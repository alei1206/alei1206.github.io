<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>test</title>
    <link href="/2024/11/17/flink/test/"/>
    <url>/2024/11/17/flink/test/</url>
    
    <content type="html"><![CDATA[<p>asdfasf</p><p>sdf</p><p><img src="/assets/image-20241117155405793.png" alt="image-20241117155405793"></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>3.10-Netty的FastThreadLocal</title>
    <link href="/2024/06/05/Netty/3.10-Netty%E7%9A%84FastThreadLocal/"/>
    <url>/2024/06/05/Netty/3.10-Netty%E7%9A%84FastThreadLocal/</url>
    
    <content type="html"><![CDATA[<h1 id="1-ThreadLocal存在的问题"><a href="#1-ThreadLocal存在的问题" class="headerlink" title="1 ThreadLocal存在的问题"></a>1 ThreadLocal存在的问题</h1><p>ThreadLocalMap使用线性探测法存储ThreadLocal对象及其维护的数据，具体操作逻辑如下：</p><ul><li>假设有一个新的ThreadLocal对象，通过hash计算它应存储的位置下标为x。</li><li>此时发现下标x对应位置已经存储了其他的ThreadLocal对象，则它会往后寻找，步长为1，下标变更为x+1。</li><li>接下来发现下标x+1对应位置也已经存储了其他的ThreadLocal对象，同理则它会继续往后寻找，下标变更为x+2。</li><li>直到寻找到下标为x+3时发现是空闲的，然后将该ThreadLocal对象及其维护的数据构建一个entry对象存储在x+3位置。</li></ul><p>在ThreadLocalMap中数据很多的情况下，很容易出现hash冲突，解决冲突需要不断的向下遍历，<strong>该操作的时间复杂度为O(n)</strong> ，效率较低。</p><h1 id="2-FastThreadLocal"><a href="#2-FastThreadLocal" class="headerlink" title="2 FastThreadLocal"></a>2 FastThreadLocal</h1><h2 id="2-1-FastThreadLocal使用"><a href="#2-1-FastThreadLocal使用" class="headerlink" title="2.1 FastThreadLocal使用"></a>2.1 FastThreadLocal使用</h2><p><code>FastThreadLocal</code> 的使用方法几乎和 <code>ThreadLocal</code> 保持一致，只需要把代码中 <code>Thread</code>、<code>ThreadLocal</code> 替换为<code>FastThreadLocalThread</code> 和 <code>FastThreadLocal</code> 即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastThreadLocalTest</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FastThreadLocal&lt;String&gt; THREAD_NAME_LOCAL = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastThreadLocal</span>&lt;&gt;();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> FastThreadLocal&lt;TradeOrder&gt; TRADE_THREAD_LOCAL = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastThreadLocal</span>&lt;&gt;();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;<br>            <span class="hljs-type">int</span> <span class="hljs-variable">tradeId</span> <span class="hljs-operator">=</span> i;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">threadName</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;thread-&quot;</span> + i;<br>            <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastThreadLocalThread</span>(() -&gt; &#123;<br>                THREAD_NAME_LOCAL.set(threadName);<br>                <span class="hljs-type">TradeOrder</span> <span class="hljs-variable">tradeOrder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TradeOrder</span>(tradeId, tradeId % <span class="hljs-number">2</span> == <span class="hljs-number">0</span> ? <span class="hljs-string">&quot;已支付&quot;</span> : <span class="hljs-string">&quot;未支付&quot;</span>);<br>                TRADE_THREAD_LOCAL.set(tradeOrder);<br>                System.out.println(<span class="hljs-string">&quot;threadName: &quot;</span> + THREAD_NAME_LOCAL.get());<br>                System.out.println(<span class="hljs-string">&quot;tradeOrder info：&quot;</span> + TRADE_THREAD_LOCAL.get());<br>            &#125;, threadName).start();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-FastThreadLocal结构"><a href="#2-2-FastThreadLocal结构" class="headerlink" title="2.2 FastThreadLocal结构"></a>2.2 FastThreadLocal结构</h2><p>在ThreadLcoal的使用上，主要有<code>Thread</code>、<code>ThreadLocal</code>、<code>ThreadLocalMap</code>三个对象进行相互配合，因此Netty在对ThreadLocal进行优化时，也从这三个类进行入手，构建出<code>FastThreadLocalThread</code>、<code>FastThreadLocal</code>、<code>InternalThreadLocalMap</code>。</p><h3 id="2-2-1-FastThreadLocalThread"><a href="#2-2-1-FastThreadLocalThread" class="headerlink" title="2.2.1 FastThreadLocalThread"></a>2.2.1 FastThreadLocalThread</h3><p><code>FastThreadLocalThread</code>如下，其主要是新增<code>InternalThreadLocalMap</code>变量。由此可推断，在使用<code>FastThreadLocal</code>时，其<code>FastThreadLocal</code>对象是存储在<code>InternalThreadLocalMap</code>中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastThreadLocalThread</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Thread</span> &#123;<br>    <span class="hljs-keyword">private</span> InternalThreadLocalMap threadLocalMap;<br>    <span class="hljs-comment">// 省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-InternalThreadLocalMap"><a href="#2-2-2-InternalThreadLocalMap" class="headerlink" title="2.2.2 InternalThreadLocalMap"></a>2.2.2 InternalThreadLocalMap</h3><p>上文中我们讲到了 ThreadLocal 的一个重要缺点，就是 <strong>ThreadLocalMap 采用线性探测法解决 Hash 冲突性能较慢</strong>。为解决此问题，<code>InternalThreadLocalMap</code> 并没有使用线性探测法来解决 Hash 冲突，而是在 <code>FastThreadLocal</code> 初始化的时候分配一个数组索引 index，index 的值采用原子类 AtomicInteger 保证顺序递增，通过调用 <code>InternalThreadLocalMap.nextVariableIndex()</code> 方法获得。然后在读写数据的时候通过数组下标 index 直接定位到 <code>FastThreadLocal</code> 的位置，<strong>时间复杂度为 O(1)</strong> 。如果数组下标递增到非常大，那么数组也会比较大，所以 <code>FastThreadLocal</code> 是通过空间换时间的思想提升读写性能。具体代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">InternalThreadLocalMap</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">UnpaddedInternalThreadLocalMap</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">DEFAULT_ARRAY_LIST_INITIAL_CAPACITY</span> <span class="hljs-operator">=</span> <span class="hljs-number">8</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> STRING_BUILDER_INITIAL_SIZE;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> STRING_BUILDER_MAX_SIZE;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">UNSET</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>();<br>    <span class="hljs-keyword">private</span> BitSet cleanerFlags;<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">InternalThreadLocalMap</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(newIndexedVariableTable());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Object[] newIndexedVariableTable() &#123;<br>        Object[] array = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Object</span>[<span class="hljs-number">32</span>];<br>        Arrays.fill(array, UNSET);<br>        <span class="hljs-keyword">return</span> array;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">nextVariableIndex</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> nextIndex.getAndIncrement();<br>        <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) &#123;<br>            nextIndex.decrementAndGet();<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;too many thread-local indexed variables&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> index;<br>    &#125;<br>    <span class="hljs-comment">// 省略其他代码</span><br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">UnpaddedInternalThreadLocalMap</span> &#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;InternalThreadLocalMap&gt; slowThreadLocalMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadLocal</span>&lt;InternalThreadLocalMap&gt;();<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicInteger</span> <span class="hljs-variable">nextIndex</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicInteger</span>();<br>    Object[] indexedVariables;<br>    UnpaddedInternalThreadLocalMap(Object[] indexedVariables) &#123;<br>        <span class="hljs-built_in">this</span>.indexedVariables = indexedVariables;<br>    &#125;<br>    <span class="hljs-comment">// 省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-总结"><a href="#3-总结" class="headerlink" title="3 总结"></a>3 总结</h1><p>本节课我们对比介绍了 ThreadLocal 和 FastThreadLocal，简单总结下 FastThreadLocal 的优势。</p><ul><li><strong>高效查找</strong>。FastThreadLocal 在定位数据的时候可以直接根据数组下标 index 获取，时间复杂度 O(1)。而 JDK 原生的 ThreadLocal 在数据较多时哈希表很容易发生 Hash 冲突，线性探测法在解决 Hash 冲突时需要不停地向下寻找，效率较低。此外，FastThreadLocal 相比 ThreadLocal 数据扩容更加简单高效，FastThreadLocal 以 index 为基准向上取整到 2 的次幂作为扩容后容量，然后把原数据拷贝到新数组。而 ThreadLocal 由于采用的哈希表，所以在扩容后需要再做一轮 rehash。</li><li><strong>安全性更高</strong>。JDK 原生的 ThreadLocal 使用不当可能造成内存泄漏，只能等待线程销毁。在使用线程池的场景下，ThreadLocal 只能通过主动检测的方式防止内存泄漏，从而造成了一定的开销。然而 FastThreadLocal 不仅提供了 <code>remove()</code> 主动清除对象的方法，而且在线程池场景中 Netty 还封装了 <code>FastThreadLocalRunnable</code>，FastThreadLocalRunnable 最后会执行 <code>FastThreadLocal.removeAll()</code> 将 Set 集合中所有 FastThreadLocal 对象都清理掉，</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.1-Netty的参数介绍</title>
    <link href="/2024/06/05/Netty/4.1-Netty%E7%9A%84%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D/"/>
    <url>/2024/06/05/Netty/4.1-Netty%E7%9A%84%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D/</url>
    
    <content type="html"><![CDATA[<h1 id="1-系统参数调优"><a href="#1-系统参数调优" class="headerlink" title="1 系统参数调优"></a>1 系统参数调优</h1><h2 id="1-1-Linux系统参数"><a href="#1-1-Linux系统参数" class="headerlink" title="1.1 Linux系统参数"></a>1.1 Linux系统参数</h2><h3 id="1-1-1-单个TCP句柄打开Socket句柄数量限制"><a href="#1-1-1-单个TCP句柄打开Socket句柄数量限制" class="headerlink" title="1.1.1 单个TCP句柄打开Socket句柄数量限制"></a>1.1.1 单个TCP句柄打开Socket句柄数量限制</h3><p>进行TCP连接时，系统为每个TCP连接创建一个socket句柄，也就是一个文件句柄，但是Linux对每个进程打开的文件句柄数量做了限制，如果超出：报错“Too many open file” 。使用<code>ulimit-n [xxx]</code>可临时修改（注意： ulimit命令修改的数值只对当前登录用户的目前使用环境有效，系统重启或者用户退出后就会失效，<strong>所以可以作为程序启动脚本一部分，让它程序启动前执行</strong>）</p><h3 id="1-1-2-SO-TIMEOUT"><a href="#1-1-2-SO-TIMEOUT" class="headerlink" title="1.1.2 SO_TIMEOUT"></a>1.1.2 SO_TIMEOUT</h3><p>NIO编程都是阻塞式IO，理论上阻塞可以一直阻塞下去，因为可通过设置SO_TIMEOUT来设置最大阻塞时间。</p><h2 id="1-2-Netty支持的系统参数"><a href="#1-2-Netty支持的系统参数" class="headerlink" title="1.2 Netty支持的系统参数"></a>1.2 Netty支持的系统参数</h2><h3 id="1-2-1-SocketChannel"><a href="#1-2-1-SocketChannel" class="headerlink" title="1.2.1 SocketChannel"></a>1.2.1 SocketChannel</h3><ul><li><strong>SO_SNDBUF</strong>：TCP 数据发送缓冲区大小，默认是4K，目前Linux支持 [min， default， max]动态调整，一般不用调整这个参数。</li><li><strong>SO_RCVBUF</strong>：TCP 数据接受缓冲区大小，默认是4K，目前Linux支持 [min， default， max]动态调整，一般不用调整这个参数</li><li><strong>SO_KEEPALIVE</strong>：TCP层的keepalive，一般都是使用应用层的keepalive，所以SO_KEEPALIVE控制的TCP层keepalive默认关闭即可。</li><li><strong>SO_REUSEADDR</strong>：默认关闭，在部分场景下，如多网卡绑定相同端口或让关闭的连接端释放端口可更早的使用，可开启。是值多网卡下不同的IP相同的port进行绑定。</li><li><strong>SO_LINGER</strong>：默认不开启。是指关闭Socket的延迟时间，默认禁用该功能， socket.close（）方法立即返回</li><li><strong>IP_TOS</strong>：指ip包的优先级，是指服务质量。通过设置 IP 头部的 Type-of-Service 字段，用于描述 IP 包的优先级和 QoS 选项。例如倾向于延时还是吞吐量。默认值是0000，如果是1000则表示最小延迟，0001则表示最大吞吐量。（这个选项可能部分实现不支持）</li><li><strong>TCP_NODELAY</strong>：设置是否启用Nagle算法：用将小的碎片数据连接成更大的报文来提高发送效率。默认False，如果需要发送一些较小的报文，则需要禁用该算法。</li></ul><h2 id="1-3-ServerSocketChannel"><a href="#1-3-ServerSocketChannel" class="headerlink" title="1.3 ServerSocketChannel"></a>1.3 ServerSocketChannel</h2><p>ServerSocketChannel主要用户创建连接，并不是一个真正的连接实体，其参数较少。</p><ul><li><strong>SO_RCVBUF</strong>：接收数据缓冲区，ServerSocketChannel主要作用就是accept连接，然后创建socket channel。这个SO_RCVBUF值就是channel默认的接收缓冲区大小。为什么没有SO_SNDBUF，是因为SO_SNDBUF可在发送数据前设置，因此不需要单独提前设置值。</li><li><strong>SO_REUSEADDR</strong>：是否可以重用端☐,默认false。</li><li><strong>SO_BACKLOG</strong>：最大的等待连接数量。当并发压力较大时，服务器无法同时接收大量连接，未连接的请求将会保存到queue中，queue的大小就是SO_BACKLOG值确定，默认: 128。使用方式: <code>javaChannel().bind(localAddress, config.getBacklog());</code></li></ul><h1 id="2-Netty内部核心参数"><a href="#2-Netty内部核心参数" class="headerlink" title="2 Netty内部核心参数"></a>2 Netty内部核心参数</h1><p>Netty内部核心参数控制了Netty的内部整个行为。Netty内部核心参数分为ChannelOption与System property</p><h2 id="2-1-ChannelOption"><a href="#2-1-ChannelOption" class="headerlink" title="2.1 ChannelOption"></a>2.1 ChannelOption</h2><p>ChannelOption中，如果以SO开头，则表示是系统参数，否则表示netty内部参数。</p><ul><li><strong>WRITE_BUFFER_WATER_MARK</strong>：高低水位线、间接防止写数据OOM， 默认32k(低水位线)与64k(高水位线)。在写数据时，如果数据较多，超过高水位线，则netty会将其设置为不可写，避免OOM。注意，这个值是channel级别的，即每个连接都是默认值32与64。</li><li><strong>CONNECT_TIMEOUT_MILEIS</strong>：客户端连接服务器最大允许时间，默认30s。</li><li><strong>MAX_MESSAGES_PER_READ</strong>：最大允许“连续”读次数，默认16次。</li><li><strong>WRITE_SPIN_COUNT</strong>：最大允许“连读”写次数，默认16次。</li><li><strong>ALLOCATOR</strong>：ByteBuf分配器，默认ByteBufAllocator.DEFAULT：大多池化、堆外。</li><li><strong>RCVBUF_ALLOCATOR</strong>：数据接收ByteBuf分配大小计算器+读次数控制器， 其作用是负责计算为接收数据分配多少ByteBuf。默认AdaptiveRecvByteBufAllocator，主要有两大功能：<ul><li>动态计算下一次分配的bytebuf大小。</li><li>动态判断是否可继续读。</li></ul></li><li><strong>AUTO_READ</strong>：是否监听“读事件。默认:监听“读”事件。设置此标记的方法也触发注册或移除读事件的监听。</li><li><strong>AUTO_CLOSE</strong>：“写数据”失败，是否关闭连接。默认打开，因为不关闭，下次还写，还是失败怎么办！</li><li><strong>MESSAGE_SIZE_ESTIMATOR</strong>：数据（ByteBuf、 FileRegion等）大小计算器。默认值DefaultMessageSizeEstimator.DEFAULT 例如计算ByteBuf: byteBuf.readableBytes()</li><li><strong>SINGLE_EVENTEXECUTOR_PER_GROUP</strong>：当增加一个handler且指定EventExecutorGroup时，决定这个handler是否只用EventExecutorGroup中的一个固定的executor(取决于next()实现。默认为true，无论handler是否共享，都会唯一的绑定一个eventExecutor。</li><li><strong>ALLOW_HALF_CLOSURE</strong>：关闭连接时，是否允许半关。默认不允许。</li></ul><h2 id="2-2-系统属性"><a href="#2-2-系统属性" class="headerlink" title="2.2 系统属性"></a>2.2 系统属性</h2><ul><li><strong>io.netty.eventLoopThreads</strong>：eventloop中 IO thread的数量，默认是availableProcessors * 2</li><li><strong>io.netty.availableProcessors</strong>：指定availableProcessors 的值。部分场景下，netty会在容器中运行，在jdk10以下，availableProcessors 的值是宿主机的cpu值，并不是容器的cpu。所以此时需要通过此参数明确指定。</li><li><strong>io.netty.allocator.type</strong>：控制bytebuf是池化或者非池化，默认池化。</li><li><strong>io.netty.noPreferDirect</strong>：控制bytebuf是堆内还是堆外，默认堆外。</li><li><strong>io.netty.noUnsafe</strong>：是否使用sun.misc.Unsafe。这些方法是jdk底层的方法，在不同版本中，这些方法可能会被移除，因此导致netty服务异常。</li><li><strong>io.netty.leakDetection.level</strong>：netty提供的内存泄露检测，默认是simple</li><li><strong>io.netty.native.workdir&#x2F;io.netty.tmpdir</strong>：netty的临时目录，会从jar中解出natice库存放的临时目录。</li><li><strong>io.netty.processld&#x2F;io.netty.machineld</strong>：进程号与机器硬件地址，作用是计算唯一的channel ID</li><li><strong>io.netty.eventLoop.maxPendingTasks&#x2F;io.netty.eventexecutor.maxPendingTasks</strong>：存的task是数目，默认是Integer最大值，不能低于16</li><li><strong>io.netty.handler.ssl.noOpenSsl</strong>：是否关闭open ssl使用，默认不关闭。</li><li><strong>workerGroup.setloRatio(50)</strong> ：设置io线程处理io事件的比例，因为在默认情况下，io线程也需要处理handle的业务逻辑，因此可通过这里设置处理IO事件的比例。</li></ul><h1 id="3-特殊参数解释"><a href="#3-特殊参数解释" class="headerlink" title="3 特殊参数解释"></a>3 特殊参数解释</h1><h2 id="3-1-地址重用SO-REUSEADDR"><a href="#3-1-地址重用SO-REUSEADDR" class="headerlink" title="3.1 地址重用SO_REUSEADDR"></a>3.1 地址重用SO_REUSEADDR</h2><p>功能：</p><ol><li>开启后多网卡绑定相同端口或让关闭的连接端释放端口可更早的使用。</li><li>多网卡下不同的IP相同的port进行绑定</li></ol><p>其中关闭的连接端释放端口可更早的使用，其原理如下：</p><p>在tcp协议中，client在关闭连接后，会有一个TIME-WAIT的时间，一般是2*(报文有效最大时间)，一般是60s，因此client的端口会在60s内不可用。因此可通过此设置，强制改变等待时间，让端口更早的可用，但是改变的时间与网络服务状态有关，如果网络服务很好，则可设置为1s，否则可能会导致错包。</p><p>​<img src="/../../images/Netty/Netty%E7%9A%84%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D.png">​</p><h2 id="3-2-SO-LINGER-scoket延迟关闭"><a href="#3-2-SO-LINGER-scoket延迟关闭" class="headerlink" title="3.2 SO_LINGER scoket延迟关闭"></a>3.2 SO_LINGER scoket延迟关闭</h2><p>就是指在关闭连接时，方法return的时间。正常默认情况下是直接返回，如果打开的话，会在收到ack后返回。</p><p>​<img src="/../../images/Netty/Netty%E7%9A%84%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D-1.png">​</p><h2 id="3-3-ALLOW-HALF-CLOSURE-半关"><a href="#3-3-ALLOW-HALF-CLOSURE-半关" class="headerlink" title="3.3 ALLOW_HALF_CLOSURE 半关"></a>3.3 ALLOW_HALF_CLOSURE 半关</h2><p>半关是指客户端与服务端关闭一个channel，如下图，半关时要调用单独的方法</p><p>​<img src="/../../images/Netty/Netty%E7%9A%84%E5%8F%82%E6%95%B0%E4%BB%8B%E7%BB%8D-2.png">​</p>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.2-Netty使用示例</title>
    <link href="/2024/06/05/Netty/4.2-Netty%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/"/>
    <url>/2024/06/05/Netty/4.2-Netty%E4%BD%BF%E7%94%A8%E7%A4%BA%E4%BE%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Netty客户端代码"><a href="#1-Netty客户端代码" class="headerlink" title="1 Netty客户端代码"></a>1 Netty客户端代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyRemotingClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">AutoCloseable</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(NettyRemotingClient.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Bootstrap</span> <span class="hljs-variable">bootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Bootstrap</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">NettyEncoder</span> <span class="hljs-variable">encoder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyEncoder</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;Host, Channel&gt; channels = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;(<span class="hljs-number">128</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">isStarted</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLoopGroup workerGroup;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> NettyClientConfig clientConfig;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Semaphore</span> <span class="hljs-variable">asyncSemaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Semaphore</span>(<span class="hljs-number">200</span>, <span class="hljs-literal">true</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExecutorService callbackExecutor;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> NettyClientHandler clientHandler;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ScheduledExecutorService responseFutureExecutor;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NettyRemotingClient</span><span class="hljs-params">(<span class="hljs-keyword">final</span> NettyClientConfig clientConfig)</span> &#123;<br>        <span class="hljs-built_in">this</span>.clientConfig = clientConfig;<br>        <span class="hljs-keyword">if</span> (Epoll.isAvailable()) &#123;<br>            <span class="hljs-built_in">this</span>.workerGroup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EpollEventLoopGroup</span>(clientConfig.getWorkerThreads(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadFactory</span>(<span class="hljs-string">&quot;NettyClient&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.workerGroup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(clientConfig.getWorkerThreads(), <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadFactory</span>(<span class="hljs-string">&quot;NettyClient&quot;</span>));<br>        &#125;<br>        <span class="hljs-built_in">this</span>.callbackExecutor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPoolExecutor</span>(<br>                Constants.CPUS,<br>                Constants.CPUS,<br>                <span class="hljs-number">1</span>,<br>                TimeUnit.MINUTES,<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedBlockingQueue</span>&lt;&gt;(<span class="hljs-number">1000</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadFactory</span>(<span class="hljs-string">&quot;CallbackExecutor&quot;</span>),<br>                <span class="hljs-keyword">new</span> <span class="hljs-title class_">CallerThreadExecutePolicy</span>());<br>        <span class="hljs-built_in">this</span>.clientHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyClientHandler</span>(<span class="hljs-built_in">this</span>, callbackExecutor);<br><br>        <span class="hljs-built_in">this</span>.responseFutureExecutor = Executors.newSingleThreadScheduledExecutor(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NamedThreadFactory</span>(<span class="hljs-string">&quot;ResponseFutureExecutor&quot;</span>));<br><br>        <span class="hljs-built_in">this</span>.start();<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br><br>        <span class="hljs-built_in">this</span>.bootstrap<br>                .group(<span class="hljs-built_in">this</span>.workerGroup)<br>                .channel(NettyUtils.getSocketChannelClass())<br>                .option(ChannelOption.SO_KEEPALIVE, clientConfig.isSoKeepalive())<br>                .option(ChannelOption.TCP_NODELAY, clientConfig.isTcpNoDelay())<br>                .option(ChannelOption.SO_SNDBUF, clientConfig.getSendBufferSize())<br>                .option(ChannelOption.SO_RCVBUF, clientConfig.getReceiveBufferSize())<br>                .option(ChannelOption.CONNECT_TIMEOUT_MILLIS, clientConfig.getConnectTimeoutMillis())<br>                .handler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> &#123;<br>                        ch.pipeline()<br>                                .addLast(<span class="hljs-string">&quot;client-idle-handler&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateHandler</span>(Constants.NETTY_CLIENT_HEART_BEAT_TIME, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, TimeUnit.MILLISECONDS))<br>                                .addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyDecoder</span>(),<br>                                        clientHandler,<br>                                        encoder);<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-built_in">this</span>.responseFutureExecutor.scheduleAtFixedRate(ResponseFuture::scanFutureTable, <span class="hljs-number">5000</span>, <span class="hljs-number">1000</span>, TimeUnit.MILLISECONDS);<br>        isStarted.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * async send</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> host host</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> command command</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeoutMillis timeoutMillis</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> invokeCallback callback function</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sendAsync</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Host host, <span class="hljs-keyword">final</span> Command command,</span><br><span class="hljs-params">                          <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> timeoutMillis,</span><br><span class="hljs-params">                          <span class="hljs-keyword">final</span> InvokeCallback invokeCallback)</span> <span class="hljs-keyword">throws</span> InterruptedException, RuntimeException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> getChannel(host);<br>        <span class="hljs-keyword">if</span> (channel == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(<span class="hljs-string">&quot;network error&quot;</span>);<br>        &#125;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * request unique identification</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">opaque</span> <span class="hljs-operator">=</span> command.getOpaque();<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         *  control concurrency number</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">acquired</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.asyncSemaphore.tryAcquire(timeoutMillis, TimeUnit.MILLISECONDS);<br>        <span class="hljs-keyword">if</span> (acquired) &#123;<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ReleaseSemaphore</span> <span class="hljs-variable">releaseSemaphore</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReleaseSemaphore</span>(<span class="hljs-built_in">this</span>.asyncSemaphore);<br><br>            <span class="hljs-comment">/*</span><br><span class="hljs-comment">             *  response future</span><br><span class="hljs-comment">             */</span><br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ResponseFuture</span> <span class="hljs-variable">responseFuture</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseFuture</span>(opaque,<br>                    timeoutMillis,<br>                    invokeCallback,<br>                    releaseSemaphore);<br>            <span class="hljs-keyword">try</span> &#123;<br>                channel.writeAndFlush(command).addListener(future -&gt; &#123;<br>                    <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                        responseFuture.setSendOk(<span class="hljs-literal">true</span>);<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        responseFuture.setSendOk(<span class="hljs-literal">false</span>);<br>                    &#125;<br>                    responseFuture.setCause(future.cause());<br>                    responseFuture.putResponse(<span class="hljs-literal">null</span>);<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        responseFuture.executeInvokeCallback();<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                        logger.error(<span class="hljs-string">&quot;execute callback error&quot;</span>, ex);<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        responseFuture.release();<br>                    &#125;<br>                &#125;);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                responseFuture.release();<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(String.format(<span class="hljs-string">&quot;send command to host: %s failed&quot;</span>, host), ex);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-type">String</span> <span class="hljs-variable">message</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;try to acquire async semaphore timeout: %d, waiting thread num: %d, total permits: %d&quot;</span>,<br>                    timeoutMillis, asyncSemaphore.getQueueLength(), asyncSemaphore.availablePermits());<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(message);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * sync send</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> host host</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message command</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> timeoutMillis timeoutMillis</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> command</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Command <span class="hljs-title function_">sendSync</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Host host, <span class="hljs-keyword">final</span> Command message, <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> timeoutMillis)</span> <span class="hljs-keyword">throws</span> InterruptedException, RemotingException &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> getChannel(host);<br>        <span class="hljs-keyword">if</span> (channel == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RuntimeException</span>(String.format(<span class="hljs-string">&quot;connect to : %s fail&quot;</span>, host));<br>        &#125;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">opaque</span> <span class="hljs-operator">=</span> message.getOpaque();<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ResponseFuture</span> <span class="hljs-variable">responseFuture</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ResponseFuture</span>(opaque, timeoutMillis, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span>);<br>        channel.writeAndFlush(message).addListener(future -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                responseFuture.setSendOk(<span class="hljs-literal">true</span>);<br>                <span class="hljs-keyword">return</span>;<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                responseFuture.setSendOk(<span class="hljs-literal">false</span>);<br>            &#125;<br>            responseFuture.setCause(future.cause());<br>            responseFuture.putResponse(<span class="hljs-literal">null</span>);<br>            logger.error(<span class="hljs-string">&quot;send command &#123;&#125; to host &#123;&#125; failed&quot;</span>, message, host);<br>        &#125;);<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * sync wait for result</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-type">Command</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> responseFuture.waitResponse();<br>        <span class="hljs-keyword">if</span> (result == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">if</span> (responseFuture.isSendOK()) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemotingTimeoutException</span>(host.toString(), timeoutMillis, responseFuture.getCause());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemotingException</span>(host.toString(), responseFuture.getCause());<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * send task</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> host host</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> message command</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Host host, <span class="hljs-keyword">final</span> Command message)</span> <span class="hljs-keyword">throws</span> RemotingException &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> getChannel(host);<br>        <span class="hljs-keyword">if</span> (channel == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemotingException</span>(String.format(<span class="hljs-string">&quot;connect to : %s fail&quot;</span>, host));<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> channel.writeAndFlush(message).await();<br>            <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                logger.debug(<span class="hljs-string">&quot;send command : &#123;&#125; , to : &#123;&#125; successfully.&quot;</span>, message, host.getAddress());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-type">String</span> <span class="hljs-variable">msg</span> <span class="hljs-operator">=</span> String.format(<span class="hljs-string">&quot;send command : %s , to :%s failed&quot;</span>, message, host.getAddress());<br>                logger.error(msg, future.cause());<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemotingException</span>(msg);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (RemotingException remotingException) &#123;<br>            <span class="hljs-keyword">throw</span> remotingException;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            logger.error(<span class="hljs-string">&quot;Send command &#123;&#125; to address &#123;&#125; encounter error.&quot;</span>, message, host.getAddress());<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemotingException</span>(String.format(<span class="hljs-string">&quot;Send command : %s , to :%s encounter error&quot;</span>, message, host.getAddress()), e);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * get channel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Channel <span class="hljs-title function_">getChannel</span><span class="hljs-params">(Host host)</span> &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> channels.get(host);<br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-literal">null</span> &amp;&amp; channel.isActive()) &#123;<br>            <span class="hljs-keyword">return</span> channel;<br>        &#125;<br>        <span class="hljs-keyword">return</span> createChannel(host, <span class="hljs-literal">true</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * create channel</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> host host</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> isSync sync flag</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> channel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> Channel <span class="hljs-title function_">createChannel</span><span class="hljs-params">(Host host, <span class="hljs-type">boolean</span> isSync)</span> &#123;<br>        ChannelFuture future;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">synchronized</span> (bootstrap) &#123;<br>                future = bootstrap.connect(<span class="hljs-keyword">new</span> <span class="hljs-title class_">InetSocketAddress</span>(host.getIp(), host.getPort()));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (isSync) &#123;<br>                future.sync();<br>            &#125;<br>            <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> future.channel();<br>                channels.put(host, channel);<br>                <span class="hljs-keyword">return</span> channel;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>            logger.warn(String.format(<span class="hljs-string">&quot;connect to %s error&quot;</span>, host), ex);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isStarted.compareAndSet(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                closeChannels();<br>                <span class="hljs-keyword">if</span> (workerGroup != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-built_in">this</span>.workerGroup.shutdownGracefully();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (callbackExecutor != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-built_in">this</span>.callbackExecutor.shutdownNow();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-built_in">this</span>.responseFutureExecutor != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-built_in">this</span>.responseFutureExecutor.shutdownNow();<br>                &#125;<br>                logger.info(<span class="hljs-string">&quot;netty client closed&quot;</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                logger.error(<span class="hljs-string">&quot;netty client close exception&quot;</span>, ex);<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * close channels</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeChannels</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">for</span> (Channel channel : <span class="hljs-built_in">this</span>.channels.values()) &#123;<br>            channel.close();<br>        &#125;<br>        <span class="hljs-built_in">this</span>.channels.clear();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * close channel</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> host host</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">closeChannel</span><span class="hljs-params">(Host host)</span> &#123;<br>        <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.channels.remove(host);<br>        <span class="hljs-keyword">if</span> (channel != <span class="hljs-literal">null</span>) &#123;<br>            channel.close();<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="2-Netty服务端代码"><a href="#2-Netty服务端代码" class="headerlink" title="2 Netty服务端代码"></a>2 Netty服务端代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> client_server;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyRemotingServer</span> &#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(NettyRemotingServer.class);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">ExecutorService</span> <span class="hljs-variable">defaultExecutor</span> <span class="hljs-operator">=</span> Executors.newFixedThreadPool(Constants.CPUS);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLoopGroup bossGroup;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> EventLoopGroup workGroup;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> NettyServerConfig serverConfig;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">NettyServerHandler</span> <span class="hljs-variable">serverHandler</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyServerHandler</span>(<span class="hljs-built_in">this</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">AtomicBoolean</span> <span class="hljs-variable">isStarted</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">AtomicBoolean</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">NETTY_BIND_FAILURE_MSG</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;NettyRemotingServer bind %s fail&quot;</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NettyRemotingServer</span><span class="hljs-params">(<span class="hljs-keyword">final</span> NettyServerConfig serverConfig)</span> &#123;<br>        <span class="hljs-built_in">this</span>.serverConfig = serverConfig;<br>        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">bossThreadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>().setDaemon(<span class="hljs-literal">true</span>).setNameFormat(<span class="hljs-string">&quot;NettyServerBossThread_%s&quot;</span>).build();<br>        <span class="hljs-type">ThreadFactory</span> <span class="hljs-variable">workerThreadFactory</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadFactoryBuilder</span>().setDaemon(<span class="hljs-literal">true</span>).setNameFormat(<span class="hljs-string">&quot;NettyServerWorkerThread_%s&quot;</span>).build();<br>        <span class="hljs-keyword">if</span> (Epoll.isAvailable()) &#123;<br>            <span class="hljs-built_in">this</span>.bossGroup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EpollEventLoopGroup</span>(<span class="hljs-number">1</span>, bossThreadFactory);<br>            <span class="hljs-built_in">this</span>.workGroup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EpollEventLoopGroup</span>(serverConfig.getWorkerThread(), workerThreadFactory);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.bossGroup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>, bossThreadFactory);<br>            <span class="hljs-built_in">this</span>.workGroup = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(serverConfig.getWorkerThread(), workerThreadFactory);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * server start</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">start</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isStarted.compareAndSet(<span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>)) &#123;<br>            <span class="hljs-built_in">this</span>.serverBootstrap<br>                    .group(<span class="hljs-built_in">this</span>.bossGroup, <span class="hljs-built_in">this</span>.workGroup)<br>                    .channel(NettyUtils.getServerSocketChannelClass())<br>                    .option(ChannelOption.SO_REUSEADDR, <span class="hljs-literal">true</span>)<br>                    .option(ChannelOption.SO_BACKLOG, serverConfig.getSoBacklog())<br>                    .childOption(ChannelOption.SO_KEEPALIVE, serverConfig.isSoKeepalive())<br>                    .childOption(ChannelOption.TCP_NODELAY, serverConfig.isTcpNoDelay())<br>                    .childOption(ChannelOption.SO_SNDBUF, serverConfig.getSendBufferSize())<br>                    .childOption(ChannelOption.SO_RCVBUF, serverConfig.getReceiveBufferSize())<br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;SocketChannel&gt;() &#123;<br><br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> &#123;<br>                            initNettyChannel(ch);<br>                        &#125;<br>                    &#125;);<br><br>            ChannelFuture future;<br>            <span class="hljs-keyword">try</span> &#123;<br>                future = serverBootstrap.bind(serverConfig.getListenPort()).sync();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                logger.error(<span class="hljs-string">&quot;NettyRemotingServer bind fail &#123;&#125;, exit&quot;</span>, e.getMessage(), e);<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteException</span>(String.format(NETTY_BIND_FAILURE_MSG, serverConfig.getListenPort()));<br>            &#125;<br>            <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>                logger.info(<span class="hljs-string">&quot;NettyRemotingServer bind success at port : &#123;&#125;&quot;</span>, serverConfig.getListenPort());<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (future.cause() != <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteException</span>(String.format(NETTY_BIND_FAILURE_MSG, serverConfig.getListenPort()), future.cause());<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemoteException</span>(String.format(NETTY_BIND_FAILURE_MSG, serverConfig.getListenPort()));<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * init netty channel</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ch socket channel</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initNettyChannel</span><span class="hljs-params">(SocketChannel ch)</span> &#123;<br>        ch.pipeline()<br>                .addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyEncoder</span>())<br>                .addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyDecoder</span>())<br>                .addLast(<span class="hljs-string">&quot;server-idle-handle&quot;</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">IdleStateHandler</span>(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, Constants.NETTY_SERVER_HEART_BEAT_TIME, TimeUnit.MILLISECONDS))<br>                .addLast(<span class="hljs-string">&quot;handler&quot;</span>, serverHandler);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ExecutorService <span class="hljs-title function_">getDefaultExecutor</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> defaultExecutor;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">close</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">if</span> (isStarted.compareAndSet(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>)) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (bossGroup != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-built_in">this</span>.bossGroup.shutdownGracefully();<br>                &#125;<br>                <span class="hljs-keyword">if</span> (workGroup != <span class="hljs-literal">null</span>) &#123;<br>                    <span class="hljs-built_in">this</span>.workGroup.shutdownGracefully();<br>                &#125;<br>                defaultExecutor.shutdown();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>                logger.error(<span class="hljs-string">&quot;netty server close exception&quot;</span>, ex);<br>            &#125;<br>            logger.info(<span class="hljs-string">&quot;netty server closed&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="3-Netty编码器"><a href="#3-Netty编码器" class="headerlink" title="3 Netty编码器"></a>3 Netty编码器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">package</span> codec;<br><br><span class="hljs-keyword">import</span> exceptions.RemotingException;<br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandler.Sharable;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.MessageToByteEncoder;<br><span class="hljs-keyword">import</span> serialize.Command;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * netty encoder</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Sharable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MessageToByteEncoder</span>&lt;Command&gt; &#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * encode</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx channel handler context</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> msg command</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out byte buffer</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Command msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemotingException</span>(<span class="hljs-string">&quot;encode msg is null&quot;</span>);<br>        &#125;<br>        out.writeByte(Command.MAGIC);<br>        out.writeByte(Command.VERSION);<br>        out.writeByte(msg.getType().ordinal());<br>        out.writeLong(msg.getOpaque());<br>        writeContext(msg, out);<br>        out.writeInt(msg.getBody().length);<br>        out.writeBytes(msg.getBody());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeContext</span><span class="hljs-params">(Command msg, ByteBuf out)</span> &#123;<br>        <span class="hljs-type">byte</span>[] headerBytes = msg.getContext().toBytes();<br>        out.writeInt(headerBytes.length);<br>        out.writeBytes(headerBytes);<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><h1 id="4-Netty解码器"><a href="#4-Netty解码器" class="headerlink" title="4 Netty解码器"></a>4 Netty解码器</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> codec;<br><br><span class="hljs-keyword">import</span> io.netty.buffer.ByteBuf;<br><span class="hljs-keyword">import</span> io.netty.channel.ChannelHandlerContext;<br><span class="hljs-keyword">import</span> io.netty.handler.codec.ReplayingDecoder;<br><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><span class="hljs-keyword">import</span> serialize.Command;<br><span class="hljs-keyword">import</span> serialize.CommandContext;<br><span class="hljs-keyword">import</span> serialize.CommandHeader;<br><span class="hljs-keyword">import</span> serialize.CommandType;<br><br><span class="hljs-keyword">import</span> java.util.List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * netty decoder</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReplayingDecoder</span>&lt;NettyDecoder.State&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.getLogger(NettyDecoder.class);<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">NettyDecoder</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-built_in">super</span>(State.MAGIC);<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">CommandHeader</span> <span class="hljs-variable">commandHeader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommandHeader</span>();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * decode</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx channel handler context</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> in byte buffer</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out out content</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">switch</span> (state()) &#123;<br>            <span class="hljs-keyword">case</span> MAGIC:<br>                checkMagic(in.readByte());<br>                checkpoint(State.VERSION);<br>                <span class="hljs-comment">// fallthru</span><br>            <span class="hljs-keyword">case</span> VERSION:<br>                checkVersion(in.readByte());<br>                checkpoint(State.COMMAND);<br>                <span class="hljs-comment">// fallthru</span><br>            <span class="hljs-keyword">case</span> COMMAND:<br>                commandHeader.setType(in.readByte());<br>                checkpoint(State.OPAQUE);<br>                <span class="hljs-comment">// fallthru</span><br>            <span class="hljs-keyword">case</span> OPAQUE:<br>                commandHeader.setOpaque(in.readLong());<br>                checkpoint(State.CONTEXT_LENGTH);<br>                <span class="hljs-comment">// fallthru</span><br>            <span class="hljs-keyword">case</span> CONTEXT_LENGTH:<br>                commandHeader.setContextLength(in.readInt());<br>                checkpoint(State.CONTEXT);<br>                <span class="hljs-comment">// fallthru</span><br>            <span class="hljs-keyword">case</span> CONTEXT:<br>                <span class="hljs-type">byte</span>[] context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[commandHeader.getContextLength()];<br>                in.readBytes(context);<br>                commandHeader.setContext(context);<br>                checkpoint(State.BODY_LENGTH);<br>                <span class="hljs-comment">// fallthru</span><br>            <span class="hljs-keyword">case</span> BODY_LENGTH:<br>                commandHeader.setBodyLength(in.readInt());<br>                checkpoint(State.BODY);<br>                <span class="hljs-comment">// fallthru</span><br>            <span class="hljs-keyword">case</span> BODY:<br>                <span class="hljs-type">byte</span>[] body = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[commandHeader.getBodyLength()];<br>                in.readBytes(body);<br>                <span class="hljs-comment">//</span><br>                <span class="hljs-type">Command</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span>();<br>                packet.setType(commandType(commandHeader.getType()));<br>                packet.setOpaque(commandHeader.getOpaque());<br>                packet.setContext(CommandContext.valueOf(commandHeader.getContext()));<br>                packet.setBody(body);<br>                out.add(packet);<br>                <span class="hljs-comment">//</span><br>                checkpoint(State.MAGIC);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">default</span>:<br>                logger.warn(<span class="hljs-string">&quot;unknown decoder state &#123;&#125;&quot;</span>, state());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * get command type</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type type</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> CommandType <span class="hljs-title function_">commandType</span><span class="hljs-params">(<span class="hljs-type">byte</span> type)</span> &#123;<br>        <span class="hljs-keyword">for</span> (CommandType ct : CommandType.values()) &#123;<br>            <span class="hljs-keyword">if</span> (ct.ordinal() == type) &#123;<br>                <span class="hljs-keyword">return</span> ct;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * check magic</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> magic magic</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkMagic</span><span class="hljs-params">(<span class="hljs-type">byte</span> magic)</span> &#123;<br>        <span class="hljs-keyword">if</span> (magic != Command.MAGIC) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;illegal packet [magic]&quot;</span> + magic);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * check version</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkVersion</span><span class="hljs-params">(<span class="hljs-type">byte</span> version)</span> &#123;<br>        <span class="hljs-keyword">if</span> (version != Command.VERSION) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;illegal protocol [version]&quot;</span> + version);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">enum</span> <span class="hljs-title class_">State</span> &#123;<br>        MAGIC,<br>        VERSION,<br>        COMMAND,<br>        OPAQUE,<br>        CONTEXT_LENGTH,<br>        CONTEXT,<br>        BODY_LENGTH,<br>        BODY;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>4.3-Netty内存泄漏检测</title>
    <link href="/2024/06/05/Netty/4.3-Netty%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/"/>
    <url>/2024/06/05/Netty/4.3-Netty%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-内存泄漏检测"><a href="#1-内存泄漏检测" class="headerlink" title="1 内存泄漏检测"></a>1 内存泄漏检测</h1><p>Netty也自带了内存泄漏检测工具，可用于检测出<strong>ByteBuf对象被GC回收，但ByteBuf管理的内存没有释放</strong>的情况，但不适用ByteBuf对象还没被GC回收内存泄漏的情况，例如任务队列积压</p><p>为了便于用户发现内存泄露，Netty提供4个检测级别：</p><ul><li>disabled 完全关闭内存泄露检测</li><li>simple 以约1%的抽样率检测是否泄露，默认级别</li><li>advanced 抽样率同simple，但显示详细的泄露报告</li><li>paranoid 抽样率为100%，显示报告信息同advanced</li></ul><p>使用方法是在命令行参数设置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">-Dio.netty.leakDetectionLevel=[检测级别]<br></code></pre></td></tr></table></figure><p>示例程序如下，设置检测级别为paranoid ：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// -Dio.netty.leakDetectionLevel=paranoid</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">500000</span>; ++i) &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> UnpooledByteBufAllocator.DEFAULT.buffer(<span class="hljs-number">1024</span>);<br>        byteBuf = <span class="hljs-literal">null</span>;    <br>    &#125;<br>    System.gc();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看到控制台输出泄漏报告：</p><p>可以看到控制台输出泄漏报告：</p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">十二月 <span class="hljs-number">27</span>, <span class="hljs-number">2019</span> <span class="hljs-number">8</span>:<span class="hljs-number">37</span>:<span class="hljs-number">04</span> 上午 io.netty.util.<span class="hljs-type">ResourceLeakDetector</span> reportTracedLeak<br>严重: <span class="hljs-type">LEAK</span>: <span class="hljs-type">ByteBuf</span>.release<span class="hljs-literal">()</span> was not called before it&#x27;s garbage-collected. <span class="hljs-type">See</span> https:<span class="hljs-comment">//netty.io/wiki/reference-counted-objects.html for more information.</span><br><span class="hljs-type">Recent</span> access records: <br><span class="hljs-type">Created</span> at:<br>    io.netty.buffer.<span class="hljs-type">UnpooledByteBufAllocator</span>.newDirectBuffer(<span class="hljs-type">UnpooledByteBufAllocator</span>.java:<span class="hljs-number">96</span>)<br>    io.netty.buffer.<span class="hljs-type">AbstractByteBufAllocator</span>.directBuffer(<span class="hljs-type">AbstractByteBufAllocator</span>.java:<span class="hljs-number">187</span>)<br>    io.netty.buffer.<span class="hljs-type">AbstractByteBufAllocator</span>.directBuffer(<span class="hljs-type">AbstractByteBufAllocator</span>.java:<span class="hljs-number">178</span>)<br>    io.netty.buffer.<span class="hljs-type">AbstractByteBufAllocator</span>.buffer(<span class="hljs-type">AbstractByteBufAllocator</span>.java:<span class="hljs-number">115</span>)<br>    org.caison.netty.demo.memory.<span class="hljs-type">BufferLeaksDemo</span>.main(<span class="hljs-type">BufferLeaksDemo</span>.java:<span class="hljs-number">15</span>)<br></code></pre></td></tr></table></figure><p>内存泄漏的原理是利用弱引用，弱引用(WeakReference)创建时需要指定引用队列(refQueue)，通过将ByteBuf对象用弱引用包装起来（代码入口位于<code>AbstractByteBufAllocator#toLeakAwareBuffer()</code>方法）</p><p>当发生GC时，如果GC线程检测到ByteBuf对象只被弱引用对象关联，会将该WeakReference加入refQueue；<br>当ByteBuf内存被正常释放，会调用WeakReference的<code>clear()</code>方法解除对ByteBuf的引用，后续GC线程不会再将该WeakReference加入refQueue；</p><p>Netty在每次创建ByteBuf时，基于抽样率，抽样命中时会轮询(poll)refQueue中的WeakReference对象，轮询返回的非null的WeakReference关联的ByteBuf即为泄漏的堆外内存(代码入口位于<code>ResourceLeakDetector#track()</code>方法)</p>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.9-Netty的设计模式</title>
    <link href="/2024/06/04/Netty/3.9-Netty%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2024/06/04/Netty/3.9-Netty%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1 单例模式"></a>1 单例模式</h1><p>单例模式是最常见的设计模式，它可以保证全局只有一个实例，避免线程安全问题。单例模式有很多种实现方法，其中我比较推荐三种最佳实践：<strong>双重检验锁</strong>、<strong>静态内部类方式</strong>、<strong>饿汉方式</strong>和<strong>枚举方式</strong>，其中双重检验锁和静态内部类方式属于懒汉式单例，饿汉方式和枚举方式属于饿汉式单例。</p><h1 id="2-工厂方法模式"><a href="#2-工厂方法模式" class="headerlink" title="2 工厂方法模式"></a>2 工厂方法模式</h1><p>工厂模式封装了对象创建的过程，使用者不需要关心对象创建的细节。在需要生成复杂对象的场景下，都可以使用工厂模式实现。工厂模式分为三种：<strong>简单工厂模式</strong>、<strong>工厂方法模式</strong>和<strong>抽象工厂模式</strong>。</p><ul><li><strong>简单工厂模式</strong>。定义一个工厂类，根据参数类型返回不同类型的实例。适用于对象实例类型不多的场景，如果对象实例类型太多，每增加一种类型就要在工厂类中增加相应的创建逻辑，这是违背开放封闭原则的。</li><li><strong>工厂方法模式</strong>。简单工厂模式的升级版，不再是提供一个统一的工厂类来创建所有对象的实例，而是每种类型的对象实例都对应不同的工厂类，每个具体的工厂类只能创建一个类型的对象实例。</li><li><strong>抽象工厂模式</strong>。较少使用，适用于创建多个产品的场景。如果按照工厂方法模式的实现思路，需要在具体工厂类中实现多个工厂方法，是非常不友好的。抽象工厂模式就是把这些工厂方法单独剥离到抽象工厂类中，然后创建工厂对象并通过组合的方式来获取工厂方法。<br>Netty 在创建 Channel 的时候使用的就是工厂方法模式，因为服务端和客户端的 Channel 是不一样的。Netty 将反射和工厂方法模式结合在一起，只使用一个工厂类，然后根据传入的 Class 参数来构建出对应的 Channel，不需要再为每一种 Channel 类型创建一个工厂类。具体源码实现如下：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReflectiveChannelFactory</span>&lt;T <span class="hljs-keyword">extends</span> <span class="hljs-title class_">Channel</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelFactory</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Constructor&lt;? <span class="hljs-keyword">extends</span> <span class="hljs-title class_">T</span>&gt; constructor;<br>    <span class="hljs-keyword">public</span> <span class="hljs-title function_">ReflectiveChannelFactory</span><span class="hljs-params">(Class&lt;? extends T&gt; clazz)</span> &#123;<br>        ObjectUtil.checkNotNull(clazz, <span class="hljs-string">&quot;clazz&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-built_in">this</span>.constructor = clazz.getConstructor();<br>        &#125; <span class="hljs-keyword">catch</span> (NoSuchMethodException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;Class &quot;</span> + StringUtil.simpleClassName(clazz) +<br>                    <span class="hljs-string">&quot; does not have a public non-arg constructor&quot;</span>, e);<br>        &#125;<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> T <span class="hljs-title function_">newChannel</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> constructor.newInstance();<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;Unable to create Channel from class &quot;</span> + constructor.getDeclaringClass(), t);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String <span class="hljs-title function_">toString</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> StringUtil.simpleClassName(ReflectiveChannelFactory.class) +<br>                <span class="hljs-string">&#x27;(&#x27;</span> + StringUtil.simpleClassName(constructor.getDeclaringClass()) + <span class="hljs-string">&quot;.class)&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-责任链模式"><a href="#3-责任链模式" class="headerlink" title="3 责任链模式"></a>3 责任链模式</h1><p>责任链模式自然而然联想到 ChannlPipeline 和 <code>ChannelHandler</code>。ChannlPipeline 内部是由一组 ChannelHandler 实例组成的，内部通过双向链表将不同的 ChannelHandler 链接在一起</p><p><img src="/../../images/Netty/Netty%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.png"></p><h1 id="4-观察者模式"><a href="#4-观察者模式" class="headerlink" title="4 观察者模式"></a>4 观察者模式</h1><p>观察者模式有两个角色：观察者和被观察。被观察者发布消息，观察者订阅消息，没有订阅的观察者是收不到消息的。首先我们通过一个简单的例子看下观察者模式的是如何实现的。<br>Netty 中观察者模式的运用非常多，但是并没有以上示例代码这么直观，我们平时经常使用的<code>ChannelFuture#addListener</code> 接口就是观察者模式的实现。我们先来看下 ChannelFuture 使用的示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">channelFuture</span> <span class="hljs-operator">=</span> channel.writeAndFlush(object);<br>channelFuture.addListener(future -&gt; &#123;<br>    <span class="hljs-keyword">if</span> (future.isSuccess()) &#123;<br>       <span class="hljs-comment">// do something</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// do something</span><br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><p>addListener 方法会将添加监听器添加到 ChannelFuture 当中，并在 ChannelFuture 执行完毕的时候立刻通知已经注册的监听器。所以 ChannelFuture 是被观察者，addListener 方法用于添加观察者。</p><h1 id="5-建造者模式"><a href="#5-建造者模式" class="headerlink" title="5 建造者模式"></a>5 建造者模式</h1><p>建造者模式非常简单，通过链式调用来设置对象的属性，在对象属性繁多的场景下非常有用。建造者模式的优势就是可以像搭积木一样自由选择需要的属性，并不是强绑定的。对于使用者来说，必须清楚需要设置哪些属性，在不同场景下可能需要的属性也是不一样的。</p><p>Netty 中 ServerBootStrap 和 Bootstrap 引导器是最经典的建造者模式实现，在构建过程中需要设置非常多的参数，例如配置线程池 EventLoopGroup、设置 Channel 类型、注册 ChannelHandler、设置 Channel 参数、端口绑定等。</p><h1 id="6-策略模式"><a href="#6-策略模式" class="headerlink" title="6 策略模式"></a>6 策略模式</h1><p>策略模式针对同一个问题提供多种策略的处理方式，这些策略之间可以相互替换，在一定程度上提高了系统的灵活性。策略模式非常符合开闭原则，使用者在不修改现有系统的情况下选择不同的策略，而且便于扩展增加新的策略。</p><p>Netty 在多处地方使用了策略模式，例如 EventExecutorChooser 提供了不同的策略选择 NioEventLoop，<code>newChooser()</code> 方法会根据线程池的大小是否是 2 的幂次，以此来动态的选择取模运算的方式，从而提高性能。EventExecutorChooser 源码实现如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">DefaultEventExecutorChooserFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">EventExecutorChooserFactory</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">DefaultEventExecutorChooserFactory</span> <span class="hljs-variable">INSTANCE</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultEventExecutorChooserFactory</span>();<br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">DefaultEventExecutorChooserFactory</span><span class="hljs-params">()</span> &#123; &#125;<br>    <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> EventExecutorChooser <span class="hljs-title function_">newChooser</span><span class="hljs-params">(EventExecutor[] executors)</span> &#123;<br>        <span class="hljs-keyword">if</span> (isPowerOfTwo(executors.length)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PowerOfTwoEventExecutorChooser</span>(executors);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">GenericEventExecutorChooser</span>(executors);<br>        &#125;<br>    &#125;  <br><br>    <span class="hljs-comment">// 省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="7-装饰者模式"><a href="#7-装饰者模式" class="headerlink" title="7 装饰者模式"></a>7 装饰者模式</h1><p>装饰器模式是对被装饰类的功能增强，在不修改被装饰类的前提下，能够为被装饰类添加新的功能特性。当我们需要为一个类扩展功能时会使用装饰器模式，但是该模式的缺点是需要增加额外的代码。</p><p>在Netty 中使用WrappedByteBuf装饰 ByteBuf ，源码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">WrappedByteBuf</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ByteBuf</span> &#123;<br><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> ByteBuf buf;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">WrappedByteBuf</span><span class="hljs-params">(ByteBuf buf)</span> &#123;<br>        <span class="hljs-keyword">if</span> (buf == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NullPointerException</span>(<span class="hljs-string">&quot;buf&quot;</span>);<br>        &#125;<br>        <span class="hljs-built_in">this</span>.buf = buf;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">hasMemoryAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> buf.hasMemoryAddress();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-title function_">memoryAddress</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">return</span> buf.memoryAddress();<br>    &#125;<br>    <span class="hljs-comment">// 省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="8-其他设计模式"><a href="#8-其他设计模式" class="headerlink" title="8 其他设计模式"></a>8 其他设计模式</h1><ul><li>模板方法模式：ServerBootStrap 和 Bootstrap 的 init 过程实现；</li><li>迭代器模式：CompositeByteBuf；</li><li>适配器模式：ScheduledFutureTask。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.1-Netty引用计数机制</title>
    <link href="/2024/06/03/Netty/3.1-Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/06/03/Netty/3.1-Netty%E5%BC%95%E7%94%A8%E8%AE%A1%E6%95%B0%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1 介绍"></a>1 介绍</h1><p>引用计数是一种常用的内存管理机制，是指将资源的被引用次数保存起来，当被引用次数变为零时就将其释放的过程。Netty在4.x版本开始使用引用计数机制进行部分对象的管理，其实现思路并不是特别复杂，它主要涉及跟踪某个对象被引用的次数。在Netty具体代码中需要通过引用计数进行内存管理的对象，会基于ReferenceCounted接口实现，其中引用计数大于0时则代表该对象被引用不会释放，当引用计数减少到0时，该对象就会被释放。通过引用计数机制，Netty可以很好的实现内存管理，引用计数减少到0时要么直接释放内存，要么放回内存池中重复利用。</p><h1 id="2-实现细节"><a href="#2-实现细节" class="headerlink" title="2 实现细节"></a>2 实现细节</h1><h2 id="2-1-计数实现"><a href="#2-1-计数实现" class="headerlink" title="2.1 计数实现"></a>2.1 计数实现</h2><p>在内部，使用refCnt的值表示计数值，为提高性能，使用位运算的机制进行修改引用数据。</p><ul><li>初始化refCnt的值为2</li><li>如果是增加一个引用计数，则refCnt左移1位（x2）。</li><li>refCnt的值是内部的引用计数，如果要计算实际的引用数量，则通过公式计算<code>rawCnt != 2 &amp;&amp; rawCnt != 4 &amp;&amp; (rawCnt &amp; 1) != 0 ? 0 : rawCnt &gt;&gt;&gt; 1</code></li></ul><h2 id="2-2-新增计数"><a href="#2-2-新增计数" class="headerlink" title="2.2 新增计数"></a>2.2 新增计数</h2><p>具体实现代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> T <span class="hljs-title function_">retain</span><span class="hljs-params">(T instance)</span> &#123;<br>    <span class="hljs-keyword">return</span> retain0(instance, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>);<br>&#125;<br><br><span class="hljs-comment">// rawIncrement == increment &lt;&lt; 1  增量=真实增量x2</span><br><span class="hljs-keyword">private</span> T <span class="hljs-title function_">retain0</span><span class="hljs-params">(T instance, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> increment, <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> rawIncrement)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">oldRef</span> <span class="hljs-operator">=</span> updater().getAndAdd(instance, rawIncrement);  <span class="hljs-comment">//使用updater对象进行原子更新，然后返回旧值</span><br>    <span class="hljs-keyword">if</span> (oldRef != <span class="hljs-number">2</span> &amp;&amp; oldRef != <span class="hljs-number">4</span> &amp;&amp; (oldRef &amp; <span class="hljs-number">1</span>) != <span class="hljs-number">0</span>) &#123;   <span class="hljs-comment">//判断旧值是否有效，即不能是奇数。</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalReferenceCountException</span>(<span class="hljs-number">0</span>, increment);<br>    &#125;<br>    <span class="hljs-comment">// don&#x27;t pass 0!</span><br>    <span class="hljs-keyword">if</span> ((oldRef &lt;= <span class="hljs-number">0</span> &amp;&amp; oldRef + rawIncrement &gt;= <span class="hljs-number">0</span>)  <span class="hljs-comment">//经过0就说明有溢出了，要处理掉</span><br>        || (oldRef &gt;= <span class="hljs-number">0</span> &amp;&amp; oldRef + rawIncrement &lt; oldRef)) &#123;<br>        <span class="hljs-comment">// overflow case</span><br>        updater().getAndAdd(instance, -rawIncrement);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalReferenceCountException</span>(realRefCnt(oldRef), increment);<br>    &#125;<br>    <span class="hljs-keyword">return</span> instance;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-3-释放计数"><a href="#2-3-释放计数" class="headerlink" title="2.3 释放计数"></a>2.3 释放计数</h2><p>释放的时候会先调用nonVolatileRawCnt获得引用计数，然后判断引用计数是否是2或者减的值就是真实引用计数值，是的话就可以尝试直接设置的方法tryFinalRelease0，如果失败会去尝试释放方法retryRelease0，这个是自旋，直到成功为止。如果不是的话就普通的引用计数器值的修改即可nonFinalRelease0。当然这里可能会对引用已经是1的再进行释放，这样就会在retryRelease0中的toLiveRealRefCnt检测报异常，避免了重复释放，而且里面修改值都是原子操作，线程安全的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//减少计数1，返回是否真正释放</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(T instance)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rawCnt</span> <span class="hljs-operator">=</span> nonVolatileRawCnt(instance);<span class="hljs-comment">//获取引用计数 如果引用计数rawCnt == 2 说明真实计数是1，就可以直接尝试最终释放，否则就真实计数减1，这个就算已经释放也不会报错</span><br>    <span class="hljs-keyword">return</span> rawCnt == <span class="hljs-number">2</span> ? tryFinalRelease0(instance, <span class="hljs-number">2</span>) || retryRelease0(instance, <span class="hljs-number">1</span>)<br>        : nonFinalRelease0(instance, <span class="hljs-number">1</span>, rawCnt, toLiveRealRefCnt(rawCnt, <span class="hljs-number">1</span>));<br>&#125;<br><span class="hljs-comment">//减少计数decrement，返回是否真正释放</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">release</span><span class="hljs-params">(T instance, <span class="hljs-type">int</span> decrement)</span> &#123;<br>    <span class="hljs-type">int</span> <span class="hljs-variable">rawCnt</span> <span class="hljs-operator">=</span> nonVolatileRawCnt(instance);<span class="hljs-comment">//获取引用计数</span><br>    <span class="hljs-type">int</span> <span class="hljs-variable">realCnt</span> <span class="hljs-operator">=</span> toLiveRealRefCnt(rawCnt, checkPositive(decrement, <span class="hljs-string">&quot;decrement&quot;</span>));<span class="hljs-comment">//获取真实计数</span><br>    <span class="hljs-keyword">return</span> decrement == realCnt ? tryFinalRelease0(instance, rawCnt) || retryRelease0(instance, decrement)<br>        : nonFinalRelease0(instance, decrement, rawCnt, realCnt);<span class="hljs-comment">//</span><br>&#125;<br><span class="hljs-comment">//尝试最终释放 如果引用计数是2的话，就直接设为1，释放内存，否则就失败</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">tryFinalRelease0</span><span class="hljs-params">(T instance, <span class="hljs-type">int</span> expectRawCnt)</span> &#123;<br>    <span class="hljs-keyword">return</span> updater().compareAndSet(instance, expectRawCnt, <span class="hljs-number">1</span>); <span class="hljs-comment">// any odd number will work</span><br>&#125;<br><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">nonFinalRelease0</span><span class="hljs-params">(T instance, <span class="hljs-type">int</span> decrement, <span class="hljs-type">int</span> rawCnt, <span class="hljs-type">int</span> realCnt)</span> &#123;<br>    <span class="hljs-keyword">if</span> (decrement &lt; realCnt <span class="hljs-comment">//更新引用计数</span><br>        <span class="hljs-comment">// all changes to the raw count are 2x the &quot;real&quot; change - overflow is OK</span><br>        &amp;&amp; updater().compareAndSet(instance, rawCnt, rawCnt - (decrement &lt;&lt; <span class="hljs-number">1</span>))) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> retryRelease0(instance, decrement);<br>&#125;<br><span class="hljs-comment">//自旋设置引用计数或者尝试释放</span><br><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">retryRelease0</span><span class="hljs-params">(T instance, <span class="hljs-type">int</span> decrement)</span> &#123;<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">rawCnt</span> <span class="hljs-operator">=</span> updater().get(instance), realCnt = toLiveRealRefCnt(rawCnt, decrement);<br>        <span class="hljs-keyword">if</span> (decrement == realCnt) &#123;<span class="hljs-comment">//真实的计数和要减去的计数一样的话</span><br>            <span class="hljs-keyword">if</span> (tryFinalRelease0(instance, rawCnt)) &#123;<span class="hljs-comment">//尝试最终释放</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (decrement &lt; realCnt) &#123;<span class="hljs-comment">//真实计数大于减去的计数，还不能释放，只是减去decrement</span><br>            <span class="hljs-comment">// all changes to the raw count are 2x the &quot;real&quot; change</span><br>            <span class="hljs-keyword">if</span> (updater().compareAndSet(instance, rawCnt, rawCnt - (decrement &lt;&lt; <span class="hljs-number">1</span>))) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalReferenceCountException</span>(realCnt, -decrement);<br>        &#125;<br>        Thread.<span class="hljs-keyword">yield</span>(); <span class="hljs-comment">// this benefits throughput under high contention 提示释放CPU，增加吞吐量</span><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="2-4-ReferenceCountUpdater原子更新"><a href="#2-4-ReferenceCountUpdater原子更新" class="headerlink" title="2.4 ReferenceCountUpdater原子更新"></a>2.4 ReferenceCountUpdater原子更新</h2><p>在上述的新增计数与释放计数过程中，都是使用updater()获取更新具体的update对象，其是一个<code>AtomicIntegerFieldUpdater&lt;AbstractReferenceCountedByteBuf&gt;</code>原子对象，其新增操作等是使用cas机制来控制不同线程并发的安全性。</p>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.2-Netty心跳机制</title>
    <link href="/2024/06/03/Netty/3.2-Netty%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/06/03/Netty/3.2-Netty%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-TCP-保活机制"><a href="#1-TCP-保活机制" class="headerlink" title="1 TCP 保活机制"></a>1 TCP 保活机制</h1><p>Netty 是 基于 TCP 协议开发的，在四层协议 TCP 协议的实现中也提供了 keepalive 报文用来探测对端是否可用。TCP 层将在定时时间到后发送相应的 KeepAlive 探针以确定连接可用性。<br><code>tcp-keepalive</code>，操作系统内核支持，但是不默认开启, 应用需要自行开启，开启之后有三个参数会生效，来决定一个 keepalive 的行为。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs makedown">Copynet.ipv4.tcp_keepalive_time = 7200<br>net.ipv4.tcp_keepalive_probes = 9<br>net.ipv4.tcp_keepalive_intvl = 75<br></code></pre></td></tr></table></figure><p><strong>tcp_keepalive_time</strong>： 在 TCP 保活打开的情况下，最后一次数据交换到 TCP 发送第一个保活探测包的间隔，即允许的持续空闲时长，或者说每次正常发送心跳的周期，默认值为7200s（2h）；<br><strong>tcp_keepalive_probes</strong>： 在 tcp_keepalive_time 之后，没有接收到对方确认，继续发送保活探测包次数，默认值为9（次）；<br><strong>tcp_keepalive_intvl</strong>：在 tcp_keepalive_time 之后，没有接收到对方确认，继续发送保活探测包的发送频率，默认值为75s。</p><p>TCP KeepAlive 是用于检测连接的死活，而心跳机制则附带一个额外的功能：<strong>检测通讯双方的存活状态</strong>。两者听起来似乎是一个意思，但实际上却大相径庭。</p><p>考虑一种情况，某台服务器因为某些原因导致负载超高，CPU 100%，无法响应任何业务请求，但是使用 TCP 探针则仍旧能够确定连接状态，这就是典型的连接活着但业务提供方已死的状态，对客户端而言，这时的最好选择就是断线后重新连接其他服务器，而不是一直认为当前服务器是可用状态一直向当前服务器发送些必然会失败的请求。</p><p>可以通过如下命令查看系统 <code>tcp-keepalive</code> 参数配置：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Copysysctl -a | grep keepalive<br><span class="hljs-built_in">cat</span> /proc/sys/net/ipv4/tcp_keepalive_time<br>sysctl net.ipv4.tcp_keepalive_time<br></code></pre></td></tr></table></figure><p>Netty 中也提供了设置 tcp-keepalive 的设置：<br>​<img src="/../../images/Netty/Netty%E5%BF%83%E8%B7%B3%E6%9C%BA%E5%88%B6.png">​</p><p>设置：<code>ChannelOption.SO_KEEPALIVE, true</code> 表示打开 TCP 的 keepAlive 设置。</p><h1 id="2-Netty中的心跳机制"><a href="#2-Netty中的心跳机制" class="headerlink" title="2 Netty中的心跳机制"></a>2 Netty中的心跳机制</h1><h2 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h2><p>TCP 基础协议中的 keep-live 机制存在一定的限制，如只考虑 tcp 是否存活等，在某种场景下，如 tcp 连接存活，但是 cpu 占用100%，这种场景下，客户端应该连接其他的服务器比较好，因此 Netty 中也提供了应用层的心跳机制。<br>Netty 中的心跳机制实现主要是通过 IdleStateHandler，IdleStateHandler 是一个双向的 handle，能够检测进站与出站请求。在使用时有以下注意点：</p><ol><li>IdleStateHandler 在添加进pipeline 的时机必须在用户 handle 之前，因为 IdleStateHandler 在检测到超时后，会在 pipeline 中添加一个 event 事件，需要在用户 handle 中触发执行相关逻辑。</li><li>在用户 handle 中，必须重写 <code>userEventTriggered()</code>，以捕获心跳事件，然后对事件进行相关处理。</li></ol><h2 id="2-2-相关源码"><a href="#2-2-相关源码" class="headerlink" title="2.2 相关源码"></a>2.2 相关源码</h2><h3 id="2-2-1-整体逻辑"><a href="#2-2-1-整体逻辑" class="headerlink" title="2.2.1 整体逻辑"></a>2.2.1 整体逻辑</h3><p>部分代码如下所示：</p><ol><li>IdleStateHandler 是 ChannelDuplexHandler 的子集，所以在消息进出站时，都会被触发。</li><li>在连接建立时，会触发 initialize (ctx); 逻辑，执行初始化相关操作。</li><li>Initialize ()是重点方法，会执行相关初始化动作，在初始化时，会启动相关的定时线程，定时运行某个任务，以判断是否心跳超时等。<ol><li>初始化当前时间，即 lastReadTime 与 lastWriteTime</li><li>调用 schedule ()来延迟执行检测逻辑，即向线程池中添加读空闲、写空闲、所有空闲检测，在延迟部分时间后，会执行相关的逻辑。在执行检测逻辑时，会再次向线程池中添加检测逻辑，以达到一直检测的目的。</li><li>在检测时，如果出现超时等异常情况，会触发生成 IdleStateEvent 时间，并将此时间添加到 channel 中，在后续的 handle 中被 <code>userEventTriggered()</code> 逻辑处理。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IdleStateHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelDuplexHandler</span> &#123;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        initialize(ctx);<br>        <span class="hljs-built_in">super</span>.channelActive(ctx);<br>    &#125;<br>    <br>    <span class="hljs-comment">//········省略部分代码············</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initialize</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br>        <span class="hljs-comment">// Avoid the case where destroy() is called before scheduling timeouts.</span><br>        <span class="hljs-comment">// See: https://github.com/netty/netty/issues/143</span><br>        <span class="hljs-keyword">switch</span> (state) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>:<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        state = <span class="hljs-number">1</span>;<br>        initOutputChanged(ctx);<br><br>        lastReadTime = lastWriteTime = ticksInNanos();<br>        <span class="hljs-keyword">if</span> (readerIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;<br>            readerIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> <span class="hljs-title class_">ReaderIdleTimeoutTask</span>(ctx),<br>                    readerIdleTimeNanos, TimeUnit.NANOSECONDS);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (writerIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;<br>            writerIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> <span class="hljs-title class_">WriterIdleTimeoutTask</span>(ctx),<br>                    writerIdleTimeNanos, TimeUnit.NANOSECONDS);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (allIdleTimeNanos &gt; <span class="hljs-number">0</span>) &#123;<br>            allIdleTimeout = schedule(ctx, <span class="hljs-keyword">new</span> <span class="hljs-title class_">AllIdleTimeoutTask</span>(ctx),<br>                    allIdleTimeNanos, TimeUnit.NANOSECONDS);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-2-读超时检测"><a href="#2-2-2-读超时检测" class="headerlink" title="2.2.2 读超时检测"></a>2.2.2 读超时检测</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ReaderIdleTimeoutTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelHandlerContext ctx;<br><br>  ReaderIdleTimeoutTask(ChannelHandlerContext ctx) &#123;<br>    <span class="hljs-built_in">this</span>.ctx = ctx;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!ctx.channel().isOpen()) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><span class="hljs-comment">// nextDelay = 当前时间-最后一次时间</span><br>    <span class="hljs-type">long</span> <span class="hljs-variable">nextDelay</span> <span class="hljs-operator">=</span> readerIdleTimeNanos;<br>    <span class="hljs-keyword">if</span> (!reading) &#123;<br>      nextDelay -= System.nanoTime() - lastReadTime;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (nextDelay &lt;= <span class="hljs-number">0</span>) &#123;<br>     <span class="hljs-comment">// 重新定义readerIdleTimeout schedule，与initialize方法设置的相同，继续执行定时任务</span><br>      readerIdleTimeout =<br>        ctx.executor().schedule(<span class="hljs-built_in">this</span>, readerIdleTimeNanos, TimeUnit.NANOSECONDS);<br>      <span class="hljs-keyword">try</span> &#123;<br>       <span class="hljs-comment">// event = new IdleStateEvent(IdleState.READER_IDLE, true)，将event设置为读空闲</span><br>        <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> newIdleStateEvent(IdleState.READER_IDLE, firstReaderIdleEvent);<br>        <span class="hljs-keyword">if</span> (firstReaderIdleEvent) &#123;<br>          firstReaderIdleEvent = <span class="hljs-literal">false</span>;<br>        &#125;<br><span class="hljs-comment">//channelIdle的主要工作就是将evt传输给下一个Handler</span><br>        channelIdle(ctx, event);<br>      &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        ctx.fireExceptionCaught(t);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果nextDelay&gt;0，则说明客户端在规定时间内已经写入数据了</span><br>      <span class="hljs-comment">// 重新定义readerIdleTimeout schedule，以nextDelay为执行频率</span><br>      readerIdleTimeout = ctx.executor().schedule(<span class="hljs-built_in">this</span>, nextDelay, TimeUnit.NANOSECONDS);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-3-写超时检测"><a href="#2-2-3-写超时检测" class="headerlink" title="2.2.3 写超时检测"></a>2.2.3 写超时检测</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WriterIdleTimeoutTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br><br>  <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChannelHandlerContext ctx;<br><br>  WriterIdleTimeoutTask(ChannelHandlerContext ctx) &#123;<br>    <span class="hljs-built_in">this</span>.ctx = ctx;<br>  &#125;<br><br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (!ctx.channel().isOpen()) &#123;<br>      <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">long</span> <span class="hljs-variable">lastWriteTime</span> <span class="hljs-operator">=</span> IdleStateHandler.<span class="hljs-built_in">this</span>.lastWriteTime;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">nextDelay</span> <span class="hljs-operator">=</span> writerIdleTimeNanos - (System.nanoTime() - lastWriteTime);<br>    <span class="hljs-keyword">if</span> (nextDelay &lt;= <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// Writer is idle - set a new timeout and notify the callback.</span><br>      writerIdleTimeout = ctx.executor().schedule(<br>        <span class="hljs-built_in">this</span>, writerIdleTimeNanos, TimeUnit.NANOSECONDS);<br>      <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> newIdleStateEvent(IdleState.WRITER_IDLE, firstWriterIdleEvent);<br>        <span class="hljs-keyword">if</span> (firstWriterIdleEvent) &#123;<br>          firstWriterIdleEvent = <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        channelIdle(ctx, event);<br>      &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        ctx.fireExceptionCaught(t);<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// Write occurred before the timeout - set a new timeout with shorter delay.</span><br>      writerIdleTimeout = ctx.executor().schedule(<span class="hljs-built_in">this</span>, nextDelay, TimeUnit.NANOSECONDS);<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-4-读写超时检测"><a href="#2-2-4-读写超时检测" class="headerlink" title="2.2.4 读写超时检测"></a>2.2.4 读写超时检测</h3><p>读写超时检测，会通过检测最后一次的读时间或者写时间，与当前时间比较是否超时，然后决定当前是否触发读写超时事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AllIdleTimeoutTask</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractIdleTask</span> &#123;<br><br>    AllIdleTimeoutTask(ChannelHandlerContext ctx) &#123;<br>        <span class="hljs-built_in">super</span>(ctx);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> &#123;<br><br>        <span class="hljs-type">long</span> <span class="hljs-variable">nextDelay</span> <span class="hljs-operator">=</span> allIdleTimeNanos;<br>        <span class="hljs-keyword">if</span> (!reading) &#123;<br>            nextDelay -= ticksInNanos() - Math.max(lastReadTime, lastWriteTime);<br>        &#125;<br>        <span class="hljs-keyword">if</span> (nextDelay &lt;= <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// Both reader and writer are idle - set a new timeout and</span><br>            <span class="hljs-comment">// notify the callback.</span><br>            allIdleTimeout = schedule(ctx, <span class="hljs-built_in">this</span>, allIdleTimeNanos, TimeUnit.NANOSECONDS);<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">first</span> <span class="hljs-operator">=</span> firstAllIdleEvent;<br>            firstAllIdleEvent = <span class="hljs-literal">false</span>;<br><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (hasOutputChanged(ctx, first)) &#123;<br>                    <span class="hljs-keyword">return</span>;<br>                &#125;<br><br>                <span class="hljs-type">IdleStateEvent</span> <span class="hljs-variable">event</span> <span class="hljs-operator">=</span> newIdleStateEvent(IdleState.ALL_IDLE, first);<br>                channelIdle(ctx, event);<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                Ctx.FireExceptionCaught (t);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// Either read or write occurred before the timeout - set a new</span><br>            <span class="hljs-comment">// timeout with shorter delay.</span><br>            AllIdleTimeout = schedule (ctx, <span class="hljs-built_in">this</span>, nextDelay, TimeUnit. NANOSECONDS);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-Netty-心跳-Demo"><a href="#3-Netty-心跳-Demo" class="headerlink" title="3 Netty 心跳 Demo"></a>3 Netty 心跳 Demo</h1><p>一般情况下，netty 的客户端需要与 netty 的服务端之间维持心跳，其作用有：</p><ol><li>Netty 客户端向服务端发送心跳，表明自身存活。</li><li>Netty 服务端接收心跳，在心跳超时时，关闭相关连接。</li></ol><p>因此整体逻辑如下：</p><ol><li>向客户端的 pipeline 中添加 IdleStateHandler，增加读写空闲检测。</li><li>在客户端的 handle 中添加<code>userEventTriggered ()</code>​逻辑，在此逻辑中增加向服务端发送心跳信息的逻辑，即当 IdleStateHandler 中检测到读写空闲超时后，通过 <code>userEventTriggered()</code>​发送心跳信息。</li><li>在服务端的 pipeline 中添加 IdleStateHandler，增加读写空闲超时检测。</li><li>在服务端的 handle 中添加 <code>userEventTriggered()</code>​逻辑中增加关闭连接的逻辑，即服务端在发生读写空闲超时后，即说明是客户端的心跳包未接收到，即关闭连接。</li><li>为保证正常，服务端的心跳检测时间应该是客户端的心跳检测2倍，保证不会被误删除连接。</li></ol><blockquote><p><a href="https://cloud.tencent.com/developer/article/1846196">https://cloud.tencent.com/developer/article/1846196</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.3-Netty的零拷贝</title>
    <link href="/2024/06/03/Netty/3.3-Netty%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D/"/>
    <url>/2024/06/03/Netty/3.3-Netty%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="1-传统-Linux-中的零拷贝技术"><a href="#1-传统-Linux-中的零拷贝技术" class="headerlink" title="1 传统 Linux 中的零拷贝技术"></a>1 传统 Linux 中的零拷贝技术</h1><h2 id="1-1-初始"><a href="#1-1-初始" class="headerlink" title="1.1 初始"></a>1.1 初始</h2><p>所谓零拷贝，就是在数据操作时，不需要将数据从一个内存位置拷贝到另外一个内存位置，这样可以减少一次内存拷贝的损耗，从而节省了 CPU 时钟周期和内存带宽。</p><p>从文件中读取数据，然后将数据传输到网络上，那么传统的数据拷贝过程从数据读取到发送一共经历了<strong>四次数据拷贝</strong>，具体流程如下：</p><ol><li>当用户进程发起 read() 调用后，上下文从用户态切换至内核态。DMA 引擎从文件中读取数据，并存储到内核态缓冲区，这里是<strong>第一次数据拷贝</strong>。</li><li>请求的数据从内核态缓冲区拷贝到用户态缓冲区，然后返回给用户进程。第二次数据拷贝的过程同时，会导致上下文从内核态再次切换到用户态。</li><li>用户进程调用 send() 方法期望将数据发送到网络中，此时会触发第三次线程切换，用户态会再次切换到内核态，请求的数据从用户态缓冲区被拷贝到 Socket 缓冲区。</li><li>最终 send() 系统调用结束返回给用户进程，发生了第四次上下文切换。第四次拷贝会异步执行，从 Socket 缓冲区拷贝到协议引擎中。</li></ol><p>​<img src="/../../images/Netty/Netty%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D-5.png">​</p><h2 id="1-2-零拷贝进阶1"><a href="#1-2-零拷贝进阶1" class="headerlink" title="1.2 零拷贝进阶1"></a>1.2 零拷贝进阶1</h2><p>在零拷贝技术引入后，第二次和第三次拷贝是可以去除的，DMA 引擎从文件读取数据后放入到内核缓冲区，然后可以直接从内核缓冲区传输到 Socket 缓冲区，从而减少内存拷贝的次数。</p><p><strong>在 Linux 中系统调用 sendfile() 可以实现将数据从一个文件描述符传输到另一个文件描述符，从而实现了零拷贝技术</strong>。在 Java 中也使用了零拷贝技术，它就是 NIO FileChannel 类中的 <code>transferTo()</code> 方法，<code>transferTo()</code> 底层就依赖了操作系统零拷贝的机制，它可以将数据从 FileChannel 直接传输到另外一个 Channel。</p><p>具体步骤如下：</p><p>​<img src="/../../images/Netty/Netty%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D.png">​</p><h2 id="1-3-零拷贝进阶2"><a href="#1-3-零拷贝进阶2" class="headerlink" title="1.3 零拷贝进阶2"></a>1.3 零拷贝进阶2</h2><p>比较大的一个变化是，DMA 引擎从文件中读取数据拷贝到内核态缓冲区之后，由操作系统直接拷贝到 Socket 缓冲区，不再拷贝到用户态缓冲区，所以数据拷贝的次数从之前的 4 次减少到 3 次。</p><p>但是上述的优化离达到零拷贝的要求还是有差距的，能否继续减少内核中的数据拷贝次数呢？在 Linux 2.4 版本之后，开发者对 Socket Buffer 追加一些 Descriptor 信息来进一步减少内核数据的复制。如下图所示，DMA 引擎读取文件内容并拷贝到内核缓冲区，然后并没有再拷贝到 Socket 缓冲区，只是将数据的长度以及位置信息被追加到 Socket 缓冲区，然后 DMA 引擎根据这些描述信息，直接从内核缓冲区读取数据并传输到协议引擎中，从而消除最后一次 CPU 拷贝。</p><p>​<img src="/../../images/Netty/Netty%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D-6.png">​</p><p>其实从 Linux 操作系统的角度来说，<strong>零拷贝就是为了避免用户态和内存态之间的数据拷贝</strong>。无论是传统的数据拷贝还是使用零拷贝技术，其中<strong>有 2 次 DMA 的数据拷贝必不可少</strong>，只是这 2 次 DMA 拷贝都是依赖硬件来完成，不需要 CPU 参与。所以，在这里我们讨论的零拷贝是个广义的概念，<strong>只要能够减少不必要的 CPU 拷贝，都可以被称为零拷贝</strong>。</p><h1 id="2-Netty-的零拷贝技术"><a href="#2-Netty-的零拷贝技术" class="headerlink" title="2 Netty 的零拷贝技术"></a>2 Netty 的零拷贝技术</h1><p>Netty 中的零拷贝和传统 Linux 的零拷贝不太一样。Netty 中的零拷贝技术除了操作系统级别的功能封装，更多的是面向用户态的数据操作优化，主要体现在以下 5 个方面：</p><ul><li><strong>堆外内存</strong>，避免 JVM 堆内存到堆外内存的数据拷贝。</li><li><strong>CompositeByteBuf 类</strong>，可以组合多个 Buffer 对象合并成一个逻辑上的对象，避免通过传统内存拷贝的方式将几个 Buffer 合并成一个大的 Buffer。</li><li><strong>Unpooled.wrappedBuffer</strong>：通过 <code>Unpooled.wrappedBuffer</code> 可以将 byte 数组包装成 ByteBuf 对象，包装过程中不会产生内存拷贝。</li><li><strong>ByteBuf.slice</strong> 操作与 Unpooled.wrappedBuffer 相反，slice 操作可以将一个 ByteBuf 对象切分成多个 ByteBuf 对象，切分过程中不会产生内存拷贝，底层共享一个 byte 数组的存储空间。</li><li>Netty 使用 <strong>FileRegion</strong> 实现文件传输，FileRegion 底层封装了 FileChannel#transferTo() 方法，可以将文件缓冲区的数据直接传输到目标 Channel，避免内核缓冲区和用户态缓冲区之间的数据拷贝，这属于操作系统级别的零拷贝。</li></ul><h2 id="2-1-堆外内存"><a href="#2-1-堆外内存" class="headerlink" title="2.1 堆外内存"></a>2.1 堆外内存</h2><p>如果在 JVM 内部执行 I&#x2F;O 操作时，必须将数据拷贝到堆外内存，才能执行系统调用。这是所有 VM 语言都会存在的问题。那么为什么操作系统不能直接使用 JVM 堆内存进行 I&#x2F;O 的读写呢？主要有两点原因：第一，操作系统并不感知 JVM 的堆内存，而且 JVM 的内存布局与操作系统所分配的是不一样的，操作系统并不会按照 JVM 的行为来读写数据。第二，同一个对象的内存地址随着 JVM GC 的执行可能会随时发生变化，例如 JVM GC 的过程中会通过压缩来减少内存碎片，这就涉及对象移动的问题了。</p><p>Netty 在进行 I&#x2F;O 操作时都是使用的堆外内存，可以避免数据从 JVM 堆内存到堆外内存的拷贝。</p><h2 id="2-2-CompositeByteBuf"><a href="#2-2-CompositeByteBuf" class="headerlink" title="2.2 CompositeByteBuf"></a>2.2 CompositeByteBuf</h2><p>CompositeByteBuf 是 Netty 中实现零拷贝机制非常重要的一个数据结构，CompositeByteBuf 可以理解为一个虚拟的 Buffer 对象，它是由多个 ByteBuf 组合而成，但是在 <strong>CompositeByteBuf 内部保存着每个 ByteBuf 的引用关系，从逻辑上构成一个整体</strong>。</p><p>CompositeByteBuf 通过调用 addComponents() 方法来添加多个 ByteBuf，但是底层的 byte 数组是复用的，不会发生内存拷贝。但对于用户来说，它可以当作一个整体进行操作。其内部结构如下所示，其本质是添加到CompositeByteBuf 中是buff，只是记录逻辑上的关系，并不是真正的物理上的拷贝，在读取的时候，也是根据逻辑上的关系，去真正的存放buff的位置去读取。</p><p>​<img src="/../../images/Netty/Netty%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D-7.png">​</p><h2 id="2-3-Unpooled-wrappedBuffer-操作"><a href="#2-3-Unpooled-wrappedBuffer-操作" class="headerlink" title="2.3 Unpooled.wrappedBuffer 操作"></a>2.3 Unpooled.wrappedBuffer 操作</h2><p>Unpooled.wrappedBuffer 方法可以将不同的数据源的一个或者多个数据包装成一个大的 ByteBuf 对象，其中数据源的类型包括 byte[]、ByteBuf、ByteBuffer。包装的过程中不会发生数据拷贝操作，包装后生成的 ByteBuf 对象和原始 ByteBuf 对象是共享底层的 byte 数组。也是如CompositeByteBuf一样，进行逻辑上的封装</p><h2 id="2-4-ByteBuf-slice-操作"><a href="#2-4-ByteBuf-slice-操作" class="headerlink" title="2.4 ByteBuf.slice 操作"></a>2.4 ByteBuf.slice 操作</h2><p>ByteBuf.slice 和 Unpooled.wrappedBuffer 的逻辑正好相反，ByteBuf.slice 是将一个 ByteBuf 对象切分成多个共享同一个底层存储的 ByteBuf 对象。</p><p>通过 slice 切分后都会返回一个新的 ByteBuf 对象，而且新的对象有自己独立的 readerIndex、writerIndex 索引，如下图所示。由于新的 ByteBuf 对象与原始的 ByteBuf 对象数据是共享的，所以通过新的 ByteBuf 对象进行数据操作也会对原始 ByteBuf 对象生效。</p><p>​<img src="/../../images/Netty/Netty%E7%9A%84%E9%9B%B6%E6%8B%B7%E8%B4%9D-8.png">​</p><h2 id="2-5-文件传输-FileRegion"><a href="#2-5-文件传输-FileRegion" class="headerlink" title="2.5 文件传输 FileRegion"></a>2.5 文件传输 FileRegion</h2><p>在 Netty 源码的 example 包中，提供了 FileRegion 的使用示例，以下代码片段摘自 FileServerHandler.java。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, String msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-type">RandomAccessFile</span> <span class="hljs-variable">raf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        raf = <span class="hljs-keyword">new</span> <span class="hljs-title class_">RandomAccessFile</span>(msg, <span class="hljs-string">&quot;r&quot;</span>);<br>        length = raf.length();<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        ctx.writeAndFlush(<span class="hljs-string">&quot;ERR: &quot;</span> + e.getClass().getSimpleName() + <span class="hljs-string">&quot;: &quot;</span> + e.getMessage() + <span class="hljs-string">&#x27;\n&#x27;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (length &lt; <span class="hljs-number">0</span> &amp;&amp; raf != <span class="hljs-literal">null</span>) &#123;<br>            raf.close();<br>        &#125;<br>    &#125;<br>    ctx.write(<span class="hljs-string">&quot;OK: &quot;</span> + raf.length() + <span class="hljs-string">&#x27;\n&#x27;</span>);<br>    <span class="hljs-keyword">if</span> (ctx.pipeline().get(SslHandler.class) == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// SSL not enabled - can use zero-copy file transfer.</span><br>        ctx.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultFileRegion</span>(raf.getChannel(), <span class="hljs-number">0</span>, length));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// SSL enabled - cannot use zero-copy file transfer.</span><br>        ctx.write(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChunkedFile</span>(raf));<br>    &#125;<br>    ctx.writeAndFlush(<span class="hljs-string">&quot;\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>从 FileRegion 的使用示例可以看出，Netty 使用 FileRegion 实现文件传输的零拷贝。FileRegion 的默认实现类是 DefaultFileRegion，通过 DefaultFileRegion 将文件内容写入到 NioSocketChannel。</p><p>FileRegion 其实就是对 FileChannel 的包装，并没有什么特殊操作，底层使用的是 JDK NIO 中的 FileChannel#transferTo() 方法实现文件传输，所以 FileRegion 是操作系统级别的零拷贝，对于传输大文件会很有帮助。</p>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.4-Netty的定时任务时间轮</title>
    <link href="/2024/06/03/Netty/3.4-Netty%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%97%B6%E9%97%B4%E8%BD%AE/"/>
    <url>/2024/06/03/Netty/3.4-Netty%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%97%B6%E9%97%B4%E8%BD%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="1-时间轮原理分析"><a href="#1-时间轮原理分析" class="headerlink" title="1 时间轮原理分析"></a>1 时间轮原理分析</h1><p>如下图所示，时间轮可以理解为一种环形结构，像钟表一样被分为多个 slot 槽位。每个 slot 代表一个时间段，每个 slot 中可以存放多个任务，使用的是链表结构保存该时间段到期的所有任务。时间轮通过一个时针随着时间一个个 slot 转动，并执行 slot 中的所有到期任务。</p><p><img src="/../../images/Netty/Netty%E7%9A%84%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1%E6%97%B6%E9%97%B4%E8%BD%AE.png"></p><p>任务是如何添加到时间轮当中的呢？可以根据任务的到期时间进行取模，然后将任务分布到不同的 slot 中。如上图所示，时间轮被划分为 8 个 slot，每个 slot 代表 1s，当前时针指向 2。假如现在需要调度一个 3s 后执行的任务，应该加入 2+3&#x3D;5 的 slot 中；如果需要调度一个 12s 以后的任务，需要等待时针完整走完一圈 round 零 4 个 slot，需要放入第 (2+12)%8&#x3D;6 个 slot。</p><p>那么当时针走到第 6 个 slot 时，怎么区分每个任务是否需要立即执行，还是需要等待下一圈 round，甚至更久时间之后执行呢？所以我们需要把 round 信息保存在任务中。例如图中第 6 个 slot 的链表中包含 3 个任务，第一个任务 round&#x3D;0，需要立即执行；第二个任务 round&#x3D;1，需要等待 1*8&#x3D;8s 后执行；第三个任务 round&#x3D;2，需要等待 2*8&#x3D;8s 后执行。所以当时针转动到对应 slot 时，只执行 round&#x3D;0 的任务，slot 中其余任务的 round 应当减 1，等待下一个 round 之后执行。</p><p>上面介绍了时间轮算法的基本理论，可以看出时间轮有点类似 HashMap，如果多个任务如果对应同一个 slot，处理冲突的方法采用的是拉链法。在任务数量比较多的场景下，适当增加时间轮的 slot 数量，可以减少时针转动时遍历的任务个数。</p><p>时间轮定时器最大的优势就是，任务的新增和取消都是 O(1) 时间复杂度，而且只需要一个线程就可以驱动时间轮进行工作。HashedWheelTimer 是 Netty 中时间轮算法的实现类，下面我就结合 HashedWheelTimer 的源码详细分析时间轮算法的实现原理。</p><h1 id="2-时间轮使用"><a href="#2-时间轮使用" class="headerlink" title="2 时间轮使用"></a>2 时间轮使用</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HashedWheelTimerTest</span> &#123;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        <span class="hljs-type">Timer</span> <span class="hljs-variable">timer</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashedWheelTimer</span>();<br>        <span class="hljs-type">Timeout</span> <span class="hljs-variable">timeout1</span> <span class="hljs-operator">=</span> timer.newTimeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Timeout timeout)</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;timeout1: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            &#125;<br><br>        &#125;, <span class="hljs-number">10</span>, TimeUnit.SECONDS);<br>        <span class="hljs-keyword">if</span> (!timeout1.isExpired()) &#123;<br>            timeout1.cancel();<br>        &#125;<br>        timer.newTimeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Timeout timeout)</span> <span class="hljs-keyword">throws</span> InterruptedException &#123;<br>                System.out.println(<span class="hljs-string">&quot;timeout2: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>                Thread.sleep(<span class="hljs-number">5000</span>);<br>            &#125;<br>        &#125;, <span class="hljs-number">1</span>, TimeUnit.SECONDS);<br>        timer.newTimeout(<span class="hljs-keyword">new</span> <span class="hljs-title class_">TimerTask</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(Timeout timeout)</span> &#123;<br>                System.out.println(<span class="hljs-string">&quot;timeout3: &quot;</span> + <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>());<br>            &#125;<br>        &#125;, <span class="hljs-number">3</span>, TimeUnit.SECONDS);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.5-Netty的异常传播机制</title>
    <link href="/2024/06/03/Netty/3.5-Netty%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/06/03/Netty/3.5-Netty%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="1-异常传播方式"><a href="#1-异常传播方式" class="headerlink" title="1 异常传播方式"></a>1 异常传播方式</h1><p>ChannelPipeline 事件传播的实现采用了经典的责任链模式，调用链路环环相扣。如果一个handle出现异常，如果用户没进行异常捕获处理，则会将异常按顺序从 Head 节点传播到 Tail 节点，最后将由 Tail 节点统一处理。异常事件的处理顺序与 <strong>ChannelHandler 的添加顺序相同，会依次向后传播，与 Inbound 事件和 Outbound 事件无关</strong>。</p><p>虽然 Netty 中 TailContext 提供了兜底的异常处理逻辑，但是在很多场景下，并不能满足我们的需求。假如你需要拦截指定的异常类型，并做出相应的异常处理。</p><h1 id="2-异常处理的最佳实践"><a href="#2-异常处理的最佳实践" class="headerlink" title="2 异常处理的最佳实践"></a>2 异常处理的最佳实践</h1><p>在 Netty 应用开发的过程中，良好的异常处理机制会让排查问题的过程事半功倍。所以推荐用户对异常进行统一拦截，然后根据实际业务场景实现更加完善的异常处理机制。通过异常传播机制的学习，我们应该可以想到最好的方法是在 ChannelPipeline 自定义处理器的末端添加统一的异常处理器，此时 ChannelPipeline 的内部结构如下图所示。</p><p><img src="/../../images/Netty/Netty%E7%9A%84%E5%BC%82%E5%B8%B8%E4%BC%A0%E6%92%AD%E6%9C%BA%E5%88%B6.png"></p><p>用户自定义的异常处理器代码示例如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ExceptionHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelDuplexHandler</span> &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> &#123;<br>        <span class="hljs-keyword">if</span> (cause <span class="hljs-keyword">instanceof</span> RuntimeException) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Handle Business Exception Success.&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.6-Netty对象池</title>
    <link href="/2024/06/03/Netty/3.6-Netty%E5%AF%B9%E8%B1%A1%E6%B1%A0/"/>
    <url>/2024/06/03/Netty/3.6-Netty%E5%AF%B9%E8%B1%A1%E6%B1%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="1-概述"><a href="#1-概述" class="headerlink" title="1 概述"></a>1 概述</h1><h2 id="1-1-Recycler整体结构"><a href="#1-1-Recycler整体结构" class="headerlink" title="1.1 Recycler整体结构"></a>1.1 Recycler整体结构</h2><p>池化是我们提升性能的手段之一，比如线程池、内存池以及接下来讲的对象池。池化的作用目的是减少创建和销毁对象的开销，提高并发处理能力，而且利用池化也可以降低 GC 压力。Netty 设计了一个简易的对象池，在 Netty 内存使用广泛，比如对 <code>PooledUnsafeDirectByteBuf</code> 对象进行池化。</p><p>Recycler 是 Netty 提供的自定义实现的轻量级对象回收站，借助 Recycler 可以完成对象的获取和回收。既然 Recycler 是 Netty 自己实现的对象池，其内部结构如下图所示，主要结构有：<strong>Recycler、Stack、WeakOrderQueue、Link、DefaultHandle</strong>。</p><p><img src="/../../images/Netty/Netty%E5%AF%B9%E8%B1%A1%E6%B1%A0.png"></p><p>在整个 Recycler 的内部结构中各个组件的关系如下图所示：</p><p>​<img src="/../../images/Netty/Netty%E5%AF%B9%E8%B1%A1%E6%B1%A0-1.png">​</p><h2 id="1-2-Stack"><a href="#1-2-Stack" class="headerlink" title="1.2 Stack"></a>1.2 Stack</h2><p>Stack 是整个对象池的顶层数据结构，描述了整个对象池的构造，用于存储当前本线程回收的对象。在多线程的场景下，Netty 为了避免锁竞争问题，每个线程都会持有各自的对象池，内部通过 FastThreadLocal 来实现每个线程的私有化。Stack的源码定义如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Stack</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">final</span> Recycler&lt;T&gt; parent; <span class="hljs-comment">// 所属的 Recycler</span><br>    <span class="hljs-keyword">final</span> WeakReference&lt;Thread&gt; threadRef; <span class="hljs-comment">// 所属线程的弱引用</span><br>    <span class="hljs-keyword">final</span> AtomicInteger availableSharedCapacity; <span class="hljs-comment">// 异线程回收对象时，其他线程能保存的被回收对象的最大个数</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxDelayedQueues; <span class="hljs-comment">// WeakOrderQueue最大个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> maxCapacity; <span class="hljs-comment">// 对象池的最大大小，默认最大为 4k</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> ratioMask; <span class="hljs-comment">// 控制对象的回收比率，默认只回收 1/8 的对象</span><br>    <span class="hljs-keyword">private</span> DefaultHandle&lt;?&gt;[] elements; <span class="hljs-comment">// 存储缓存数据的数组</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> size; <span class="hljs-comment">// 缓存的 DefaultHandle 对象个数</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">handleRecycleCount</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>; <br>    <span class="hljs-comment">// WeakOrderQueue 链表的三个重要节点</span><br>    <span class="hljs-keyword">private</span> WeakOrderQueue cursor, prev;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> WeakOrderQueue head;<br>    <span class="hljs-comment">// 省略其他代码</span><br>&#125;<br></code></pre></td></tr></table></figure><p>对应Recycler内部组件图可知：</p><ul><li><code>elements</code>： Stack内部使用<code>DefaultHandle&lt;?&gt;[] elements</code>存储本线程回收的对象。为避免并发性能问题，每个线程内部会有一个私有的线程池，如对象a由线程a创建，且由线程a回收，则在回收时，会将对象a直接放入到elements数组中。</li><li><code>cursor、prev、head</code>：Stack内部使用WeakOrderQueue存储异线程回收的对象。如对象a由线程a创建，且由线程b回收，此时对象a不能直接放到线程a的elements数组中，需要将其放到对应的WeakOrderQueue中，由此就可以避免并发问题。在合适的时候，线程a会从内部stack的WeakOrderQueue中收割异线程回收的对象，将其转移到elements中，以达到对象复用。</li><li><code>Link</code>：每个 WeakOrderQueue 中都包含一个 Link 链表，回收对象都会被存在 Link 链表中的节点上，每个 Link 节点默认存储 16 个对象，当每个 Link 节点存储满了会创建新的 Link 节点放入链表尾部。</li><li><code>DefaultHandle</code>：DefaultHandle 实例中保存了实际回收的对象，Stack 和 WeakOrderQueue 都使用 DefaultHandle 存储回收的对象。在 Stack 中包含一个 elements 数组，该数组保存的是 DefaultHandle 实例。DefaultHandle 中每个 Link 节点所存储的 16 个对象也是使用 DefaultHandle 表示的。可以理解为，Netty使用DefaultHandle对被收回的对象进行封装。</li><li><code>ratioMask</code>：控制对象的回收速率，默认只回收 1&#x2F;8 的对象，即8个对象只回收一个对象。</li></ul><h2 id="1-3-WeakOrderQueue"><a href="#1-3-WeakOrderQueue" class="headerlink" title="1.3 WeakOrderQueue"></a>1.3 WeakOrderQueue</h2><p>WeakOrderQueue是一个特殊的数据结构，用于缓存异线程回收的本线程所创建的对象。主要属性如下：</p><ul><li>head：标识WeakOrderQueue内部Link链表的头结点。</li><li>tail：标识WeakOrderQueue内部Link链表的尾结点。</li><li>next：指向下一个WeakOrderQueue，每个WeakOrderQueue对应一个异线程，因为会有多个异线程使用本线程的对象，所以会有多个WeakOrderQueue，通过next属性来获取下个WeakOrderQueue。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">WeakOrderQueue</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">WeakReference</span>&lt;Thread&gt; &#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Head head;<br>        <span class="hljs-keyword">private</span> Link tail;<br>        <span class="hljs-comment">// pointer to another queue of delayed items for the same stack</span><br>        <span class="hljs-keyword">private</span> WeakOrderQueue next;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-从-Recycler-中获取对象"><a href="#2-从-Recycler-中获取对象" class="headerlink" title="2 从 Recycler 中获取对象"></a>2 从 Recycler 中获取对象</h1><p>从对象池中获取对象的入口是在 <code>Recycler#get()</code> 方法，源码如下，主要逻辑是从stack中获取对应的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> T <span class="hljs-title function_">get</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (maxCapacityPerThread == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">return</span> newObject((Handle&lt;T&gt;) NOOP_HANDLE);<br>    &#125;<br>    Stack&lt;T&gt; stack = threadLocal.get();  <span class="hljs-comment">//获取此线程对应的stack</span><br>    DefaultHandle&lt;T&gt; handle = stack.pop();  <span class="hljs-comment">//从stack中获取对象的包装对象handle</span><br>    <span class="hljs-keyword">if</span> (handle == <span class="hljs-literal">null</span>) &#123;<br>        handle = stack.newHandle();<br>        handle.value = newObject(handle);<br>    &#125;<br>    <span class="hljs-keyword">return</span> (T) handle.value;  <span class="hljs-comment">//从包装对象中获取缓存对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在<code>stack.pop()</code>中，如果stack对象elements数组中存在元素，则直接弹出。如果stack对象elements数组中不存在元素，则需要从内部WeakOrderQueue中收割异线程回收的对象，然后将其放入到elements数组中，然后再弹出。其主要逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">scavenge</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 尝试从 WeakOrderQueue 中转移对象实例到 Stack 中</span><br>    <span class="hljs-keyword">if</span> (scavengeSome()) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-comment">// 如果迁移失败，就会重置 cursor 指针到 head 节点</span><br>    prev = <span class="hljs-literal">null</span>;<br>    cursor = head;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-type">boolean</span> <span class="hljs-title function_">scavengeSome</span><span class="hljs-params">()</span> &#123;<br><br>    WeakOrderQueue prev;<br>    <span class="hljs-type">WeakOrderQueue</span> <span class="hljs-variable">cursor</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.cursor; <span class="hljs-comment">// cursor 指针指向当前 WeakorderQueueu 链表的读取位置</span><br>    <span class="hljs-comment">// 如果 cursor 指针为 null, 则是第一次从 WeakorderQueueu 链表中获取对象</span><br>    <span class="hljs-keyword">if</span> (cursor == <span class="hljs-literal">null</span>) &#123;<br>        prev = <span class="hljs-literal">null</span>;<br>        cursor = head;<br>        <span class="hljs-keyword">if</span> (cursor == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        prev = <span class="hljs-built_in">this</span>.prev;<br>    &#125;<br><br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-comment">// 不断循环从 WeakOrderQueue 链表中找到一个可用的对象实例</span><br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-comment">// 尝试迁移 WeakOrderQueue 中部分对象实例到 Stack 中</span><br>        <span class="hljs-keyword">if</span> (cursor.transfer(<span class="hljs-built_in">this</span>)) &#123;<br>            success = <span class="hljs-literal">true</span>;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-type">WeakOrderQueue</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> cursor.next;<br>        <span class="hljs-keyword">if</span> (cursor.owner.get() == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 如果已退出的线程还有数据</span><br>            <span class="hljs-keyword">if</span> (cursor.hasFinalData()) &#123;<br>                <span class="hljs-keyword">for</span> (;;) &#123;<br>                   <span class="hljs-keyword">if</span> (cursor.transfer(<span class="hljs-built_in">this</span>)) &#123;<br>                        success = <span class="hljs-literal">true</span>;<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>            <span class="hljs-comment">// 将已退出的线程从 WeakOrderQueue 链表中移除</span><br>            <span class="hljs-keyword">if</span> (prev != <span class="hljs-literal">null</span>) &#123;<br>                prev.setNext(next);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            prev = cursor;<br>        &#125;<br>        <span class="hljs-comment">// 将 cursor 指针指向下一个 WeakOrderQueue</span><br>        cursor = next;<br>    &#125; <span class="hljs-keyword">while</span> (cursor != <span class="hljs-literal">null</span> &amp;&amp; !success);<br>    <span class="hljs-built_in">this</span>.prev = prev;<br>    <span class="hljs-built_in">this</span>.cursor = cursor;<br>    <span class="hljs-keyword">return</span> success;<br>&#125;<br></code></pre></td></tr></table></figure><p>scavenge 的源码中首先会从 cursor 指针指向的 WeakOrderQueue 节点回收部分对象到 Stack 的 elements 数组中，如果没有回收到数据就会将 cursor 指针移到下一个 WeakOrderQueue，重复执行以上过程直至回到到对象实例为止。具体的流程可以结合下图来理解。此外，每次移动 cursor 时，都会检查 WeakOrderQueue 对应的线程是否已经退出了，如果线程已经退出，那么线程中的对象实例都会被回收，然后将 WeakOrderQueue 节点从链表中移除。</p><p>​<img src="/../../images/Netty/Netty%E5%AF%B9%E8%B1%A1%E6%B1%A0-2.png">​</p><p>还有一个问题，每次 Stack 从 WeakOrderQueue 链表会回收多少数据呢？我们依然结合上图讲解，每个 WeakOrderQueue 中都包含一个 Link 链表，Netty 每次会回收其中的一个 Link 节点所存储的对象。从图中可以看出，Link 内部会包含一个读指针 readIndex，每个 Link 节点默认存储 16 个对象，读指针到链表尾部就是可以用于回收的对象实例，每次回收对象时，readIndex 都会从上一次记录的位置开始回收。</p><p>在回收对象实例之前，Netty 会计算出可回收对象的数量，加上 Stack 中已有的对象数量后，如果超过 Stack 的当前容量且小于 Stack 的最大容量，会对 Stack 进行扩容。为了防止回收对象太多导致 Stack 的容量激增，在每次回收时 Netty 会调用 dropHandle 方法控制回收频率，具体源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">boolean</span> <span class="hljs-title function_">dropHandle</span><span class="hljs-params">(DefaultHandle&lt;?&gt; handle)</span> &#123;<br>    <span class="hljs-keyword">if</span> (!handle.hasBeenRecycled) &#123;<br>        <span class="hljs-keyword">if</span> (handleRecycleCount &lt; interval) &#123;<br>            handleRecycleCount++;<br>            <span class="hljs-comment">// Drop the object.</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>        handleRecycleCount = <span class="hljs-number">0</span>;<br>        handle.hasBeenRecycled = <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>dropHandle 方法中主要靠 hasBeenRecycled 和 handleRecycleCount 两个变量控制回收的频率，会从每 8 个未被收回的对象中选取一个进行回收，其他的都被丢弃掉。</p><p>到此为止，从 Recycler 中获取对象的主流程已经讲完了，简单总结为两点：</p><ul><li>当 Stack 中 elements 有数据时，直接从栈顶弹出。</li><li>当 Stack 中 elements 没有数据时，尝试从 WeakOrderQueue 中回收一个 Link 包含的对象实例到 Stack 中，然后从栈顶弹出。</li></ul><p>3 Recycler 对象回收原理</p><p>理解了如何从 Recycler 获取对象之后，再学习 Recycler 对象回收的原理就会清晰很多了，同样上文代码示例中定位到对象回收的源码入口 <code>DefaultHandle#recycle()</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">recycle</span><span class="hljs-params">(Object object)</span> &#123;<br>    <span class="hljs-keyword">if</span> (object != value) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(<span class="hljs-string">&quot;object does not belong to handle&quot;</span>);<br>    &#125;<br><br>    Stack&lt;?&gt; stack = <span class="hljs-built_in">this</span>.stack;<br>    <span class="hljs-keyword">if</span> (lastRecycledId != recycleId || stack == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;recycled already&quot;</span>);<br>    &#125;<br><br>    stack.push(<span class="hljs-built_in">this</span>);<br>&#125;<br><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">push</span><span class="hljs-params">(DefaultHandle&lt;?&gt; item)</span> &#123;<br>    <span class="hljs-type">Thread</span> <span class="hljs-variable">currentThread</span> <span class="hljs-operator">=</span> Thread.currentThread();<br>    <span class="hljs-keyword">if</span> (threadRef.get() == currentThread) &#123;<br>        <span class="hljs-comment">// The current Thread is the thread that belongs to the Stack, we can try to push the object now.</span><br>        pushNow(item);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-comment">// The current Thread is not the one that belongs to the Stack</span><br>        <span class="hljs-comment">// (or the Thread that belonged to the Stack was collected already), we need to signal that the push</span><br>        <span class="hljs-comment">// happens later.</span><br>        pushLater(item, currentThread);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从源码中可以看出，在回收对象时，会向 Stack 中 push 对象，push 会分为同线程回收和异线程回收两种情况，分别对应 pushNow 和 pushLater 两个方法。</p><h2 id="2-1-本线程回收对象"><a href="#2-1-本线程回收对象" class="headerlink" title="2.1 本线程回收对象"></a>2.1 本线程回收对象</h2><p>如果是当前线程回收自己分配的对象时，会调用 pushNow 方法。同线程回收对象的逻辑非常简单，就是直接向 Stack 的 elements 数组中添加数据，对象会被存放在栈顶指针指向的位置。如果超过了 Stack 的最大容量，那么对象会被直接丢弃，同样这里使用了 dropHandle 方法控制对象的回收速率，每 8 个对象会有一个被回收到 Stack 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushNow</span><span class="hljs-params">(DefaultHandle&lt;?&gt; item)</span> &#123;<br>    <span class="hljs-keyword">if</span> ((item.recycleId | item.lastRecycledId) != <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 防止被多次回收</span><br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;recycled already&quot;</span>);<br>    &#125;<br>    item.recycleId = item.lastRecycledId = OWN_THREAD_ID;<br><br>    <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.size;<br>    <span class="hljs-comment">//1. 超出最大容量 2. 控制回收速率</span><br>    <span class="hljs-keyword">if</span> (size &gt;= maxCapacity || dropHandle(item)) &#123;<br>        <span class="hljs-comment">// Hit the maximum capacity or should drop - drop the possibly youngest object.</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (size == elements.length) &#123;<br>        elements = Arrays.copyOf(elements, min(size &lt;&lt; <span class="hljs-number">1</span>, maxCapacity));<br>    &#125;<br><br>    elements[size] = item;<br>    <span class="hljs-built_in">this</span>.size = size + <span class="hljs-number">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-异线程回收对象"><a href="#2-2-异线程回收对象" class="headerlink" title="2.2 异线程回收对象"></a>2.2 异线程回收对象</h2><p>异线程回收对象时，并不会添加到 Stack 中，而是会与 WeakOrderQueue 直接打交道，pushLater 的源码如下所示，pushLater 的实现过程可以总结为两个步骤：<strong>获取 WeakOrderQueue</strong>，<strong>添加对象到 WeakOrderQueue 中</strong>。</p><p>首先看下如何获取 WeakOrderQueue 对象。通过 FastThreadLocal 取出当前对象的 DELAYED_RECYCLED 缓存，DELAYED_RECYCLED 存放着当前线程帮助其他线程回收对象的映射关系。假如 item 是 ThreadA 分配的对象，当前线程是 ThreadB，此时 ThreadB 帮助 ThreadA 回收 item，那么 DELAYED_RECYCLED 放入的 key 是 StackA。然后从 delayedRecycled 中取出 StackA 对应的 WeakOrderQueue，如果 WeakOrderQueue 不存在，那么为 StackA 新创建一个 WeakOrderQueue，并将其加入 DELAYED_RECYCLED 缓存。WeakOrderQueue.allocate() 会检查帮助 StackA 回收的对象总数是否超过 2K 个，如果没有超过 2K，会将 StackA 的 head 指针指向新创建的 WeakOrderQueue，否则不再为 StackA 回收对象。</p><p>当然 ThreadB 不会只帮助 ThreadA 回收对象，它可以帮助其他多个线程回收，所以 DELAYED_RECYCLED 使用的 Map 结构，为了防止 DELAYED_RECYCLED 内存膨胀，Netty 也采取了保护措施，从 delayedRecycled.size() &gt;&#x3D; maxDelayedQueues 可以看出，每个线程最多帮助 2 倍 CPU 核数的线程回收线程，如果超过了该阈值，假设当前对象绑定的为 StackX，那么将在 Map 中为 StackX 放入一种特殊的 WeakOrderQueue.DUMMY，表示当前线程无法帮助 StackX 回收对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">pushLater</span><span class="hljs-params">(DefaultHandle&lt;?&gt; item, Thread thread)</span> &#123;<br>    <span class="hljs-keyword">if</span> (maxDelayedQueues == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-comment">// We don&#x27;t support recycling across threads and should just drop the item on the floor.</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// we don&#x27;t want to have a ref to the queue as the value in our weak map</span><br>    <span class="hljs-comment">// so we null it out; to ensure there are no races with restoring it later</span><br>    <span class="hljs-comment">// we impose a memory ordering here (no-op on x86)</span><br>    Map&lt;Stack&lt;?&gt;, WeakOrderQueue&gt; delayedRecycled = DELAYED_RECYCLED.get(); <span class="hljs-comment">// 当前线程帮助其他线程回收对象的缓存</span><br>    <span class="hljs-type">WeakOrderQueue</span> <span class="hljs-variable">queue</span> <span class="hljs-operator">=</span> delayedRecycled.get(<span class="hljs-built_in">this</span>); <span class="hljs-comment">//取出对象绑定的 Stack 对应的 WeakOrderQueue</span><br>    <span class="hljs-keyword">if</span> (queue == <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-comment">// 最多帮助 2*CPU 核数的线程回收线程</span><br>        <span class="hljs-keyword">if</span> (delayedRecycled.size() &gt;= maxDelayedQueues) &#123;<br>            <span class="hljs-comment">// Add a dummy queue so we know we should drop the object</span><br>            delayedRecycled.put(<span class="hljs-built_in">this</span>, WeakOrderQueue.DUMMY);<span class="hljs-comment">// WeakOrderQueue.DUMMY 表示当前线程无法再帮助该 Stack 回收对象</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">// 新建 WeakOrderQueue</span><br>        <span class="hljs-keyword">if</span> ((queue = newWeakOrderQueue(thread)) == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// drop object</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        delayedRecycled.put(<span class="hljs-built_in">this</span>, queue);<br>    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (queue == WeakOrderQueue.DUMMY) &#123;<br>        <span class="hljs-comment">// drop object</span><br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    queue.add(item);<span class="hljs-comment">// 添加对象到 WeakOrderQueue 的 Link 链表中</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来我们继续分析对象是如何被添加到 WeakOrderQueue 的，直接跟进 queue.add(item) 的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">void</span> <span class="hljs-title function_">add</span><span class="hljs-params">(DefaultHandle&lt;?&gt; handle)</span> &#123;<br>    handle.lastRecycledId = id;<br>    <span class="hljs-type">Link</span> <span class="hljs-variable">tail</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.tail;<br>    <span class="hljs-type">int</span> writeIndex;<br>    <span class="hljs-comment">// 如果链表尾部的 Link 已经写满，那么再新建一个 Link 追加到链表尾部</span><br>    <span class="hljs-keyword">if</span> ((writeIndex = tail.get()) == LINK_CAPACITY) &#123;<br>        <span class="hljs-comment">// 检查是否超过对应 Stack 可以存放的其他线程帮助回收的最大对象数</span><br>        <span class="hljs-keyword">if</span> (!head.reserveSpace(LINK_CAPACITY)) &#123;<br>            <span class="hljs-comment">// Drop it.</span><br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">this</span>.tail = tail = tail.next = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Link</span>();<br>        writeIndex = tail.get();<br>    &#125;<br>    tail.elements[writeIndex] = handle; <span class="hljs-comment">// 添加对象到 Link 尾部</span><br>    handle.stack = <span class="hljs-literal">null</span>; <span class="hljs-comment">// handle 的 stack 属性赋值为 null</span><br>    tail.lazySet(writeIndex + <span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在向 WeakOrderQueue 写入对象之前，会先判断 Link 链表的 tail 节点是否还有空间存放对象。如果还有空间，直接向 tail Link 尾部写入数据，否则直接丢弃对象。如果 tail Link 已经没有空间，会新建一个 Link 之后再存放对象，新建 Link 之前会检查异线程帮助回收的对象总数超过了 Stack 设置的阈值，如果超过了阈值，那么对象也会被丢弃掉。</p><p>对象被添加到 Link 之后，handle 的 stack 属性被赋值为 null，而在取出对象的时候，handle 的 stack 属性又再次被赋值回来，为什么这么做呢，岂不是很麻烦？如果 Stack 不再使用，期望被 GC 回收，发现 handle 中还持有 Stack 的引用，那么就无法被 GC 回收，从而造成内存泄漏。</p><p>到此为止，Recycler 如何回收对象的实现原理就全部分析完了，在多线程的场景下，Netty 考虑的还是非常细致的，Recycler 回收对象时向 WeakOrderQueue 中存放对象，从 Recycler 获取对象时，WeakOrderQueue 中的对象会作为 Stack 的储备，而且有效地解决了跨线程回收的问题，是一个挺新颖别致的设计。</p><h3 id="2-2-1-总结"><a href="#2-2-1-总结" class="headerlink" title="2.2.1 总结"></a>2.2.1 总结</h3><p>最后，简单总结下对象池几个重要的知识点：</p><ul><li>对象池有两个重要的组成部分：Stack 和 WeakOrderQueue。</li><li>从 Recycler 获取对象时，优先从 Stack 中查找，如果 Stack 没有可用对象，会尝试从 WeakOrderQueue 迁移部分对象到 Stack 中。</li><li>Recycler 回收对象时，分为同线程对象回收和异线程对象回收两种情况，同线程回收直接向 Stack 中添加对象，异线程回收向 WeakOrderQueue 中的 Link 添加对象。</li><li>对象回收都会控制回收速率，每 8 个对象会回收一个，其他的全部丢弃。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.7-Netty发送数据流程</title>
    <link href="/2024/06/03/Netty/3.7-Netty%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B/"/>
    <url>/2024/06/03/Netty/3.7-Netty%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-整体结构"><a href="#1-整体结构" class="headerlink" title="1 整体结构"></a>1 整体结构</h1><p><img src="/../../images/Netty/Netty%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B-8.webp"></p><h1 id="2-ChannelHandlerContext"><a href="#2-ChannelHandlerContext" class="headerlink" title="2 ChannelHandlerContext"></a>2 ChannelHandlerContext</h1><p><img src="/../../images/Netty/Netty%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%B5%81%E7%A8%8B.webp"></p><ol><li>在Pipeline的ChannelHandle外，还封装一层ChannelHandleContext，其作用是抽离出相同的逻辑，进行封装。如写出时间流程，其write方法就是定义在ChannelHandleContext中。ChannelHandler 并不需要感知到它所处的 pipeline 中的上下文信息，只需要专心处理好 IO 逻辑即可，<strong>关于 pipeline 的上下文信息全部封装在 ChannelHandlerContext中</strong>。这样设计就使得 ChannelHandlerContext 和 ChannelHandler 的职责单一，各司其职，具有高度的可扩展性。</li><li>在pipeline中，前后有两个特殊的context，进站与出站数据，会分别从两个特殊的context中开始处理。</li></ol><h1 id="3-write事件触发"><a href="#3-write事件触发" class="headerlink" title="3  write事件触发"></a>3  write事件触发</h1><p>在发送数据时，一般通过两种方式触发发送数据，分别如下：</p><ul><li><code>channelHandlerContext.write()</code>：方法会从当前 ChannelHandler 开始在 pipeline 中向前传播 write 事件直到 HeadContext。</li><li><code>channelHandlerContext.channel().write()</code>：方法则会从 pipeline 的尾结点 TailContext 开始在 pipeline 中向前传播 write 事件直到 HeadContext 。</li></ul><h1 id="4-write发送数据流程及异常处理"><a href="#4-write发送数据流程及异常处理" class="headerlink" title="4 write发送数据流程及异常处理"></a>4 write发送数据流程及异常处理</h1><h2 id="4-1-整体流程"><a href="#4-1-整体流程" class="headerlink" title="4.1 整体流程"></a>4.1 整体流程</h2><p><img src="/../../images/Netty/c97eb4ea0c2ee5ff5e2ab02c4133114b_1240.webp"></p><h2 id="4-2-write"><a href="#4-2-write" class="headerlink" title="4.2 write()"></a>4.2 write()</h2><p>在Netty中，write方法是异步操作的，当我们在业务线程中调用 channelHandlerContext.write() 后，Netty 会给我们返回一个 ChannelFuture，我们可以在这个 ChannelFutrue 中添加 ChannelFutureListener ，这样当 Netty 将我们要发送的数据发送到底层 Socket 中时，Netty 会通过 ChannelFutureListener 通知我们写入结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// write方法是一个异步的方法</span><br><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractChannelHandlerContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelHandlerContext</span>, ResourceLeakHint &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">write</span><span class="hljs-params">(Object msg)</span> &#123;<br>        <span class="hljs-keyword">return</span> write(msg, newPromise());<br>    &#125;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">write</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Object msg, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>        write(msg, <span class="hljs-literal">false</span>, promise);<br>        <span class="hljs-keyword">return</span> promise;<br>    &#125;<br>&#125;<br><span class="hljs-comment">//可以通过添加listen的方式创建通知回调</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ChannelHandlerContext ctx, <span class="hljs-keyword">final</span> Object msg)</span> &#123;<br>        <span class="hljs-comment">//此处的msg就是Netty在read loop中从NioSocketChannel中读取到的ByteBuffer</span><br>        <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">future</span> <span class="hljs-operator">=</span> ctx.write(msg);<br>        future.addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> future.cause();<br>                <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) &#123;<br>                     <span class="hljs-comment">//处理异常情况</span><br>                &#125; <span class="hljs-keyword">else</span> &#123;                    <br>                     <span class="hljs-comment">//写入Socket成功后，Netty会通知到这里</span><br>                &#125;<br>            &#125;<br>        &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>write数据异常处理：<br>当异步事件在 pipeline 传播的过程中发生异常时，异步事件就会停止在 pipeline 中传播。所以我们在日常开发中，需要对写操作异常情况进行处理。</p><ul><li>其中 inbound 类异步事件发生异常时，<strong>会触发exceptionCaught事件传播</strong>。  exceptionCaught 事件本身也是一种 inbound 事件，传播方向会从当前发生异常的 ChannelHandler 开始一直向后传播直到 TailContext。</li><li>而 outbound 类异步事件发生异常时，<strong>则不会触发exceptionCaught事件传播</strong>。一般只是通知相关 ChannelFuture。但如果是 flush 事件在传播过程中发生异常，则会触发当前发生异常的 ChannelHandler 中 exceptionCaught 事件回调。</li></ul></blockquote><p><code>write()</code>整体流程如下代码所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(Object msg, <span class="hljs-type">boolean</span> flush, ChannelPromise promise)</span> &#123;<br>ObjectUtil.checkNotNull(msg, <span class="hljs-string">&quot;msg&quot;</span>);<br><br><span class="hljs-comment">//................省略检查promise的有效性...............</span><br><br><span class="hljs-comment">//flush = true 表示channelHandler中调用的是writeAndFlush方法，这里需要找到pipeline中覆盖write或者flush方法的channelHandler</span><br><span class="hljs-comment">//flush = false 表示调用的是write方法，只需要找到pipeline中覆盖write方法的channelHandler</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">next</span> <span class="hljs-operator">=</span> findContextOutbound(flush ?<br>(MASK_WRITE | MASK_FLUSH) : MASK_WRITE);<br><span class="hljs-comment">//用于检查内存泄露</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">Object</span> <span class="hljs-variable">m</span> <span class="hljs-operator">=</span> pipeline.touch(msg, next);<br><span class="hljs-comment">//获取pipeline中下一个要被执行的channelHandler的executor</span><br><span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> next.executor();<br><span class="hljs-comment">//确保OutBound事件由ChannelHandler指定的executor执行</span><br><span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br><span class="hljs-comment">//如果当前线程正是channelHandler指定的executor则直接执行</span><br><span class="hljs-keyword">if</span> (flush) &#123;<br>next.invokeWriteAndFlush(m, promise);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>next.invokeWrite(m, promise);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//如果当前线程不是ChannelHandler指定的executor,则封装成异步任务提交给指定executor执行，注意这里的executor不一定是reactor线程。</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">WriteTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> WriteTask.newInstance(next, m, promise, flush);<br><span class="hljs-keyword">if</span> (!safeExecute(executor, task, promise, m, !flush)) &#123;<br>task.cancel();<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-3-findContextOutbound"><a href="#4-3-findContextOutbound" class="headerlink" title="4.3 findContextOutbound()"></a>4.3 findContextOutbound()</h2><p>write 事件要向前在 pipeline 中传播，就需要在 pipeline 上找到下一个具有执行write资格的 ChannelHandler，因为位于当前 ChannelHandler 前边的可能是 ChannelInboundHandler 类型的也可能是 ChannelOutboundHandler 类型的 ChannelHandler ，或者有可能压根就不关心 write 事件的 ChannelHandler（没有实现write回调方法）。</p><p>因此就需要使用<code>findContextOutbound()</code>来查找下一个具有执行write功能的handle。其主体逻辑如下所示，findContextOutbound 方法接收的参数是一个掩码，这个掩码表示要向前查找具有什么样执行资格的 ChannelHandler。因为我们这里调用的是 ChannelHandlerContext 的 write 方法所以 flush &#x3D; false，传递进来的掩码为 MASK_WRITE，表示我们要向前查找覆盖实现了 write 回调方法的 ChannelOutboundHandler。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> AbstractChannelHandlerContext <span class="hljs-title function_">findContextOutbound</span><span class="hljs-params">(<span class="hljs-type">int</span> mask)</span> &#123;<br><span class="hljs-type">AbstractChannelHandlerContext</span> <span class="hljs-variable">ctx</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>;<br><span class="hljs-comment">//获取当前ChannelHandler的executor</span><br><span class="hljs-type">EventExecutor</span> <span class="hljs-variable">currentExecutor</span> <span class="hljs-operator">=</span> executor();<br><span class="hljs-keyword">do</span> &#123;<br><span class="hljs-comment">//获取前一个ChannelHandler</span><br>ctx = ctx.prev;<br>&#125; <span class="hljs-keyword">while</span> (skipContext(ctx, currentExecutor, mask, MASK_ONLY_OUTBOUND));<br><span class="hljs-keyword">return</span> ctx;<br>&#125;<br><span class="hljs-comment">//判断前一个ChannelHandler是否具有响应Write事件的资格</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">skipContext</span><span class="hljs-params">(</span><br><span class="hljs-params">AbstractChannelHandlerContext ctx, EventExecutor currentExecutor, <span class="hljs-type">int</span> mask, <span class="hljs-type">int</span> onlyMask)</span> &#123;<br><br><span class="hljs-keyword">return</span> (ctx.executionMask &amp; (onlyMask | mask)) == <span class="hljs-number">0</span> ||<br>(ctx.executor() == currentExecutor &amp;&amp; (ctx.executionMask &amp; mask) == <span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上文代码中，findContextOutbound()的参数是一个mask掩码，根据掩码来查找对应的handle。在Netty 中将 ChannelHandler 覆盖实现的一些异步事件回调方法用 int 型的掩码来表示，这样我们就可以通过这个掩码来判断当前 ChannelHandler 具有什么样的执行资格。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ChannelHandlerMask</span> &#123;<br>    ....................省略......................<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MASK_CHANNEL_ACTIVE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">3</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MASK_CHANNEL_READ</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">5</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MASK_CHANNEL_READ_COMPLETE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">6</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MASK_WRITE</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">15</span>;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MASK_FLUSH</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> &lt;&lt; <span class="hljs-number">16</span>;<br><br>   <span class="hljs-comment">//outbound事件掩码集合</span><br>   <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">MASK_ONLY_OUTBOUND</span> <span class="hljs-operator">=</span>  MASK_BIND | MASK_CONNECT | MASK_DISCONNECT |<br>            MASK_CLOSE | MASK_DEREGISTER | MASK_READ | MASK_WRITE | MASK_FLUSH;<br>    ....................省略......................<br>&#125;<br></code></pre></td></tr></table></figure><p>在 ChannelHandler 被添加进 pipeline 的时候，Netty 会根据当前 ChannelHandler 的类型以及其覆盖实现的异步事件回调方法，通过 <code>| 运算</code> 向 <code>ChannelHandlerContext#executionMask</code> 字段添加该 ChannelHandler 的执行资格。即当前 ChannelHandler 的执行资格存放在它的 ChannelHandlerContext 中的executionMask 字段中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractChannelHandlerContext</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelHandlerContext</span>, ResourceLeakHint &#123;<br>    <span class="hljs-comment">//ChannelHandler执行资格掩码</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> executionMask;<br>    ....................省略......................<br>&#125;<br></code></pre></td></tr></table></figure><p>结合上文，因此可知通过掩码与AbstractChannelHandlerContext中的循环，不断向前寻找下一个具有执行资格的handle。在write流程中，此执行资格是指<strong>前驱 ChannelHandler 是否是ChannelOutboundHandler 类型的，并且它是否覆盖实现了 write 事件回调方法</strong>。</p><h2 id="4-4-向前传播write事件"><a href="#4-4-向前传播write事件" class="headerlink" title="4.4 向前传播write事件"></a>4.4 向前传播write事件</h2><p>通过 findContextOutbound 方法我们在 pipeline 中找到了下一个具有执行资格的 ChannelHandler，这里指的是下一个 ChannelOutboundHandler 类型并且覆盖实现了 write 方法的 ChannelHandler。</p><p>Netty 紧接着会调用这个 nextChannelHandler 的 write 方法实现 write 事件在 pipeline 中的传播。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//获取下一个要被执行的channelHandler指定的executor</span><br><span class="hljs-type">EventExecutor</span> <span class="hljs-variable">executor</span> <span class="hljs-operator">=</span> next.executor();<br><span class="hljs-comment">//确保outbound事件的执行 是由 channelHandler指定的executor执行的</span><br><span class="hljs-keyword">if</span> (executor.inEventLoop()) &#123;<br><span class="hljs-comment">//如果当前线程是指定的executor 则直接操作</span><br><span class="hljs-keyword">if</span> (flush) &#123;<br>next.invokeWriteAndFlush(m, promise);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>next.invokeWrite(m, promise);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//如果当前线程不是channelHandler指定的executor，则封装程异步任务 提交给指定的executor执行</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">WriteTask</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> WriteTask.newInstance(next, m, promise, flush);<br><span class="hljs-keyword">if</span> (!safeExecute(executor, task, promise, m, !flush)) &#123;<br>task.cancel();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在我们向 pipeline 添加 ChannelHandler 的时候可以通过<code>ChannelPipeline#addLast(EventExecutorGroup,ChannelHandler......)</code> 方法指定执行该 ChannelHandler 的executor。如果不特殊指定，那么执行该 ChannelHandler 的executor默认为该 Channel 绑定的 Reactor 线程。</p><h2 id="4-5-HeadContext"><a href="#4-5-HeadContext" class="headerlink" title="4.5 HeadContext"></a>4.5 HeadContext</h2><p>HeadContext是一个特殊的Context，位于pipeline的前端，是出栈数据的最后处理位置，是 write 事件在 pipeline 中的传播终点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HeadContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractChannelHandlerContext</span><br>            <span class="hljs-keyword">implements</span> <span class="hljs-title class_">ChannelOutboundHandler</span>, ChannelInboundHandler &#123;<br>          <br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> &#123;<br>            unsafe.write(msg, promise);<br>        &#125;<br> &#125;<br></code></pre></td></tr></table></figure><p>在HeadContext中，最终会将信息封装，然后将其加入到ChannelOutboundBuffer缓存中，其主要流程如下图。每个channel对应一个<a href="3.8-ChannelOutboundBuffer.md">ChannelOutboundBuffer缓存</a>，主要用于缓存待发送的数据，当调用write方法时，会将数据放到缓存中，在调用flush方法时，才会将数据刷到socket中。<br><img src="/../../images/Netty/2ae6cb89c60ab87beeb51d9f1e5dff00_SgAADCAAAU5r9QrXnmmNU39xHYAAfVva2AFG63KKJmSkERAAAAAA=.webp"></p><h1 id="5-flush"><a href="#5-flush" class="headerlink" title="5 flush"></a>5 flush</h1><p>从前面 Netty 对 write 事件的处理过程中，我们可以看到当用户调用 ctx.write(msg) 方法之后，Netty 只是将用户要发送的数据临时写到 channel 对应的待发送缓冲队列 ChannelOutboundBuffer 中，然而并不会将数据写入 Socket 中。</p><h2 id="5-1-flush事件的传播"><a href="#5-1-flush事件的传播" class="headerlink" title="5.1  flush事件的传播"></a>5.1  flush事件的传播</h2><p>flush 事件和 write 事件一样都是 oubound 事件，所以它们的传播方向都是从后往前在 pipeline 中传播。<br>触发 flush 事件传播的同样也有两个方法：</p><ul><li><code>channelHandlerContext.flush()</code>：flush事件会从当前 channelHandler 开始在 pipeline 中向前传播直到 headContext。</li><li><code>channelHandlerContext.channel().flush()</code>：flush 事件会从 pipeline 的尾结点 tailContext 处开始向前传播直到 headContext。</li></ul><p>flush事件传播逻辑和 write 事件传播的逻辑基本一样，也是首先通过<code>findContextOutbound(MASK_FLUSH)</code> 方法从当前 ChannelHandler 开始从 pipeline 中向前查找出第一个 ChannelOutboundHandler 类型的并且实现 flush 事件回调方法的 ChannelHandler（ChannelHandler接口中也定义了flush方法，不过一般实现的比较少）。注意这里传入的执行资格掩码为 MASK_FLUSH。</p><p>与write事件的传播不一致的是，在调用不同handle传播flush过程中，如果出现异常，则会触发 nextChannelHandler 的 exceptionCaught 回调。而write事件的传播出现异常时，会直接通过事件所属的ChannelFuture来通知程序write事件异常，并不会触发 exceptionCaught 事件的传播。</p><h2 id="5-2-flush事件的处理"><a href="#5-2-flush事件的处理" class="headerlink" title="5.2 flush事件的处理"></a>5.2 flush事件的处理</h2><p>最终flush事件会在pipeline中一直向前传播至HeadContext中，并在 HeadContext 里调用 channel 的 unsafe 类完成 flush 事件的最终处理逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">AbstractUnsafe</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Unsafe</span> &#123;<br>       <span class="hljs-meta">@Override</span><br>        <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">flush</span><span class="hljs-params">()</span> &#123;<br>            assertEventLoop();<br>            <span class="hljs-type">ChannelOutboundBuffer</span> <span class="hljs-variable">outboundBuffer</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.outboundBuffer;<br>            <span class="hljs-comment">//channel以关闭</span><br>            <span class="hljs-keyword">if</span> (outboundBuffer == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//将flushedEntry指针指向ChannelOutboundBuffer头结点，此时变为即将要flush进Socket的数据队列</span><br>            outboundBuffer.addFlush();<br>            <span class="hljs-comment">//将待写数据写进Socket</span><br>            flush0();<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>参考文章：<br><a href="assets/%E4%B8%80%E6%96%87%E6%90%9E%E6%87%82%20Netty%20%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E5%85%A8%E6%B5%81%E7%A8%8B.html">一文搞懂 Netty 发送数据全流程</a></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>3.8-ChannelOutboundBuffer</title>
    <link href="/2024/06/03/Netty/3.8-ChannelOutboundBuffer/"/>
    <url>/2024/06/03/Netty/3.8-ChannelOutboundBuffer/</url>
    
    <content type="html"><![CDATA[<h1 id="1-实现结构"><a href="#1-实现结构" class="headerlink" title="1 实现结构"></a>1 实现结构</h1><p>ChannelOutboundBuffer的作用就是缓存待发送的数据，其内部是一个单链表结构的缓冲队列，链表中的节点类型为 Entry，Entry 中封装的就是待写入 Socket 中的网络发送数据相关的信息，以及 <code>ChannelHandlerContext#write</code> 方法中返回给用户的 ChannelPromise 。这样可以在数据写入Socket之后异步通知应用程序。</p><p>ChannelOutboundBuffer 中还封装了三个重要的指针：</p><ul><li><code>unflushedEntry</code> ：该指针指向 ChannelOutboundBuffer 中第一个待发送数据的 Entry。</li><li><code>tailEntry</code>：该指针指向 ChannelOutboundBuffer 中最后一个待发送数据的 Entry。通过 unflushedEntry 和 tailEntry 这两个指针，我们可以很方便的定位到待发送数据的 Entry 范围。</li><li><code>flushedEntry</code>：当我们通过 flush 操作需要将 ChannelOutboundBuffer 中缓存的待发送数据发送到 Socket 中时，flushedEntry 指针会指向 unflushedEntry 的位置，这样 flushedEntry 指针和 tailEntry 指针之间的 Entry 就是我们即将发送到 Socket 中的网络数据。<br><img src="/../../images/Netty/ChannelOutboundBuffer.webp"></li></ul><h1 id="2-Entry"><a href="#2-Entry" class="headerlink" title="2 Entry"></a>2 Entry</h1><p>Entry 作为 ChannelOutboundBuffer 链表结构中的节点元素类型，里边封装了待发送数据的各种信息，ChannelOutboundBuffer 其实就是对 Entry 结构的组织和操作。因此理解 Entry 结构是理解整个 ChannelOutboundBuffer 运作流程的基础。下面代码显示entry对象封装是信息</p><figure class="highlight java"><figcaption><span>title</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">Entry</span> &#123;<br><span class="hljs-comment">//Entry的对象池，用来创建和回收Entry对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ObjectPool&lt;Entry&gt; RECYCLER = ObjectPool.newPool(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ObjectCreator</span>&lt;Entry&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Entry <span class="hljs-title function_">newObject</span><span class="hljs-params">(Handle&lt;Entry&gt; handle)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Entry</span>(handle);<br>&#125;<br>&#125;);<br><br><span class="hljs-comment">//DefaultHandle用于回收对象</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Handle&lt;Entry&gt; handle;<br><span class="hljs-comment">//ChannelOutboundBuffer下一个节点</span><br>Entry next;<br><span class="hljs-comment">//待发送数据</span><br>Object msg;<br><span class="hljs-comment">//msg 转换为 jdk nio 中的byteBuffer</span><br>ByteBuffer[] bufs;<br>ByteBuffer buf;<br><span class="hljs-comment">//异步write操作的future</span><br>ChannelPromise promise;<br><span class="hljs-comment">//已发送了多少</span><br><span class="hljs-type">long</span> progress;<br><span class="hljs-comment">//总共需要发送多少，不包含entry对象大小。</span><br><span class="hljs-type">long</span> total;<br><span class="hljs-comment">//pendingSize表示entry对象在堆中需要的内存总量 待发送数据大小 + entry对象本身在堆中占用内存大小（96）</span><br><span class="hljs-type">int</span> pendingSize;<br><span class="hljs-comment">//msg中包含了几个jdk nio bytebuffer</span><br><span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> -<span class="hljs-number">1</span>;<br><span class="hljs-comment">//write操作是否被取消</span><br><span class="hljs-type">boolean</span> cancelled;<br>&#125;<br></code></pre></td></tr></table></figure><p>Entry结构中一共有12个字段，其中1个静态字段和11个实例字段，其含义如下：</p><ul><li><code>ObjectPool&lt;Entry&gt; RECYCLER</code>：Entry 的对象池，负责创建管理 Entry 实例，具体可参照<a href="3.6-Netty%E5%AF%B9%E8%B1%A1%E6%B1%A0.md">3.6-Netty对象池</a>。</li><li><code>Handle&lt;Entry&gt; handle</code>：默认实现类型为 DefaultHandle ，用于数据发送完毕后，对象池回收 Entry 对象。由对象池 RECYCLER 在创建 Entry 对象的时候传递进来。</li><li><code>Entry next</code>：ChannelOutboundBuffer 是一个单链表的结构，这里的 next 指针用于指向当前 Entry 节点的后继节点。</li><li><code>Object msg</code>：应用程序待发送的网络数据，这里 msg 的类型为 DirectByteBuffer 或者 FileRegion（用于通过零拷贝的方式网络传输文件）。</li><li><code>ByteBuffer[] bufs</code>：这里的 ByteBuffer 类型为 JDK NIO 原生的 ByteBuffer 类型，因为 Netty 最终发送数据是通过 JDK NIO 底层的 SocketChannel 进行发送，所以需要将 Netty 中实现的 ByteBuffer 类型转换为 JDK NIO ByteBuffer 类型。应用程序发送的 ByteBuffer 可能是一个也可能是多个，如果发送多个就用 ByteBuffer[] bufs 封装在 Entry 对象中，如果是一个就用 ByteBuffer buf 封装。</li><li><code>int count</code>：表示待发送数据 msg 中一共包含了多少个 ByteBuffer 需要发送。</li><li><code>ChannelPromise promise</code>：<code>ChannelHandlerContext#write</code> 异步写操作返回的 ChannelFuture。当 Netty 将待发送数据写入到 Socket 中时会通过这个 ChannelPromise 通知应用程序发送结果。</li><li><code>long progress</code>：表示当前的一个发送进度，已经发送了多少数据。</li><li><code>long total</code>：Entry中总共需要发送多少数据。注意：这个字段并不包含 Entry 对象的内存占用大小。只是表示待发送网络数据的大小。</li><li><code>boolean cancelled</code>：应用程序调用的 write 操作是否被取消。</li><li><code>int pendingSize</code>：表示待发送数据的内存占用总量。待发送数据在内存中的占用量分为两部分：<ul><li>Entry对象中所封装的待发送网络数据大小。</li><li>Entry对象本身在内存中的占用量。<br><img src="/../../images/Netty/ChannelOutboundBuffer-1.webp"></li></ul></li></ul><h1 id="3-pendingSize"><a href="#3-pendingSize" class="headerlink" title="3 pendingSize"></a>3 pendingSize</h1><p>ChannelOutboundBuffer的作用就是解耦数据生成与数据发送，因为数据的生产与TCP数据发送的数据不一致，因此需要在中间有一个缓存。当部分情况下，数据的生产速度大于数据的发送速度时，就会撑爆 ChannelOutboundBuffer 导致OOM（主要是堆外OOM，因为缓存是在堆外）。因此Netty 就必须限制 ChannelOutboundBuffer 中的待发送数据的内存占用总量，不能让它无限增长。所以Netty使用pendingSize字段表示缓存的已经使用大小。</p><p>因为 Netty 会将待发送数据封装在 Entry 实例对象中，在大量频繁的写操作中会产生大量的 Entry 实例对象，所以 Entry 实例对象的内存占用是不可忽视的。所以 pendingSize 的计算既要包含待发送数据的大小也要包含其 Entry 实例对象的内存占用大小，这样才能准确计算出 ChannelOutboundBuffer 中待发送数据的内存占用总量。</p><h1 id="4-高低水位线"><a href="#4-高低水位线" class="headerlink" title="4 高低水位线"></a>4 高低水位线</h1><p>Netty 中定义了高低水位线用来表示 ChannelOutboundBuffer 中的待发送数据的内存占用量的上限和下限。注意：这里的内存既包括 JVM 堆内存占用也包括堆外内存占用。</p><ul><li>当待发送数据的内存占用总量超过高水位线的时候，Netty 就会将 NioSocketChannel 的状态标记为不可写状态。否则就可能导致 OOM。</li><li>当待发送数据的内存占用总量低于低水位线的时候，Netty 会再次将 NioSocketChannel 的状态标记为可写状态。</li></ul><p>在默认情况下，ChannelOutboundBuffer 中的高水位线设置的大小为 64 KB，低水位线设置的是 32 KB。这也就意味着每个 Channel 中的待发送数据如果超过 64 KB。Channel 的状态就会变为不可写状态。当内存占用量低于 32 KB时，Channel 的状态会再次变为可写状态。</p><p>在高低水位线使用时，必须在写入数据时，判断下channel是否可写，即使用<code>channel.writable()</code>。如果当channel不可写时，就禁止写入数据。</p><p>当 Channel 的状态是首次从可写状态变为不可写状态时，就会在 channel 对应的 pipeline 中传播 ChannelWritabilityChanged 事件，注意该事件是一个 inbound 事件。也即是说，在headnContext处出现缓存超过高水位时，会向后传播ChannelWritabilityChanged 事件。<br><img src="/../../images/Netty/4cdc7612895c4023496d07c025462279_e85a1d884dc917d5e93223d2819e2524480aa9.png"></p><p>因此就可在自定义的header中，重写<code>channelWritabilityChanged()</code>方法，来响应ChannelWritabilityChanged 事件。</p><ul><li>当超过高水位时，主动停止消息的发送</li><li>当恢复正常后，主动触发消息的生产<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span> &#123; <br><span class="hljs-meta">@Override</span> <br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelWritabilityChanged</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception &#123; <br><span class="hljs-keyword">if</span> (ctx.channel().isWritable()) &#123; <br><span class="hljs-comment">//...........当前channel可写......... </span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//...........当前channel不可写......... </span><br>&#125; <br>&#125; <br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.1-EventExecutor(Group)</title>
    <link href="/2024/06/02/Netty/2.1-EventExecutor(Group)/"/>
    <url>/2024/06/02/Netty/2.1-EventExecutor(Group)/</url>
    
    <content type="html"><![CDATA[<h1 id="1-JDK-Executor"><a href="#1-JDK-Executor" class="headerlink" title="1 JDK Executor"></a>1 JDK Executor</h1><p>​<img src="/../../images/Netty/EventExecutor(Group).png">​</p><p>JDK 的 Executor 体系如上图所示，整体的设计思路为顶级接口-次级接口-抽象类-实现类。其中：</p><ul><li><strong>Executor</strong>：为顶级接口，内部只有一个 <code>execute()</code>，约定在单个线程或者线程池中执行命令功能。该接口主要是为了解耦组要执行 Runnable 任务与调用者之间的关联。</li><li><strong>ExecutorService</strong>：该接口继承自 Executor 接口，添加了 shutdown、shutdownAll、submit、invokeAll 等一系列对线程的操作方法。</li><li><strong>AbstractExecutorService</strong>: 这是一个抽象类，通过模板方法设计模式抽取并实现 ExecuotrService 接口的部分方法，以做到方法复用。</li><li><strong>ThreadPoolExecutor</strong>：这是 Java 线程池最核心的一个类，该类继承自 AbstractExecutorService，主要功能是创建线程池，给任务分配线程资源，执行任务。</li><li><strong>ScheduledExecutorService</strong>：此接口提供定义执行任务功能。</li><li><strong>ScheduledThreadPoolExecutor</strong> ：此类是 ScheduledExecutorService 的具体实现，可定时执行某些任务。</li></ul><h1 id="2-EventExecutor-Group"><a href="#2-EventExecutor-Group" class="headerlink" title="2 EventExecutor (Group)"></a>2 EventExecutor (Group)</h1><p>本章主要介绍 Netty 内部的 EventExecutor 与 EventExecutorGroup 的主要机制，Netty 提倡异步处理事件，其内部便是通过 EventExecutor 与 EventExecutorGroup 相互配合，实现对任务的异步处理。<br>在 Netty 中，EventExecutor（执行器）与 EventExecutorGroup（执行器组）与 jdk 中线程与线程池的概念类似，是对其进一步封装，EventExecutor 是用于执行任务，EventExecutorGroup 用于管理内部的 EventExecutor，当任务被提交到 EventExecutorGroup 时，其最终会被内部的 EventExecutor 异步执行。</p><h2 id="2-1-EventExecutorGroup"><a href="#2-1-EventExecutorGroup" class="headerlink" title="2.1 EventExecutorGroup"></a>2.1 EventExecutorGroup</h2><h3 id="2-1-1-EventExecutorGroup"><a href="#2-1-1-EventExecutorGroup" class="headerlink" title="2.1.1 EventExecutorGroup"></a>2.1.1 EventExecutorGroup</h3><p>​<img src="/../../images/Netty/EventExecutor(Group)-1.png">​</p><p>EventExecutorGroup 接口继承 ScheduledExecutorService 接口，并在其接口上，增加额外的方法，扩展其功能，用于管理内部的执行器（EventExecutor），如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EventExecutorGroup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ScheduledExecutorService</span>, Iterable&lt;EventExecutor&gt; &#123;<br><br>    <span class="hljs-comment">// 判断当前执行器组内部的执行器是否正在被关闭或者已经关闭。</span><br>    <span class="hljs-type">boolean</span> <span class="hljs-title function_">isShuttingDown</span><span class="hljs-params">()</span>;<br>    <span class="hljs-comment">// 用于安全的关闭当前执行器组</span><br>    Future&lt;?&gt; shutdownGracefully();<br>    Future&lt;?&gt; shutdownGracefully(<span class="hljs-type">long</span> quietPeriod, <span class="hljs-type">long</span> timeout, TimeUnit unit);<br>    <span class="hljs-comment">// 获取执行器是否关闭完成对象</span><br>    Future&lt;?&gt; terminationFuture();<br>    <span class="hljs-comment">// 返回下一个执行器</span><br>    EventExecutor <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>    <span class="hljs-meta">@Override</span><br>    Iterator&lt;EventExecutor&gt; <span class="hljs-title function_">iterator</span><span class="hljs-params">()</span>; <span class="hljs-comment">//获取EventExecutor迭代器</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li><code>next()</code>：在 EventExecutorGroup 中会管理多个 EventExecutor，通过此方法可返回 EventExecutorGroup 中管理的下一个执行器 EventExecutor。Netty 中提倡异步机制，在提交任务到 EventExecutorGroup 中的时候，都会获取此 EventExecutorGroup 中的下个 EventExecutor 进行处理。在 <code>next()</code> 函数中，会通过 <code>chooser.next()</code> 获取到下一个 EventExecutor，其中 chooser 对象是一个选择器，选择的逻辑是 <code>this.executors[(int)Math.abs(this.idx.getAndIncrement() % (long)this.executors.length)];</code> 从此看出，是简单的根据下标进行选择下一个 EventExecutor<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> &lt;T&gt; Future&lt;T&gt; <span class="hljs-title function_">submit</span><span class="hljs-params">(Callable&lt;T&gt; task)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.next().submit(task);   <span class="hljs-comment">//提交任务到下个EventExecutor中执行</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><code>iterator()</code>：<code>Iterator&lt;EventExecutor&gt; iterator()</code> 一个迭代器，用于迭代获取下个 EventExecutor。</li><li><code>shutdownGracefully()</code>：用于优雅的关闭内部的执行器，在关闭前，会先处理完当前任务。</li></ul><h3 id="2-1-2-DefaultEventExecutorGroup"><a href="#2-1-2-DefaultEventExecutorGroup" class="headerlink" title="2.1.2 DefaultEventExecutorGroup"></a>2.1.2 DefaultEventExecutorGroup</h3><p>DefaultEventExecutorGroup 是独立与 Netty 中的网络通信模块，类似于 JDK 中的线程池，用于提供异步执行任务的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">DefaultEventExecutorGroup</span> <span class="hljs-variable">eventExecutors</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultEventExecutorGroup</span>(<span class="hljs-number">1</span>);<br>eventExecutors.submit(() -&gt; &#123;System.out.println(<span class="hljs-string">&quot;Hello World!&quot;</span>);&#125;);<br></code></pre></td></tr></table></figure><p>DefaultEventExecutorGroup 是 EventExecutorGroup 的默认实现，在创建时，可执行内部执行器数量。其主要逻辑如下：</p><ul><li>提供不同的构造器，可指定构造器数，线程工厂等。</li><li>DefaultEventExecutorGroup 默认的执行器是 DefaultEventExecutor。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultEventExecutorGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads)</span> &#123;<br><span class="hljs-built_in">this</span>(nThreads, <span class="hljs-literal">null</span>);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultEventExecutorGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, ThreadFactory threadFactory)</span> &#123;<br><span class="hljs-built_in">this</span>(nThreads, threadFactory, SingleThreadEventExecutor.DEFAULT_MAX_PENDING_EXECUTOR_TASKS,<br>RejectedExecutionHandlers.reject());<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-title function_">DefaultEventExecutorGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, ThreadFactory threadFactory, <span class="hljs-type">int</span> maxPendingTasks,</span><br><span class="hljs-params"> RejectedExecutionHandler rejectedHandler)</span> &#123;<br><span class="hljs-built_in">super</span>(nThreads, threadFactory, maxPendingTasks, rejectedHandler);<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> EventExecutor <span class="hljs-title function_">newChild</span><span class="hljs-params">(Executor executor, Object... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DefaultEventExecutor</span>(<span class="hljs-built_in">this</span>, executor, (Integer) args[<span class="hljs-number">0</span>], (RejectedExecutionHandler) args[<span class="hljs-number">1</span>]);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-3-MultithreadEventExecutorGroup"><a href="#2-1-3-MultithreadEventExecutorGroup" class="headerlink" title="2.1.3 MultithreadEventExecutorGroup"></a>2.1.3 MultithreadEventExecutorGroup</h3><p>MultithreadEventExecutorGroup 是 DefaultEventExecutorGroup 的父类，DefaultEventExecutorGroup 中的大部分功能均在 MultithreadEventExecutorGroup 中实现。其主要作用是根据参数创建出多个执行器，用于执行任务，其主要逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">MultithreadEventExecutorGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor,</span><br><span class="hljs-params">                                        EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;<br>    <span class="hljs-keyword">if</span> (nThreads &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(String.format(<span class="hljs-string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));<br>    &#125;<br>    <span class="hljs-keyword">if</span> (executor == <span class="hljs-literal">null</span>) &#123;<br>        executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());<br>    &#125;<br>    children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventExecutor</span>[nThreads];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nThreads; i ++) &#123;    <span class="hljs-comment">//循环创建多个执行器</span><br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            children[i] = newChild(executor, args);  <span class="hljs-comment">//创建执行器，并填充到数组</span><br>            success = <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think about if this is a good exception type</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;failed to create a child event loop&quot;</span>, e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (!success) &#123;<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>                    children[j].shutdownGracefully();<br>                &#125;<br><br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>                    <span class="hljs-type">EventExecutor</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> children[j];<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">while</span> (!e.isTerminated()) &#123;<br>                            e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">catch</span> (InterruptedException interrupted) &#123;<br>                        <span class="hljs-comment">// Let the caller handle the interruption.</span><br>                        Thread.currentThread().interrupt();<br>                        <span class="hljs-keyword">break</span>;<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>    chooser = chooserFactory.newChooser(children); <span class="hljs-comment">//创建默认的选择器，用于选择下一个执行器</span><br><span class="hljs-comment">//·········省略部分代码·········</span><br>&#125;<br></code></pre></td></tr></table></figure><p>从上文代码中可以看出：</p><ol><li>MultithreadEventExecutorGroup 内部使用数组保存多个执行器。</li><li>根据 chooser 对象定义如何从数组中获取目标执行器（默认是根据下标获取执行器）</li><li>通过 <code>newChild()</code> 创建出默认的执行器，默认的实现是位于 <code>DefaultEventExecutorGroup#newChild()</code> 中（见2.1.2节）。</li><li>默认的 executor 是 ThreadPerTaskExecutor，此 executor 的作用是创建出执行器对应的内部线程，具体见后文。</li></ol><h3 id="2-1-4-ThreadPerTaskExecutor"><a href="#2-1-4-ThreadPerTaskExecutor" class="headerlink" title="2.1.4 ThreadPerTaskExecutor"></a>2.1.4 ThreadPerTaskExecutor</h3><p>ThreadPerTaskExecutor 的代码如下文所示，其主要逻辑即是创建一个新的线程执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">Public <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Executor</span> &#123;<br>    Private <span class="hljs-keyword">final</span> ThreadFactory threadFactory;<br><br>    Public <span class="hljs-title function_">ThreadPerTaskExecutor</span> <span class="hljs-params">(ThreadFactory threadFactory)</span> &#123;<br>        This. ThreadFactory = ObjectUtil.CheckNotNull (threadFactory, <span class="hljs-string">&quot;threadFactory&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    Public <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span> <span class="hljs-params">(Runnable command)</span> &#123;<br>        ThreadFactory. NewThread (command). Start ();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-1-5-FastThreadLocalThread"><a href="#2-1-5-FastThreadLocalThread" class="headerlink" title="2.1.5 FastThreadLocalThread"></a>2.1.5 FastThreadLocalThread</h3><h4 id="2-1-5-1-线程创建"><a href="#2-1-5-1-线程创建" class="headerlink" title="2.1.5.1 线程创建"></a>2.1.5.1 线程创建</h4><p>在2.1.3章节，如果executor为null，则会通过<code>new ThreadPerTaskExecutor(newDefaultThreadFactory());</code>逻辑构建executor，其中通过<code>newDefaultThreadFactory()</code>构建默认的线程工厂。在默认的线程工厂中，创建线程逻辑如下，从代码中可知，线程类型为<code>FastThreadLocalThread</code>类型线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r)</span> &#123;<br><span class="hljs-type">Thread</span> <span class="hljs-variable">t</span> <span class="hljs-operator">=</span> newThread(FastThreadLocalRunnable.wrap(r), prefix + nextId.incrementAndGet());<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">if</span> (t.isDaemon() != daemon) &#123;<br>t.setDaemon(daemon);<br>&#125;<br><br><span class="hljs-keyword">if</span> (t.getPriority() != priority) &#123;<br>t.setPriority(priority);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (Exception ignored) &#123;<br><span class="hljs-comment">// Doesn&#x27;t matter even if failed to set.</span><br>&#125;<br><span class="hljs-keyword">return</span> t;<br>&#125;<br><br><span class="hljs-keyword">protected</span> Thread <span class="hljs-title function_">newThread</span><span class="hljs-params">(Runnable r, String name)</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastThreadLocalThread</span>(threadGroup, r, name);<br>&#125;<br></code></pre></td></tr></table></figure><p><code>FastThreadLocalThread</code>线程是Thread线程的子类。与普通线程不同的是，<code>FastThreadLocalThread</code>线程内部含有一个<code>FastThreadLocal</code>属性，在某种程度上，FastThreadLocal会比ThreadLocal的性能更好。<br>在创建线程时，使用了<code>FastThreadLocalRunnable</code>对<code>runnable</code>对象进行包装，此包装的目的是在runnable对象执行完毕后，对相关的<code>fastThreadLocal</code>进行释放，防止内存泄漏。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FastThreadLocalRunnable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Runnable</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Runnable runnable;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-title function_">FastThreadLocalRunnable</span><span class="hljs-params">(Runnable runnable)</span> &#123;<br>        <span class="hljs-built_in">this</span>.runnable = ObjectUtil.checkNotNull(runnable, <span class="hljs-string">&quot;runnable&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            runnable.run();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            FastThreadLocal.removeAll();  <span class="hljs-comment">//释放内存</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> Runnable <span class="hljs-title function_">wrap</span><span class="hljs-params">(Runnable runnable)</span> &#123;<br>        <span class="hljs-keyword">return</span> runnable <span class="hljs-keyword">instanceof</span> FastThreadLocalRunnable ? runnable : <span class="hljs-keyword">new</span> <span class="hljs-title class_">FastThreadLocalRunnable</span>(runnable);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1-5-2-ThreadLocal"><a href="#2-1-5-2-ThreadLocal" class="headerlink" title="2.1.5.2 ThreadLocal"></a>2.1.5.2 ThreadLocal</h4><p>众所周知，在java的线程种，存在ThreadLocalMap实例变量，其本质是一个Map，用于保存值。此Map在使用时，是使用<strong>线性探测</strong>的方式解决hash冲突的问题，如果没有找到空闲的slot，就不断往后尝试，直到找到一个空闲的位置，插入entry，这种方式在经常遇到hash冲突时，影响效率。<br><img src="/../../images/Netty/EventExecutor(Group)-2.png"></p><h4 id="2-1-5-3-FastThreadLocal"><a href="#2-1-5-3-FastThreadLocal" class="headerlink" title="2.1.5.3 FastThreadLocal"></a>2.1.5.3 FastThreadLocal</h4><p>FastThreadLocal(下文简称ftl)直接使用数组避免了hash冲突的发生，具体做法是：每一个FastThreadLocal实例创建时，分配一个下标index；分配index使用AtomicInteger实现，每个FastThreadLocal都能获取到一个不重复的下标。<br>这要做虽然会产生大量的 index，但避免了在 ThreadLocal 中计算索引下标位置以及处理 hash 冲突带来的损耗（如在存储或删除threadlocal变量时，不用重新计算hash），所以在操作数组时使用固定下标要比使用计算哈希下标有一定的性能优势，特别是在频繁使用时会非常显著，用空间换时间，这就是高性能 Netty 的巧妙之处。<br><img src="/../../images/Netty/EventExecutor(Group)-3.png"></p><h3 id="2-1-6-执行器组提交任务逻辑"><a href="#2-1-6-执行器组提交任务逻辑" class="headerlink" title="2.1.6 执行器组提交任务逻辑"></a>2.1.6 执行器组提交任务逻辑</h3><p>EventExecutorGroup 接口的作用是提供异步执行任务的功能，以 DefaultEventExecutorGroup 为例，其主要逻辑为：</p><ol><li>创建 DefaultEventExecutorGroup 对象，内部会根据参数，实例化多个 EventExecutor 执行器。</li><li>调用<code>DefaultEventExecutorGroup #submit ()</code>函数提交任务，内部会 next ()筛选出 EventExecutor 执行器，并通过<code>AbstractEventExecutor #submit ()</code>将任务提交到 EventExecutor 中的任务队列。</li></ol><h2 id="2-2-EventExecutor"><a href="#2-2-EventExecutor" class="headerlink" title="2.2 EventExecutor"></a>2.2 EventExecutor</h2><h3 id="2-2-1-EventExecutor"><a href="#2-2-1-EventExecutor" class="headerlink" title="2.2.1 EventExecutor"></a>2.2.1 EventExecutor</h3><p><img src="/../../images/Netty/EventExecutor(Group)-4.png"></p><p>EventExecutor 的类图如上图所示：</p><ul><li>EventExecutor 接口表示一个执行器，可执行任务。</li><li>EventExecutorGroup 表示一个执行器组，内部含有一个或多个执行器。</li><li>EventExecutor 继承自 EventExecutorGroup， 表示是一个特殊的执行器组，其特殊之处在于其内部只有一个执行器，即是它本身。</li></ul><h3 id="2-2-2-DefaultEventExecutor"><a href="#2-2-2-DefaultEventExecutor" class="headerlink" title="2.2.2 DefaultEventExecutor"></a>2.2.2 DefaultEventExecutor</h3><p>DefaultEventExecutor 是 Netty 中执行器的默认实现。其内部 run ()定义了此执行器的主要逻辑，即不断的从队列中获取任务，然后执行任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br>Protected <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span> &#123;<br>    For (;;) &#123;<br>        <span class="hljs-type">Runnable</span> <span class="hljs-variable">task</span> <span class="hljs-operator">=</span> takeTask ();<br>        If (task != <span class="hljs-literal">null</span>) &#123;<br>            Task. Run ();<br>            UpdateLastExecutionTime ();<br>        &#125;<br><br>        If (confirmShutdown ()) &#123;<br>            Break;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>DefaultEventExecutor 的父类是 SingleThreadEventExecutor，表示 DefaultEventExecutor 内部只有一个线程，用于处理任务队列中的任务。</p><h3 id="2-2-3-SingleThreadEventExecutor"><a href="#2-2-3-SingleThreadEventExecutor" class="headerlink" title="2.2.3 SingleThreadEventExecutor"></a>2.2.3 SingleThreadEventExecutor</h3><p>DefaultEventExecutor 内部逻辑较为简单，大部分逻辑在 SingleThreadEventExecutor 中实现。主要有以下逻辑：</p><ul><li><code>inEventLoop ()</code>：表示判断当前执行线程是否为 SingleThreadEventExecutor 内部所绑定的线程（如果是的话，说明当前 EventExecutor 内部执行线程已经启动，如果不是的话，则需要尝试启动 EventExecutor 内部执行线程，用于消费任务），如果是则返回 true。</li><li><code>run ()</code>：定义用于执行消费队列中事件的方法。</li><li><code>doStartThread ()</code>：用于尝试启动 EventExecutor 内部执行线程，如下文所示，其中 executor 为上文中的 ThreadPerTaskExecutor。因此可知，在<code>doStartThread ()</code>中会通过 ThreadPerTaskExecutor 创建一个新的线程，将线程绑定到 EventExecutor 中，然后执行<code>SingleThreadEventExecutor.This.Run ()</code>逻辑，<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">Private <span class="hljs-keyword">void</span> <span class="hljs-title function_">doStartThread</span> <span class="hljs-params">()</span> &#123;<br>    Assert thread == <span class="hljs-literal">null</span>;<br>    Executor. Execute (<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span> () &#123;  <br>        <span class="hljs-meta">@Override</span><br>        Public <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span> <span class="hljs-params">()</span> &#123;<br>            Thread = Thread. CurrentThread ();  <span class="hljs-comment">//绑定线程到 EventExecutor</span><br>            If (interrupted) &#123;<br>                Thread. Interrupt ();<br>            &#125;<br><br>            <span class="hljs-type">Boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            UpdateLastExecutionTime ();<br>            Try &#123;<br>                SingleThreadEventExecutor. This. Run ();  <span class="hljs-comment">//执行 run ()，消费事件队列中事件</span><br>                Success = <span class="hljs-literal">true</span>;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                Logger. Warn (<span class="hljs-string">&quot;Unexpected exception from an event executor: &quot;</span>, t);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-comment">//·········省略部分代码········</span><br>            &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ul><h3 id="2-2-4-执行器执行任务逻辑"><a href="#2-2-4-执行器执行任务逻辑" class="headerlink" title="2.2.4 执行器执行任务逻辑"></a>2.2.4 执行器执行任务逻辑</h3><p>根据前文2.1.5可知，任务最终会通过<code>AbstractEventExecutor #submit ()</code>方法，将任务提交到 EventExecutor 内部。<code>AbstractEventExecutor #submit ()</code>最终会触发执行<code>SingleThreadEventExecutor #execute ()</code>逻辑，具体如下所示，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">Private <span class="hljs-keyword">void</span> <span class="hljs-title function_">execute</span> <span class="hljs-params">(Runnable task, <span class="hljs-type">boolean</span> immediate)</span> &#123;<br>    <span class="hljs-type">Boolean</span> <span class="hljs-variable">inEventLoop</span> <span class="hljs-operator">=</span> inEventLoop ();  <span class="hljs-comment">//判断执行器线程是否已经在运行</span><br>    AddTask (task); <span class="hljs-comment">//将任务提交到队列中</span><br>    If (! InEventLoop) &#123;<span class="hljs-comment">//如果执行器未在运行，则尝试启动线程。</span><br>        StartThread ();<span class="hljs-comment">//启动线程最终会调用 doStartThread ()，如上文所示，会不断的消耗任务队列中的任务。</span><br>        If (isShutdown ()) &#123;<br>            <span class="hljs-type">Boolean</span> <span class="hljs-variable">reject</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            Try &#123;<br>                If (removeTask (task)) &#123;<br>                    Reject = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (UnsupportedOperationException e) &#123;<br>            &#125;<br>            If (reject) &#123;<br>                Reject ();<br>            &#125;<br>        &#125;<br>    &#125;<br>    If (! AddTaskWakesUp &amp;&amp; immediate) &#123;<br>        Wakeup (inEventLoop);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.2-EventLoop(Group)</title>
    <link href="/2024/06/02/Netty/2.2-EventLoop(Group)/"/>
    <url>/2024/06/02/Netty/2.2-EventLoop(Group)/</url>
    
    <content type="html"><![CDATA[<h1 id="1-接口定义"><a href="#1-接口定义" class="headerlink" title="1 接口定义"></a>1 接口定义</h1><h2 id="1-1-EventLoopGroup"><a href="#1-1-EventLoopGroup" class="headerlink" title="1.1 EventLoopGroup"></a>1.1 EventLoopGroup</h2><p>接口定义如下文代码所示，从代码种可以看出，EventLoopGroup接口继承自EventExecutorGroup接口，并修改或新增额外功能。由此可知，EventLoopGroup的功能是管理多个EventLoop并接收channel，将其注册到内部的EventLoop中。</p><ul><li><code>next()</code>：返回EventLoopGroup管理中的下一个EventLoop事件处理器。</li><li><code>register()</code>：网络通信相关，用于注册channel。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EventLoopGroup</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">EventExecutorGroup</span> &#123;<br><span class="hljs-meta">@Override</span><br>EventLoop <span class="hljs-title function_">next</span><span class="hljs-params">()</span>;<br>ChannelFuture <span class="hljs-title function_">register</span><span class="hljs-params">(Channel channel)</span>;<br>ChannelFuture <span class="hljs-title function_">register</span><span class="hljs-params">(ChannelPromise promise)</span>;<br><span class="hljs-meta">@Deprecated</span><br>ChannelFuture <span class="hljs-title function_">register</span><span class="hljs-params">(Channel channel, ChannelPromise promise)</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="1-2-EventLoop"><a href="#1-2-EventLoop" class="headerlink" title="1.2 EventLoop"></a>1.2 EventLoop</h2><p>EventLoop继承自EventLoopGroup，是一个特殊的EventLoopGroup。与前文的EventExecutor类似，是一个只包含自身的组。在其内部通过parent()获取此EventLoop所属的EventLoopGroup。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">EventLoop</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">OrderedEventExecutor</span>, EventLoopGroup &#123;<br><span class="hljs-meta">@Override</span><br>EventLoopGroup <span class="hljs-title function_">parent</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="2-具体实现"><a href="#2-具体实现" class="headerlink" title="2 具体实现"></a>2 具体实现</h1><p>本文只介绍Netty网络通信过程中，常使用的相关实现，即NioEventLoopGroup与NioEventLoop。</p><h2 id="2-1-NioEventLoopGroup"><a href="#2-1-NioEventLoopGroup" class="headerlink" title="2.1 NioEventLoopGroup"></a>2.1 NioEventLoopGroup</h2><p>NioEventLoopGroup是用于处理NIO channel操作的事件循环组，创建的事件循环为NioEventLoop。该类是生产环境中常用的事件循环组，其继承图如下图所示，从图中可知，NioEventLoopGroup实现了EventLoopGroup接口，继承了MultithreadEventExecutorGroup类，所以其主要的逻辑在前文EventLoop中已经做了部分阐述。<br>​<img src="/../../images/Netty/7-EventLoop(Group)-20240629143557-2g3g9uh.png">​</p><p>NioEventLoopGroup用于管理内部的NioEventLoop，通过newChild()可以创建出对应的NioEventLoop。在构建NioEventLoop时，会将SelectorProvider、selectStrategy等参数传递给NioEventLoop，用于操作NIO selector。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> EventLoop <span class="hljs-title function_">newChild</span><span class="hljs-params">(Executor executor, Object... args)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-type">EventLoopTaskQueueFactory</span> <span class="hljs-variable">queueFactory</span> <span class="hljs-operator">=</span> args.length == <span class="hljs-number">4</span> ? (EventLoopTaskQueueFactory) args[<span class="hljs-number">3</span>] : <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoop</span>(<span class="hljs-built_in">this</span>, executor, (SelectorProvider) args[<span class="hljs-number">0</span>],<br>((SelectStrategyFactory) args[<span class="hljs-number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler) args[<span class="hljs-number">2</span>], queueFactory);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-MultithreadEventExecutorGroup"><a href="#2-2-MultithreadEventExecutorGroup" class="headerlink" title="2.2 MultithreadEventExecutorGroup"></a>2.2 MultithreadEventExecutorGroup</h2><p>在NioEventLoopGroup类中，逻辑较为简单，主要逻辑是在MultithreadEventExecutorGroup中实现。顾名思义，此类的功能是管理多个线程的组，其主要是构造器逻辑如下：</p><ol><li>根据被管理的线程数量，构建数组</li><li>如果executor为null，则创建出默认executor，此executor作用是创建出对应的线程，然后执行EventLoop逻辑</li><li>通过<code>newChild()</code>，构建对应的EventLoop，将其放入到数组中。</li><li>构造选择器chooser，用于从数组中，按照一定的规则选择EventLoop</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-title function_">MultithreadEventExecutorGroup</span><span class="hljs-params">(<span class="hljs-type">int</span> nThreads, Executor executor,</span><br><span class="hljs-params">EventExecutorChooserFactory chooserFactory, Object... args)</span> &#123;<br><span class="hljs-keyword">if</span> (nThreads &lt;= <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span>(String.format(<span class="hljs-string">&quot;nThreads: %d (expected: &gt; 0)&quot;</span>, nThreads));<br>&#125;<br><br><span class="hljs-keyword">if</span> (executor == <span class="hljs-literal">null</span>) &#123;<br>executor = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ThreadPerTaskExecutor</span>(newDefaultThreadFactory());<br>&#125;<br><br>children = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventExecutor</span>[nThreads];<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nThreads; i ++) &#123;<br><span class="hljs-type">boolean</span> <span class="hljs-variable">success</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">try</span> &#123;<br>children[i] = newChild(executor, args);<br>success = <span class="hljs-literal">true</span>;<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> Think about if this is a good exception type</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalStateException</span>(<span class="hljs-string">&quot;failed to create a child event loop&quot;</span>, e);<br>&#125; <span class="hljs-keyword">finally</span> &#123;<br><span class="hljs-keyword">if</span> (!success) &#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br>children[j].shutdownGracefully();<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j ++) &#123;<br><span class="hljs-type">EventExecutor</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> children[j];<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">while</span> (!e.isTerminated()) &#123;<br>e.awaitTermination(Integer.MAX_VALUE, TimeUnit.SECONDS);<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (InterruptedException interrupted) &#123;<br><span class="hljs-comment">// Let the caller handle the interruption.</span><br>Thread.currentThread().interrupt();<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br>chooser = chooserFactory.newChooser(children);<br><br><span class="hljs-keyword">final</span> FutureListener&lt;Object&gt; terminationListener = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FutureListener</span>&lt;Object&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(Future&lt;Object&gt; future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br><span class="hljs-keyword">if</span> (terminatedChildren.incrementAndGet() == children.length) &#123;<br>terminationFuture.setSuccess(<span class="hljs-literal">null</span>);<br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span> (EventExecutor e: children) &#123;<br>e.terminationFuture().addListener(terminationListener);<br>&#125;<br><br>Set&lt;EventExecutor&gt; childrenSet = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LinkedHashSet</span>&lt;EventExecutor&gt;(children.length);<br>Collections.addAll(childrenSet, children);<br>readonlyChildren = Collections.unmodifiableSet(childrenSet);<br>&#125;<br></code></pre></td></tr></table></figure><p>初次之外，也实现了regist逻辑，即注册channel。从此可看，是调用的EventLoop的注册方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">register</span><span class="hljs-params">(Channel channel)</span> &#123;<br><span class="hljs-keyword">return</span> next().register(channel);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.3-Netty事件处理流程总结</title>
    <link href="/2024/06/02/Netty/2.3-Netty%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/"/>
    <url>/2024/06/02/Netty/2.3-Netty%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="1-整体流程"><a href="#1-整体流程" class="headerlink" title="1 整体流程"></a>1 整体流程</h1><p>​<img src="/../../images/Netty/Netty%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86%E6%B5%81%E7%A8%8B%E6%80%BB%E7%BB%93.png">​</p><p>结合 Netty 的整体架构，我们一起看下 EventLoop 的事件流转图，以便更好地理解 Netty EventLoop 的设计原理。NioEventLoop 的事件处理机制采用的是<strong>无锁串行化的设计思路</strong>。</p><ul><li><strong>BossEventLoopGroup</strong> 和 <strong>WorkerEventLoopGroup</strong> 包含一个或者多个 NioEventLoop。BossEventLoopGroup 负责监听客户端的 Accept 事件，当事件触发时，将事件注册至 WorkerEventLoopGroup 中的一个 NioEventLoop 上。每新建一个 Channel， 只选择一个 NioEventLoop 与其绑定。所以说 Channel 生命周期的所有事件处理都是<strong>线程独立</strong>的，不同的 NioEventLoop 线程之间不会发生任何交集。</li><li>NioEventLoop 完成数据读取后，会调用绑定的 ChannelPipeline 进行事件传播，ChannelPipeline 也是<strong>线程安全</strong>的，数据会被传递到 ChannelPipeline 的第一个 ChannelHandler 中。数据处理完成后，将加工完成的数据再传递给下一个 ChannelHandler，整个过程是<strong>串行化</strong>执行，不会发生线程上下文切换的问题。</li></ul><p>NioEventLoop 无锁串行化的设计不仅使系统吞吐量达到最大化，而且降低了用户开发业务逻辑的难度，不需要花太多精力关心线程安全问题。虽然单线程执行避免了线程切换，但是它的<strong>缺陷就是不能执行时间过长的 I&#x2F;O 操作</strong>，一旦某个 I&#x2F;O 事件发生阻塞，那么后续的所有 I&#x2F;O 事件都无法执行，甚至造成事件积压。在使用 Netty 进行程序开发时，我们一定要对 ChannelHandler 的实现逻辑有充分的风险意识。</p><h1 id="2-初始化流程"><a href="#2-初始化流程" class="headerlink" title="2 初始化流程"></a>2 初始化流程</h1><h2 id="2-1-服务端代码"><a href="#2-1-服务端代码" class="headerlink" title="2.1 服务端代码"></a>2.1 服务端代码</h2><p>在Netty中，服务端代码基本如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> &#123;<br>        EventLoopGroup  bossGroup=<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>(<span class="hljs-number">1</span>);<br>        EventLoopGroup  workerGroup=<span class="hljs-keyword">new</span> <span class="hljs-title class_">NioEventLoopGroup</span>();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-type">ServerBootstrap</span> <span class="hljs-variable">serverBootstrap</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrap</span>();<br>            serverBootstrap<br>                    .group(bossGroup,workerGroup)<br>                    .channel(NioServerSocketChannel.class) <span class="hljs-comment">//boss group中chennel类型</span><br>                    .option(ChannelOption.SO_BACKLOG,<span class="hljs-number">1024</span>)<br>                    .option(ChannelOption.SO_REUSEADDR,<span class="hljs-literal">true</span>)<br>                    .childOption(ChannelOption.TCP_NODELAY,<span class="hljs-literal">true</span>)<br>                    .childOption(ChannelOption.SO_RCVBUF,<span class="hljs-number">64</span>*<span class="hljs-number">1024</span>)<br>                    .childOption(ChannelOption.SO_SNDBUF,<span class="hljs-number">64</span>*<span class="hljs-number">1024</span>)<br>                    .childHandler(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(Channel channel)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                            <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> channel.pipeline();<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">NettyServerHandler</span>());<br>                        &#125;<br>                    &#125;);<br>            ChannelFuture channelFuture= serverBootstrap.bind(<span class="hljs-number">10009</span>).sync(); <span class="hljs-comment">//bind()即是服务端初始化入口</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<span class="hljs-keyword">finally</span> &#123;<br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-NioServerSocketChannel构建与初始化"><a href="#2-2-NioServerSocketChannel构建与初始化" class="headerlink" title="2.2 NioServerSocketChannel构建与初始化"></a>2.2 NioServerSocketChannel构建与初始化</h2><p>在上述代码中，主要入口是<code>serverBootstrap.bind(10009)</code>。在此方法中，开始初始化并启动Netty服务端，其主要逻辑是通过<code>initAndRegister()</code>函数构建出BossGroup内部的Channel，并初始化此Channel。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.bootstrap.AbstractBootstrap#doBind</span><br><span class="hljs-keyword">private</span> ChannelFuture <span class="hljs-title function_">doBind</span><span class="hljs-params">(<span class="hljs-keyword">final</span> SocketAddress localAddress)</span> &#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> initAndRegister();  <span class="hljs-comment">//构建并初始化channel</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> regFuture.channel();<br>        <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> regFuture;<br>        &#125;<br><span class="hljs-comment">//·······省略部分代码········</span><br>    &#125;<br></code></pre></td></tr></table></figure><p>在<code>initAndRegister()</code>中，逻辑如下所示，主要流程有：</p><ol><li>通过<code>channelFactory</code>创建出BossGroup内部的Channel，其默认的channel是<code>NioServerSocketChannel</code></li><li>通过<code>init(channel)</code>初始化此channel；</li><li>将此channel实例，注册到BossGroup内部的NioEventLoop中。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> ChannelFuture <span class="hljs-title function_">initAndRegister</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">Channel</span> <span class="hljs-variable">channel</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        channel = channelFactory.newChannel();<br>        init(channel);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br><span class="hljs-comment">//·······省略部分代码········</span><br>    &#125;<br><br>    <span class="hljs-type">ChannelFuture</span> <span class="hljs-variable">regFuture</span> <span class="hljs-operator">=</span> config().group().register(channel);<br>    <span class="hljs-keyword">if</span> (regFuture.cause() != <span class="hljs-literal">null</span>) &#123;<br>        <span class="hljs-keyword">if</span> (channel.isRegistered()) &#123;<br>            channel.close();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            channel.unsafe().closeForcibly();<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> regFuture;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-1-NioServerSocketChannel构建"><a href="#2-2-1-NioServerSocketChannel构建" class="headerlink" title="2.2.1 NioServerSocketChannel构建"></a>2.2.1 NioServerSocketChannel构建</h3><p>在1.1章节中，回向ServerBootstrap中设置channel的类型为<code>NioServerSocketChannel.class</code>，因此在channel构建时，会通过channelFactory实例构建出NioServerSocketChannel的实例，即nioServerSocketChannel。</p><h3 id="2-2-2-NioServerSocketChannel初始化"><a href="#2-2-2-NioServerSocketChannel初始化" class="headerlink" title="2.2.2 NioServerSocketChannel初始化"></a>2.2.2 NioServerSocketChannel初始化</h3><p>channel初始化的逻辑如下所示，主要有：</p><ol><li>通过channel获取到channel的ChannelPipeline</li><li>向ChannelPipeline中添加<code>ServerBootstrapAcceptor</code>，并且通过<code>ch.eventLoop().execute()</code>来执行一个task任务，具体作用就是：<ol><li>向ChannelPipeline中增加一个handle，这个handle的具体作用是将客户端连接的channel注册到work group中。</li><li>使用<code>boosGroup</code>中的<code>eventloop</code>来添加<code>ServerBootstrapAcceptor</code>，是为了间接启动<code>boosGroup</code>中的<code>eventloop</code>线程，用于处理任务事件或者io事件。</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.bootstrap.ServerBootstrap#init</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(Channel channel)</span> &#123;<br>        setChannelOptions(channel, newOptionsArray(), logger);<br>        setAttributes(channel, attrs0().entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY));<br><br>        <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> channel.pipeline();<br><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">EventLoopGroup</span> <span class="hljs-variable">currentChildGroup</span> <span class="hljs-operator">=</span> childGroup;<br>        <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">currentChildHandler</span> <span class="hljs-operator">=</span> childHandler;<br>        <span class="hljs-keyword">final</span> Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] currentChildOptions;<br>        <span class="hljs-keyword">synchronized</span> (childOptions) &#123;<br>            currentChildOptions = childOptions.entrySet().toArray(EMPTY_OPTION_ARRAY);<br>        &#125;<br>        <span class="hljs-keyword">final</span> Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] currentChildAttrs = childAttrs.entrySet().toArray(EMPTY_ATTRIBUTE_ARRAY);<br><br>        p.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelInitializer</span>&lt;Channel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">initChannel</span><span class="hljs-params">(<span class="hljs-keyword">final</span> Channel ch)</span> &#123;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> ch.pipeline();<br>                <span class="hljs-type">ChannelHandler</span> <span class="hljs-variable">handler</span> <span class="hljs-operator">=</span> config.handler();<br>                <span class="hljs-keyword">if</span> (handler != <span class="hljs-literal">null</span>) &#123;<br>                    pipeline.addLast(handler);<br>                &#125;<br><br>                ch.eventLoop().execute(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Runnable</span>() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                        pipeline.addLast(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerBootstrapAcceptor</span>(<br>                                ch, currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;);<br>    &#125;<br></code></pre></td></tr></table></figure><h3 id="2-2-3-NioServerSocketChannel注册"><a href="#2-2-3-NioServerSocketChannel注册" class="headerlink" title="2.2.3 NioServerSocketChannel注册"></a>2.2.3 NioServerSocketChannel注册</h3><p>从代码中可知，通过<code>config().group().register(channel);</code>将此channel注册到boss group中，主要逻辑为：</p><ol><li><p>通过<code>bossGroup#register()</code>注册channel，在<code>bossGroup#register()</code>中，会选择内部的一个eventLoop进行注册此channel。</p></li><li><p>如下代码，最终是调用<code>SingleThreadEventLoop#register(io.netty.channel.ChannelPromise)</code>将channel注册到eventloop中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> ChannelFuture <span class="hljs-title function_">register</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>    ObjectUtil.checkNotNull(promise, <span class="hljs-string">&quot;promise&quot;</span>);<br>    promise.channel().unsafe().register(<span class="hljs-built_in">this</span>, promise); <span class="hljs-comment">//内部是使用的channel的unsafe类进行注册</span><br>    <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在<code>SingleThreadEventLoop#register(io.netty.channel.ChannelPromise)</code>中，将eventLoop对象注入到channel中，因为一个eventLoop可以处理多个channel的io事件，但是一个channel只能有一个线程进行处理，所以channel中需要持有唯一的目标eventloop。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.AbstractChannel.AbstractUnsafe#register</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">register</span><span class="hljs-params">(EventLoop eventLoop, <span class="hljs-keyword">final</span> ChannelPromise promise)</span> &#123;<br>            <span class="hljs-comment">//·······省略部分代码········</span><br>            AbstractChannel.<span class="hljs-built_in">this</span>.eventLoop = eventLoop;  <span class="hljs-comment">//eventLoop注入到channel中</span><br>            <span class="hljs-keyword">if</span> (eventLoop.inEventLoop()) &#123;<br>                register0(promise);<span class="hljs-comment">//注册，计算此channel的selectKey</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">//·······省略部分代码········</span><br>        &#125;<br></code></pre></td></tr></table></figure></li><li><p>在构建eventloop时，会构建出<code>select</code>对象。在注册channel时，会根据eventloop的select计算出此channel的<code>selectionKey</code>，后续在处理io事件时，此selectionKey就表示此channel有io事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">//io.netty.channel.nio.AbstractNioChannel#doRegister </span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegister</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">boolean</span> <span class="hljs-variable">selected</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 通过EventLoop的select对象，计算出此channel的selectionKey，并注入到channel中</span><br>                selectionKey = javaChannel().register(eventLoop().unwrappedSelector(), <span class="hljs-number">0</span>, <span class="hljs-built_in">this</span>);<br>                <span class="hljs-keyword">return</span>;<br>          <span class="hljs-comment">//·······省略部分代码········</span><br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure></li></ol><h1 id="3-BossGroup监听连接与NioSocketChannel创建与注册"><a href="#3-BossGroup监听连接与NioSocketChannel创建与注册" class="headerlink" title="3 BossGroup监听连接与NioSocketChannel创建与注册"></a>3 BossGroup监听连接与NioSocketChannel创建与注册</h1><p>BossGroup内部使用的是NioServerSocketChannel，在此channel构建的时候会注册监听<code>SelectionKey.OP_ACCEPT</code>类型的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-title function_">NioServerSocketChannel</span><span class="hljs-params">(ServerSocketChannel channel)</span> &#123;<br>    <span class="hljs-built_in">super</span>(<span class="hljs-literal">null</span>, channel, SelectionKey.OP_ACCEPT);<br>    config = <span class="hljs-keyword">new</span> <span class="hljs-title class_">NioServerSocketChannelConfig</span>(<span class="hljs-built_in">this</span>, javaChannel().socket());<br>&#125;<br></code></pre></td></tr></table></figure><p>在NioServerSocketChannel注册完成后，就会开启监听channel事件，即NioEventLoop中读取数据逻辑。即当一个客户端连接时，<code>NioEventLoop#run()</code>会处理此io事件，最终调用<code>io.netty.channel.nio.NioEventLoop#processSelectedKey</code>函数处理此io事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">processSelectedKeys</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (selectedKeys != <span class="hljs-literal">null</span>) &#123;<br>        processSelectedKeysOptimized();  <span class="hljs-comment">//开启selector优化后逻辑</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        processSelectedKeysPlain(selector.selectedKeys());  <span class="hljs-comment">//未开启selector优化逻辑</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过对代码继续深入，则最终会调用channel的unsafe内部类对象read方法，进行读取数据。在boss group中，绑定的是NioServerSocketChannel，即是AbstractNioMessageChannel的子类，所以对应的read方法是<code>io.netty.channel.nio.AbstractNioMessageChannel.NioMessageUnsafe#read</code>。其大致逻辑如下所示：</p><ol><li>获取pipeline，对RecvByteBufAllocator对象设置参数。</li><li>通过doReadMessages(readBuf)，创建对应的NioSocketChannel，将NioSocketChannel对象缓存到readBuf中。</li><li>读取readBuf中NioSocketChannel，将其放入到pipeline中，等待下一个处理器处理。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>            <span class="hljs-keyword">assert</span> <span class="hljs-title function_">eventLoop</span><span class="hljs-params">()</span>.inEventLoop();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> config();<br>            <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> pipeline();<br>            <span class="hljs-keyword">final</span> RecvByteBufAllocator.<span class="hljs-type">Handle</span> <span class="hljs-variable">allocHandle</span> <span class="hljs-operator">=</span> unsafe().recvBufAllocHandle();<br>            allocHandle.reset(config);<br><br>            <span class="hljs-type">boolean</span> <span class="hljs-variable">closed</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>            <span class="hljs-type">Throwable</span> <span class="hljs-variable">exception</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">do</span> &#123;<br>                        <span class="hljs-type">int</span> <span class="hljs-variable">localRead</span> <span class="hljs-operator">=</span> doReadMessages(readBuf); <span class="hljs-comment">//readBuf是一个List&lt;Object&gt;对象。在这里存储NioSocketChannel</span><br>                        <span class="hljs-keyword">if</span> (localRead == <span class="hljs-number">0</span>) &#123;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (localRead &lt; <span class="hljs-number">0</span>) &#123;<br>                            closed = <span class="hljs-literal">true</span>;<br>                            <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        allocHandle.incMessagesRead(localRead);<br>                    &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                    exception = t;<br>                &#125;<br>                <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> readBuf.size();<br>                <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; size; i ++) &#123;<br>                    readPending = <span class="hljs-literal">false</span>;<br>                    pipeline.fireChannelRead(readBuf.get(i)); <span class="hljs-comment">//放入pipeline，让下一个处理器处理</span><br>                &#125;<br>                readBuf.clear();<br>                allocHandle.readComplete();<br>                pipeline.fireChannelReadComplete();<br>                <span class="hljs-keyword">if</span> (exception != <span class="hljs-literal">null</span>) &#123;<br>                    closed = closeOnReadError(exception);<br>                    pipeline.fireExceptionCaught(exception);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (closed) &#123;<br>                    inputShutdown = <span class="hljs-literal">true</span>;<br>                    <span class="hljs-keyword">if</span> (isOpen()) &#123;<br>                        close(voidPromise());<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>                    removeReadOp();<br>                &#125;<br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure><p>在前文channel初始化的时候，在boss group中，NioServerSocketChannel注册了一个ServerBootstrapAcceptor，这个是一个<code>ChannelInboundHandlerAdapter</code>，也即是说，在前文创建并被pipeline中下一个处理器处理的NioSocketChannel对象会被<code>ChannelInboundHandlerAdapter</code>处理。</p><p>与其他逻辑类似，其主要逻辑在内部的channelRead函数，如下所示：</p><ul><li>从下文代码中可以看出，最终是调用<code>childGroup.register(child)</code>逻辑，将NioSocketChannel注册到workgroup中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">Channel</span> <span class="hljs-variable">child</span> <span class="hljs-operator">=</span> (Channel) msg;<br>    child.pipeline().addLast(childHandler);<br>    setChannelOptions(child, childOptions, logger);<br>    setAttributes(child, childAttrs);<br><br>    <span class="hljs-keyword">try</span> &#123;<br>        childGroup.register(child).addListener(<span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelFutureListener</span>() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">operationComplete</span><span class="hljs-params">(ChannelFuture future)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>                <span class="hljs-keyword">if</span> (!future.isSuccess()) &#123;<br>                    forceClose(child, future.cause());<br>                &#125;<br>            &#125;<br>        &#125;);<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        forceClose(child, t);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="4-WorkGroup处理IO事件"><a href="#4-WorkGroup处理IO事件" class="headerlink" title="4 WorkGroup处理IO事件"></a>4 WorkGroup处理IO事件</h1><p>在前文，NioSocketChannel被注册到WorkGroup中的NioEventLoop后，其处理IO事件的主要逻辑与boss group的逻辑类似，主要区别是在调用channel内部unsafe对象的read方法时，在WorkGroup中是调用的<code>io.netty.channel.nio.AbstractNioByteChannel.NioByteUnsafe#read</code>函数。其主要逻辑如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">read</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelConfig</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> config();<br>    <span class="hljs-keyword">if</span> (shouldBreakReadReady(config)) &#123;<br>        clearReadPending();<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ChannelPipeline</span> <span class="hljs-variable">pipeline</span> <span class="hljs-operator">=</span> pipeline();<br>    <span class="hljs-keyword">final</span> <span class="hljs-type">ByteBufAllocator</span> <span class="hljs-variable">allocator</span> <span class="hljs-operator">=</span> config.getAllocator();  <span class="hljs-comment">//获取allocator对象</span><br>    <span class="hljs-keyword">final</span> RecvByteBufAllocator.<span class="hljs-type">Handle</span> <span class="hljs-variable">allocHandle</span> <span class="hljs-operator">=</span> recvBufAllocHandle();<br>    allocHandle.reset(config);<br><br>    <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">byteBuf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">close</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            byteBuf = allocHandle.allocate(allocator); <span class="hljs-comment">//使用allocator对象分配一个缓存</span><br>            allocHandle.lastBytesRead(doReadBytes(byteBuf)); <span class="hljs-comment">//读取数据到缓存</span><br>            <span class="hljs-keyword">if</span> (allocHandle.lastBytesRead() &lt;= <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-comment">// nothing was read. release the buffer.</span><br>                byteBuf.release();<br>                byteBuf = <span class="hljs-literal">null</span>;<br>                close = allocHandle.lastBytesRead() &lt; <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">if</span> (close) &#123;<br>                    <span class="hljs-comment">// There is nothing left to read as we received an EOF.</span><br>                    readPending = <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            allocHandle.incMessagesRead(<span class="hljs-number">1</span>);<br>            readPending = <span class="hljs-literal">false</span>;<br>            pipeline.fireChannelRead(byteBuf); <span class="hljs-comment">//将byteBuf传递给pipeline的下一个handle处理</span><br>            byteBuf = <span class="hljs-literal">null</span>;<br>        &#125; <span class="hljs-keyword">while</span> (allocHandle.continueReading());<br><br>        allocHandle.readComplete();<br>        pipeline.fireChannelReadComplete();<br><br>        <span class="hljs-keyword">if</span> (close) &#123;<br>            closeOnRead(pipeline);<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>        handleReadException(pipeline, byteBuf, t, close, allocHandle);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-comment">// Check if there is a readPending which was not processed yet.</span><br>        <span class="hljs-comment">// This could be for two reasons:</span><br>        <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelRead(...) method</span><br>        <span class="hljs-comment">// * The user called Channel.read() or ChannelHandlerContext.read() in channelReadComplete(...) method</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2254</span><br>        <span class="hljs-keyword">if</span> (!readPending &amp;&amp; !config.isAutoRead()) &#123;<br>            removeReadOp();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.4-Netty中Selector优化</title>
    <link href="/2024/06/02/Netty/2.4-Netty%E4%B8%ADSelector%E4%BC%98%E5%8C%96/"/>
    <url>/2024/06/02/Netty/2.4-Netty%E4%B8%ADSelector%E4%BC%98%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h1 id="1-数据结构优化"><a href="#1-数据结构优化" class="headerlink" title="1 数据结构优化"></a>1 数据结构优化</h1><p>Netty是基于jdk的NIO进行通信。如下所示，在NIO中，使用的是Set数据结构存储IO事件。当IO就绪，服务器监听到事件后会封装成SelectionKey放到HashSet中, 然后程序就可以从这个HashSet中取出事件进行处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectorImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">AbstractSelector</span> &#123;<br>    <span class="hljs-keyword">protected</span> Set&lt;SelectionKey&gt; selectedKeys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>    <span class="hljs-keyword">protected</span> HashSet&lt;SelectionKey&gt; keys = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashSet</span>();<br>    <span class="hljs-keyword">private</span> Set&lt;SelectionKey&gt; publicKeys;<br>    <span class="hljs-keyword">private</span> Set&lt;SelectionKey&gt; publicSelectedKeys;<br>    <span class="hljs-keyword">protected</span> <span class="hljs-title function_">SelectorImpl</span><span class="hljs-params">(SelectorProvider var1)</span> &#123;<br>        <span class="hljs-built_in">super</span>(var1);<br>        <span class="hljs-keyword">if</span> (Util.atBugLevel(<span class="hljs-string">&quot;1.4&quot;</span>)) &#123;<br>            <span class="hljs-built_in">this</span>.publicKeys = <span class="hljs-built_in">this</span>.keys;<br>            <span class="hljs-built_in">this</span>.publicSelectedKeys = <span class="hljs-built_in">this</span>.selectedKeys;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">this</span>.publicKeys = Collections.unmodifiableSet(<span class="hljs-built_in">this</span>.keys);<br>            <span class="hljs-built_in">this</span>.publicSelectedKeys = Util.ungrowableSet(<span class="hljs-built_in">this</span>.selectedKeys);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>HashSet的add方法在发生哈希冲突时的时间复杂度是O(n)。Netty为了提高效率，在服务启动时，通过反射的方式，将Set数据结构改为数组结构，然后替换JDK中原始的SelectionKey集合，在新增元素时，其复杂度降低为O(1)。</p><p>每个IO线程都绑定了唯一的复用器，因此Selector的初始化时机是在创建NioEventLoop时。首先声明了一个数据结构，用于存储selectot，如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// NioEventLoop.java</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SelectorTuple</span> &#123;<br>        <span class="hljs-keyword">final</span> Selector unwrappedSelector; <span class="hljs-comment">//jdk中selector</span><br>        <span class="hljs-keyword">final</span> Selector selector;<span class="hljs-comment">//优化后的selector</span><br>        SelectorTuple(Selector unwrappedSelector) &#123;<br>            <span class="hljs-built_in">this</span>.unwrappedSelector = unwrappedSelector;<br>            <span class="hljs-built_in">this</span>.selector = unwrappedSelector;<br>        &#125;<br>        SelectorTuple(Selector unwrappedSelector, Selector selector) &#123;<br>            <span class="hljs-built_in">this</span>.unwrappedSelector = unwrappedSelector;<br>            <span class="hljs-built_in">this</span>.selector = selector;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>在构建NioEventLoop时，在构造器中会调用<code>openSelector()</code>，此方法会返回selectorTuple对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// NioEventLoop.java</span><br><span class="hljs-keyword">final</span> <span class="hljs-type">SelectorTuple</span> <span class="hljs-variable">selectorTuple</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.openSelector(); <br></code></pre></td></tr></table></figure><p>在<code>openSelector()</code>中，会判断当前是否支持优化：</p><ul><li>如果不支持优化，则返回jdk中selector。</li><li>如果支持优化，则通过反射的方式，替换jdk中的原生的SelectionKeySet，以提高效率。具体如下所示。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// NioEventLoop.java</span><br><span class="hljs-keyword">private</span> SelectorTuple <span class="hljs-title function_">openSelector</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-keyword">final</span> Selector unwrappedSelector; <span class="hljs-comment">// 从命名就可以看出来Netty对Java的多路复用器做了封装</span><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">/**</span><br><span class="hljs-comment">             * jdk底层的api</span><br><span class="hljs-comment">             * 创建了Java的IO多路复用器selector</span><br><span class="hljs-comment">             */</span><br>            unwrappedSelector = <span class="hljs-built_in">this</span>.provider.openSelector();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ChannelException</span>(<span class="hljs-string">&quot;failed to open a new selector&quot;</span>, e);<br>        &#125;<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 判断是否需要关闭优化</span><br><span class="hljs-comment">         * 默认false 也就说默认需要进行优化</span><br><span class="hljs-comment">         * netty要对jdk原生的selector进行优化 selector在select()操作的时候 会通过selector.selectedKeys()操作返回一个Set&lt;SelectionKey&gt; 这个是Set类型 netty对这个set进行了处理 使用SelectedSelectionKeySet这个数据结构进行了替换 当在select()操作时将key存入一个SelectedSelectionKeySet数据结构中</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (DISABLE_KEY_SET_OPTIMIZATION) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectorTuple</span>(unwrappedSelector); <span class="hljs-comment">// 不需要优化 直接使用Java原生的复用器实现</span><br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">maybeSelectorImplClass</span> <span class="hljs-operator">=</span> AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">/**</span><br><span class="hljs-comment">                     * 反射获取sun.nio.ch.SelectorImpl这个类的class对象</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-keyword">return</span> Class.forName(<span class="hljs-string">&quot;sun.nio.ch.SelectorImpl&quot;</span>, <span class="hljs-literal">false</span>, PlatformDependent.getSystemClassLoader());<br>                &#125; <span class="hljs-keyword">catch</span> (Throwable cause) &#123;<br>                    <span class="hljs-keyword">return</span> cause;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 判断拿到的class对象是不是Selector的实现类</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">if</span> (!(maybeSelectorImplClass <span class="hljs-keyword">instanceof</span> Class) || !((Class&lt;?&gt;) maybeSelectorImplClass).isAssignableFrom(unwrappedSelector.getClass()))<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectorTuple</span>(unwrappedSelector);<br><br>        <span class="hljs-comment">// 这个class对象是Selector的实现</span><br>        <span class="hljs-keyword">final</span> Class&lt;?&gt; selectorImplClass = (Class&lt;?&gt;) maybeSelectorImplClass;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 自定义数据结构替代jdk原生的SelectionKeySet</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-keyword">final</span> <span class="hljs-type">SelectedSelectionKeySet</span> <span class="hljs-variable">selectedKeySet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectedSelectionKeySet</span>();<br><br>        <span class="hljs-type">Object</span> <span class="hljs-variable">maybeException</span> <span class="hljs-operator">=</span> AccessController.doPrivileged(<span class="hljs-keyword">new</span> <span class="hljs-title class_">PrivilegedAction</span>&lt;Object&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">/**</span><br><span class="hljs-comment">                     * 通过反射拿到</span><br><span class="hljs-comment">                     * selectedKeys属性</span><br><span class="hljs-comment">                     * publicSelectedKeys属性</span><br><span class="hljs-comment">                     * 这两个属性都是HashSet的实现方式</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-type">Field</span> <span class="hljs-variable">selectedKeysField</span> <span class="hljs-operator">=</span> selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;selectedKeys&quot;</span>);<br>                    <span class="hljs-type">Field</span> <span class="hljs-variable">publicSelectedKeysField</span> <span class="hljs-operator">=</span> selectorImplClass.getDeclaredField(<span class="hljs-string">&quot;publicSelectedKeys&quot;</span>);<br>                    <span class="hljs-keyword">if</span> (PlatformDependent.javaVersion() &gt;= <span class="hljs-number">9</span> &amp;&amp; PlatformDependent.hasUnsafe()) &#123;<br>                        <span class="hljs-comment">// Let us try to use sun.misc.Unsafe to replace the SelectionKeySet.</span><br>                        <span class="hljs-comment">// This allows us to also do this in Java9+ without any extra flags.</span><br>                        <span class="hljs-type">long</span> <span class="hljs-variable">selectedKeysFieldOffset</span> <span class="hljs-operator">=</span> PlatformDependent.objectFieldOffset(selectedKeysField);<br>                        <span class="hljs-type">long</span> <span class="hljs-variable">publicSelectedKeysFieldOffset</span> <span class="hljs-operator">=</span> PlatformDependent.objectFieldOffset(publicSelectedKeysField);<br><br>                        <span class="hljs-keyword">if</span> (selectedKeysFieldOffset != -<span class="hljs-number">1</span> &amp;&amp; publicSelectedKeysFieldOffset != -<span class="hljs-number">1</span>) &#123;<br>                            PlatformDependent.putObject(unwrappedSelector, selectedKeysFieldOffset, selectedKeySet);<br>                            PlatformDependent.putObject(unwrappedSelector, publicSelectedKeysFieldOffset, selectedKeySet);<br>                            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                        &#125;<br>                        <span class="hljs-comment">// We could not retrieve the offset, lets try reflection as last-resort.</span><br>                    &#125;<br><br>                    <span class="hljs-comment">/**</span><br><span class="hljs-comment">                     * 将拿到的两个属性设置成可修改的</span><br><span class="hljs-comment">                     */</span><br>                    <span class="hljs-type">Throwable</span> <span class="hljs-variable">cause</span> <span class="hljs-operator">=</span> ReflectionUtil.trySetAccessible(selectedKeysField, <span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> cause;<br>                    cause = ReflectionUtil.trySetAccessible(publicSelectedKeysField, <span class="hljs-literal">true</span>);<br>                    <span class="hljs-keyword">if</span> (cause != <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> cause;<br><br>                    <span class="hljs-comment">/**</span><br><span class="hljs-comment">                     * 将selector的两个属性都换成netty的selectedKeySet实现的数据结构</span><br><span class="hljs-comment">                     */</span><br>                    selectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                    publicSelectedKeysField.set(unwrappedSelector, selectedKeySet);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>                &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException e) &#123;<br>                    <span class="hljs-keyword">return</span> e;<br>                &#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>                    <span class="hljs-keyword">return</span> e;<br>                &#125;<br>            &#125;<br>        &#125;);<br><br>        <span class="hljs-keyword">if</span> (maybeException <span class="hljs-keyword">instanceof</span> Exception) &#123;<br>            <span class="hljs-built_in">this</span>.selectedKeys = <span class="hljs-literal">null</span>;<br>            <span class="hljs-type">Exception</span> <span class="hljs-variable">e</span> <span class="hljs-operator">=</span> (Exception) maybeException;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectorTuple</span>(unwrappedSelector);<br>        &#125;<br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         * 将优化后的keySet保存成NioEventLoop的成员变量</span><br><span class="hljs-comment">         */</span><br>        <span class="hljs-built_in">this</span>.selectedKeys = selectedKeySet;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectorTuple</span>(unwrappedSelector, <span class="hljs-keyword">new</span> <span class="hljs-title class_">SelectedSelectionKeySetSelector</span>(unwrappedSelector, selectedKeySet));<br>    &#125;<br></code></pre></td></tr></table></figure><h1 id="2-Netty-空轮询优化"><a href="#2-Netty-空轮询优化" class="headerlink" title="2 Netty 空轮询优化"></a>2 Netty 空轮询优化</h1><h2 id="2-1-问题原因"><a href="#2-1-问题原因" class="headerlink" title="2.1 问题原因"></a>2.1 问题原因</h2><p>NIO空轮询（Empty Polling）是指在使用Java NIO 时，当Selector上注册的Channel没有就绪事件时，Selector.select()方法会返回0，但该方法会导致CPU空转，因为它会不断地调用操作系统的底层select系统调用。这种现象被称为NIO空轮询的bug。</p><p>在Netty中，使用selectCnt计数的机制来避免空轮询，当strategy的值为0时，进行检测selectCnt的值。如果大于默认的阈值，则重新构建selector。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">()</span> &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">selectCnt</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;  <span class="hljs-comment">//使用此机制来鉴定是否发生了空轮询</span><br>        <span class="hljs-keyword">for</span> (;;) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-type">int</span> strategy;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-comment">//如果发生空轮询，则会返回0</span><br>                    strategy = selectStrategy.calculateStrategy(selectNowSupplier, hasTasks());<br>                    <span class="hljs-keyword">switch</span> (strategy) &#123;<br>                    <span class="hljs-keyword">case</span> SelectStrategy.CONTINUE:<br>                        <span class="hljs-keyword">continue</span>;<br><br>                    <span class="hljs-keyword">case</span> SelectStrategy.BUSY_WAIT:<br>                        <span class="hljs-comment">// fall-through to SELECT since the busy-wait is not supported with NIO</span><br><br>                    <span class="hljs-keyword">case</span> SelectStrategy.SELECT:<br>                        <span class="hljs-type">long</span> <span class="hljs-variable">curDeadlineNanos</span> <span class="hljs-operator">=</span> nextScheduledTaskDeadlineNanos();<br>                        <span class="hljs-keyword">if</span> (curDeadlineNanos == -<span class="hljs-number">1L</span>) &#123;<br>                            curDeadlineNanos = NONE; <span class="hljs-comment">// nothing on the calendar</span><br>                        &#125;<br>                        nextWakeupNanos.set(curDeadlineNanos);<br>                        <span class="hljs-keyword">try</span> &#123;<br>                            <span class="hljs-keyword">if</span> (!hasTasks()) &#123;<br>                                strategy = select(curDeadlineNanos);<br>                            &#125;<br>                        &#125; <span class="hljs-keyword">finally</span> &#123;<br>                            <span class="hljs-comment">// This update is just to help block unnecessary selector wakeups</span><br>                            <span class="hljs-comment">// so use of lazySet is ok (no race condition)</span><br>                            nextWakeupNanos.lazySet(AWAKE);<br>                        &#125;<br>                        <span class="hljs-comment">// fall through</span><br>                    <span class="hljs-keyword">default</span>:<br>                    &#125;<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    <span class="hljs-comment">// If we receive an IOException here its because the Selector is messed up. Let&#x27;s rebuild</span><br>                    <span class="hljs-comment">// the selector and retry. https://github.com/netty/netty/issues/8566</span><br>                    rebuildSelector0();<br>                    selectCnt = <span class="hljs-number">0</span>;<br>                    handleLoopException(e);<br>                    <span class="hljs-keyword">continue</span>;<br>                &#125;<br><br>                selectCnt++;<br>                cancelledKeys = <span class="hljs-number">0</span>;<br>                needsToSelectAgain = <span class="hljs-literal">false</span>;<br>                <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> <span class="hljs-variable">ioRatio</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.ioRatio;<br>                <span class="hljs-type">boolean</span> ranTasks;<br>                <span class="hljs-keyword">if</span> (ioRatio == <span class="hljs-number">100</span>) &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123;<br>                            processSelectedKeys();<br>                        &#125;<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-comment">// Ensure we always run tasks.</span><br>                        ranTasks = runAllTasks();<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strategy &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ioStartTime</span> <span class="hljs-operator">=</span> System.nanoTime();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        processSelectedKeys();<br>                    &#125; <span class="hljs-keyword">finally</span> &#123;<br>                        <span class="hljs-comment">// Ensure we always run tasks.</span><br>                        <span class="hljs-keyword">final</span> <span class="hljs-type">long</span> <span class="hljs-variable">ioTime</span> <span class="hljs-operator">=</span> System.nanoTime() - ioStartTime;<br>                        ranTasks = runAllTasks(ioTime * (<span class="hljs-number">100</span> - ioRatio) / ioRatio);<br>                    &#125;<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    ranTasks = runAllTasks(<span class="hljs-number">0</span>); <span class="hljs-comment">// This will run the minimum number of tasks</span><br>                &#125;<br><br>                <span class="hljs-keyword">if</span> (ranTasks || strategy &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-keyword">if</span> (selectCnt &gt; MIN_PREMATURE_SELECTOR_RETURNS &amp;&amp; logger.isDebugEnabled()) &#123;<br>                        logger.debug(<span class="hljs-string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row for Selector &#123;&#125;.&quot;</span>,<br>                                selectCnt - <span class="hljs-number">1</span>, selector);<br>                    &#125;<br>                    selectCnt = <span class="hljs-number">0</span>;  <span class="hljs-comment">//如果未发生空轮询，则将计数置为0</span><br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (unexpectedSelectorWakeup(selectCnt)) &#123; <span class="hljs-comment">//在这里判断是否发生空轮询，如果发生则重新构建selector</span><br>                    selectCnt = <span class="hljs-number">0</span>;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (CancelledKeyException e) &#123;<br>                <span class="hljs-comment">// Harmless exception - log anyway</span><br>                <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>                    logger.debug(CancelledKeyException.class.getSimpleName() + <span class="hljs-string">&quot; raised by a Selector &#123;&#125; - JDK bug?&quot;</span>,<br>                            selector, e);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                handleLoopException(t);<br>            &#125;<br>            <span class="hljs-comment">// Always handle shutdown even if the loop processing threw an exception.</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (isShuttingDown()) &#123;<br>                    closeAll();<br>                    <span class="hljs-keyword">if</span> (confirmShutdown()) &#123;<br>                        <span class="hljs-keyword">return</span>;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                handleLoopException(t);<br>            &#125;<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">unexpectedSelectorWakeup</span><span class="hljs-params">(<span class="hljs-type">int</span> selectCnt)</span> &#123;<br>    <span class="hljs-keyword">if</span> (Thread.interrupted()) &#123;<br>        <span class="hljs-comment">// Thread was interrupted so reset selected keys and break so we not run into a busy loop.</span><br>        <span class="hljs-comment">// As this is most likely a bug in the handler of the user or it&#x27;s client library we will</span><br>        <span class="hljs-comment">// also log it.</span><br>        <span class="hljs-comment">//</span><br>        <span class="hljs-comment">// See https://github.com/netty/netty/issues/2426</span><br>        <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>            logger.debug(<span class="hljs-string">&quot;Selector.select() returned prematurely because &quot;</span> +<br>                    <span class="hljs-string">&quot;Thread.currentThread().interrupt() was called. Use &quot;</span> +<br>                    <span class="hljs-string">&quot;NioEventLoop.shutdownGracefully() to shutdown the NioEventLoop.&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (SELECTOR_AUTO_REBUILD_THRESHOLD &gt; <span class="hljs-number">0</span> &amp;&amp;   <span class="hljs-comment">//如果计数大于默认的阈值，则视为发生了空轮询</span><br>            selectCnt &gt;= SELECTOR_AUTO_REBUILD_THRESHOLD) &#123;<br>        <span class="hljs-comment">// The selector returned prematurely many times in a row.</span><br>        <span class="hljs-comment">// Rebuild the selector to work around the problem.</span><br>        logger.warn(<span class="hljs-string">&quot;Selector.select() returned prematurely &#123;&#125; times in a row; rebuilding Selector &#123;&#125;.&quot;</span>,<br>                selectCnt, selector);<br>        rebuildSelector();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>2.5-Netty编解码器详解</title>
    <link href="/2024/06/02/Netty/2.5-Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E8%AF%A6%E8%A7%A3/"/>
    <url>/2024/06/02/Netty/2.5-Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="1-TCP-半包与粘包"><a href="#1-TCP-半包与粘包" class="headerlink" title="1 TCP 半包与粘包"></a>1 TCP 半包与粘包</h1><p>半包与粘包的本质原因是 TCP 协议是<strong>流式协议</strong>，消息无边界，我们必须自己去找边界。当发送方连续发送多个小数据包时，接收方可能会将它们合并成一个大的数据包，这就是粘包问题；而当发送方发送的数据包长度大于接收方的缓冲区长度时，接收方无法完整接收数据包，导致数据的接收不完整，这就是半包问题。</p><h2 id="1-1-背景知识"><a href="#1-1-背景知识" class="headerlink" title="1.1 背景知识"></a>1.1 背景知识</h2><h3 id="1-1-1-TCP-滑动窗口机制"><a href="#1-1-1-TCP-滑动窗口机制" class="headerlink" title="1.1.1 TCP 滑动窗口机制"></a>1.1.1 TCP 滑动窗口机制</h3><p>TCP 协议是一种可靠性传输协议，所以在传输数据的时候必须要等到对方的应答之后才能发送下一条数据。为了解决这个传输效率的问题，引入了滑动窗口。滑动窗口就是在发送方和接收方都有一个缓冲区，这个缓冲区就是”窗口”，假设发送方的窗口大小是 <code>0~100KB</code>, 那么发送数据的时候前100KB 的数据不需要等到对方 ACK 应答即可全部发送。<br>如下图所示，初始时窗口大小是4，那么当发出一个数据之后并接到了就可以继续往下滑，比如：一开始窗口是在1，2，3，4这里的，后来1发送数据并且服务器响应 5 回来了，这时候窗口就变成了 2，3，4，5。</p><ul><li>窗口实际就起到一个缓冲区的作用，同时也能起到流量控制的作用</li><li>发出请求之后，在响应没有回来之前，窗口是不可以滑动的</li><li>接收方也会维护一个窗口，只有落在窗口内的数据才能允许接收</li></ul><p>​<img src="/../../images/Netty/Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E8%AF%A6%E8%A7%A3.png">​</p><h3 id="1-1-2-传输层的-MSS-与链路层的-MTU"><a href="#1-1-2-传输层的-MSS-与链路层的-MTU" class="headerlink" title="1.1.2 传输层的 MSS 与链路层的 MTU"></a>1.1.2 传输层的 MSS 与链路层的 MTU</h3><p><code>MSS</code> 是传输层的最大报文长度限制，而 <code>MTU</code> 则是链路层的最大数据包大小限制，一般 <code>MTU</code> 会限制 <code>MSS</code>，比如 <code>MTU=1500</code>，那么 <code>MSS</code> 每次传输的数据包大小只能是 <code>MTU-40=1460</code> (TCP 报文头大小为40)。</p><ul><li>每次传输的数据包大小超过 MSS 大小时，就会自动切割这个数据包，将大的数据包拆分成多个小包。</li><li>MSS 与 MTU 的限制是为了控制数发送速度，避免网络堵塞。</li></ul><h3 id="1-1-3-TCP-协议中的-Nagle-算法"><a href="#1-1-3-TCP-协议中的-Nagle-算法" class="headerlink" title="1.1.3 TCP 协议中的 Nagle 算法"></a>1.1.3 TCP 协议中的 Nagle 算法</h3><p>有这么一种情况，每次发送的数据包都非常小，比如只有1个字节，但是 TCP 的报文头默认有40个字节，数据+报文头一共是41字节。如果这种较小的数据包经常出现，会造成过多的网络资源浪费。比如有1W 个这样的数据包，那么总数据量中有400MB 都是报文头，只有10MB 是真正的数据。<br>所以 TCP 中引入了一种叫做 <code>Nagle</code> 的算法，如若连续几次发送的数据都很小，<code>TCP</code> 会根据这个算法把多个数据合并成一个包发出，从而优化传输效率，避免网络资源浪费。</p><h3 id="1-1-4-应用层的接收缓冲区和发送缓冲区"><a href="#1-1-4-应用层的接收缓冲区和发送缓冲区" class="headerlink" title="1.1.4 应用层的接收缓冲区和发送缓冲区"></a>1.1.4 应用层的接收缓冲区和发送缓冲区</h3><p>对于应用的 IO 操作，无论是发送还是接受，都是针对缓冲区操作的，各自对应一个缓冲区，在发送或接收时，将数据放到缓冲区中。</p><h2 id="1-2-产生原因分析"><a href="#1-2-产生原因分析" class="headerlink" title="1.2 产生原因分析"></a>1.2 产生原因分析</h2><h3 id="1-2-1-半包"><a href="#1-2-1-半包" class="headerlink" title="1.2.1 半包"></a>1.2.1 半包</h3><p><strong>现象</strong>：发送 <code>ABCDEFG</code> 一个数据包，被接收成 <code>ABC、DEFG</code> 两个数据包，一个包被拆成了多个。<br><strong>原因</strong>：</p><ul><li>应用层：接收方缓冲区太小，无法存放发送发的单个数据包，因此拆开读取。</li><li>滑动窗口：接收方的窗口太小，无法一次性放下完整的数据包，只能读取其中的一部分。. 假设接收方的窗口只剩了 128 bytes，发送方的报文大小是 256 bytes，这时放不下了，只能先发送前 128 bytes，等待 ack 后才能发送剩余部分，这就造成了半包。</li><li>MSS 限制：当发送的数据超过 MSS 限制后，会将数据切分发送，就会造成半包（计算机网络的知识，传输层的知识）</li></ul><h3 id="1-2-2-粘包"><a href="#1-2-2-粘包" class="headerlink" title="1.2.2 粘包"></a>1.2.2 粘包</h3><p><strong>现象</strong>：发送 <code>ABCD、EFGHIJK</code> 两个数据包，被接收成 <code>ABCDEFGHIJK</code> 一个数据包，多个包粘在一起。<br><strong>原因</strong>：</p><ul><li>应用层：接收方的接收缓冲区太大，导致读取多个数据包一起输出。</li><li>滑动窗口：接收方窗口较大，导致发送方发出的多个数据包处理不及时造成粘包。假设发送方 256 bytes 表示一个完整报文，但由于接收方处理不及时且窗口大小足够大，这 256 bytes 字节就会缓冲在接收方的滑动窗口中，当滑动窗口中缓冲了多个报文就会粘包</li><li>Nagle 算法：由于发送方的单个数据包体积太小，导致多个包合并成一个包发送</li></ul><h2 id="1-3-解决方案"><a href="#1-3-解决方案" class="headerlink" title="1.3 解决方案"></a>1.3 解决方案</h2><p>从上述的半包粘包的原因来看，产生的原因主要是 TCP 协议带来的。为解决这个问题，因此从应用层方面下手，解决半包与粘包问题。在 Netty 中，就是使用编解码器来处理半包与粘包问题。主要解决方案有三种封帧方式：</p><ol><li>采用固定长度。</li><li>采用特殊分隔符。</li><li>固定长度字段存内容长度信息（较常用）。</li></ol><h1 id="2-编码器"><a href="#2-编码器" class="headerlink" title="2 编码器"></a>2 编码器</h1><p>数据在网络传输过程中，只能以字节码的形式进行传输数据。编码器的作用就是根据特定的规则，将用户数据转换成字节码数据，方便网络传输。在转换过程中，使用特定的规则，处理 TCP 协议的半包与粘包问题。</p><h2 id="2-1-MessageToByteEncoder"><a href="#2-1-MessageToByteEncoder" class="headerlink" title="2.1 MessageToByteEncoder"></a>2.1 MessageToByteEncoder</h2><p>在 Netty 中提供众多的开箱即用的编码器，如 Bzip2Encoder 等。其解码器工作主要逻辑是在抽象父类 MessageToByteEncoder 中。其主要逻辑如下：</p><ul><li>MessageToByteEncoder继承 ChannelOutboundHandlerAdapter，在数据发送时，其 <code>write()</code> 会被调用。</li><li>在 <code>write()</code> 中调用了编码器方法 <code>encode(ctx, cast, buf)</code>，将用户数据（如 java 对象），编码成字节，写入到 ByteBuf 中。</li><li>调用 ctx 方法，将 ByteBuf 中数据写入到网络中。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageToByteEncoder</span>&lt;I&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelOutboundHandlerAdapter</span> &#123;<br>   <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (acceptOutboundMessage(msg)) &#123;<br>                <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>                <span class="hljs-type">I</span> <span class="hljs-variable">cast</span> <span class="hljs-operator">=</span> (I) msg;<br>                buf = allocateBuffer(ctx, cast, preferDirect);<br>                <span class="hljs-keyword">try</span> &#123;<br>                    encode(ctx, cast, buf);<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    ReferenceCountUtil.release(cast);<br>                &#125;<br>                <span class="hljs-keyword">if</span> (buf.isReadable()) &#123;<br>                    ctx.write(buf, promise);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    buf.release();<br>                    ctx.write(Unpooled.EMPTY_BUFFER, promise);<br>                &#125;<br><span class="hljs-comment">//  ········ 省略相关逻辑··············</span><br>    &#125;<br>    <br>   <span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, I msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception;  <br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-2-自定义编码器"><a href="#2-2-自定义编码器" class="headerlink" title="2.2 自定义编码器"></a>2.2 自定义编码器</h2><p>从上文可知编码主要是调用 <code>MessageToByteEncoder#encode()</code>，因此可通过实现此方法，来自定义编码器。</p><ul><li>@Sharable 表示可线程共享</li><li>按照一定的规则，向 ByteBuf 中写入数据。这个顺序比较重要，后续节码时，需要根据相应的顺序解码。ByteBuf 中会提供相关是方法，用于方便的写入 byte、long 数据等。</li><li>采用固定长度字段存内容长度信息的方式，处理 tcp 粘包与半包问题。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyEncoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MessageToByteEncoder</span>&lt;Command&gt; &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, Command msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-keyword">if</span> (msg == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">RemotingException</span>(<span class="hljs-string">&quot;encode msg is null&quot;</span>);<br>        &#125;<br>        out.writeByte(Command.MAGIC);<br>        out.writeByte(Command.VERSION);<br>        out.writeByte(msg.getType().ordinal());<br>        out.writeLong(msg.getOpaque());<br>        writeContext(msg, out);<br>        out.writeInt(msg.getBody().length);<br>        out.writeBytes(msg.getBody());<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">writeContext</span><span class="hljs-params">(Command msg, ByteBuf out)</span> &#123;<br>        <span class="hljs-type">byte</span>[] headerBytes = msg.getContext().toBytes();<br>        out.writeInt(headerBytes.length);<br>        out.writeBytes(headerBytes);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="3-解码器"><a href="#3-解码器" class="headerlink" title="3 解码器"></a>3 解码器</h1><p>解码器的作用就是将网络传输的字节数据，按照一定规则，解码成用户数据，如 java 对象等。</p><h2 id="3-1-ByteToMessageDecoder"><a href="#3-1-ByteToMessageDecoder" class="headerlink" title="3.1 ByteToMessageDecoder"></a>3.1 ByteToMessageDecoder</h2><p>ByteToMessageDecoder 是解码器的基类，其继承关系如下所示。<br><img src="/../../images/Netty/Netty%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E8%AF%A6%E8%A7%A3-1.png"></p><p>由此可见，与编码器类似，都是一个特殊的 channel handle，因此其主要的逻辑是在其内部的 <code>channelRead()</code> 中，大致逻辑如下：</p><ol><li>解码之前，累加器进行累加操作，将数据放到一个 Bytebuf 中。</li><li>累加完毕后，调用 callDecode ()函数，对 Bytebuf 中的数据进行解码操作，对解码后的数据对象放入到 CodecOutputList 对象中。</li><li>将 CodecOutputList 对象中解码后的数据传输到 channel 中，在后续的 handle 中处理。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    <span class="hljs-keyword">if</span> (msg <span class="hljs-keyword">instanceof</span> ByteBuf) &#123;<br>        <span class="hljs-type">CodecOutputList</span> <span class="hljs-variable">out</span> <span class="hljs-operator">=</span> CodecOutputList.newInstance();<br>        <span class="hljs-keyword">try</span> &#123;<br>            first = cumulation == <span class="hljs-literal">null</span>;<br>            cumulation = cumulator.cumulate(ctx.alloc(),<br>                    first ? Unpooled.EMPTY_BUFFER : cumulation, (ByteBuf) msg);<br>            callDecode(ctx, cumulation, out); <span class="hljs-comment">//最终会调用子实现类的decode()进行解码操作</span><br>        &#125; <span class="hljs-keyword">catch</span> (DecoderException e) &#123;<br>            <span class="hljs-keyword">throw</span> e;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoderException</span>(e);<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-keyword">if</span> (cumulation != <span class="hljs-literal">null</span> &amp;&amp; !cumulation.isReadable()) &#123;<br>                    numReads = <span class="hljs-number">0</span>;<br>                    cumulation.release();<br>                    cumulation = <span class="hljs-literal">null</span>;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (++numReads &gt;= discardAfterReads) &#123;<br>                    <span class="hljs-comment">// We did enough reads already try to discard some bytes so we not risk to see a OOME.</span><br>                    <span class="hljs-comment">// See https://github.com/netty/netty/issues/4275</span><br>                    NumReads = <span class="hljs-number">0</span>;<br>                    DiscardSomeReadBytes ();<br>                &#125;<br><br>                <span class="hljs-type">Int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> out.Size ();<br>                FiredChannelRead |= out.InsertSinceRecycled ();<br>                FireChannelRead (ctx, out, size);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                Out.Recycle ();<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        Ctx.FireChannelRead (msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-2-累加器"><a href="#3-2-累加器" class="headerlink" title="3.2 累加器"></a>3.2 累加器</h2><p>由前文可知，TCP 协议接收到的数据是存在半包与粘包问题，因此在 Netty 中使用累加器处理半包与粘包问题。累加器的作用是数据缓冲器，从套接字读取到的数据会先放到累加器中，然后从 netty 的解码器从累加器中获取数，按一定的格式解析数据。</p><p>在 ByteToMessageDecoder 内部定义了一个 Cumulator 接口，内部有两个实现，分别是：</p><ol><li><strong>MERGE_CUMULATOR</strong>：默认的累加器，主要是做一般缓冲区的合并，直接将新的缓冲区拷贝到累加缓冲区中。先扩容空间，再追加数据。</li><li><strong>COMPOSITE_CUMULATOR</strong>：<ol><li>ByteBuf 通过将它们添加到 CompositeByteBuf 来累积，因此尽可能不复制内存。请注意，使用更复杂的索引实现，CompositeByteBuf 因此根据您的用例和解码器实现，这可能会更慢，然后只使用 MERGE_CUMULATOR。</li><li>不是真正的复制，而是提供一个逻辑的视图，</li></ol></li></ol><p>默认的是使用内存累计器，其主要逻辑是：</p><ol><li>检查累加器是否有效</li><li>检查是否需要对累加器的 ByteBuf 进行扩容。</li><li>将 ByteBuf in 的数据拷贝到 ByteBuf cumulation，然后释放掉 ByteBuf in</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">Public <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Cumulator</span> <span class="hljs-variable">MERGE_CUMULATOR</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Cumulator</span> () &#123;<br>    <span class="hljs-meta">@Override</span><br>    Public ByteBuf <span class="hljs-title function_">cumulate</span> <span class="hljs-params">(ByteBufAllocator alloc, ByteBuf cumulation, ByteBuf in)</span> &#123;<br>        If (! Cumulation.IsReadable () &amp;&amp; in.IsContiguous ()) &#123;<br>            <span class="hljs-comment">// If cumulation is empty and input buffer is contiguous, use it directly</span><br>            Cumulation.Release ();<br>            Return in;<br>        &#125;<br>        Try &#123;<br>            Final <span class="hljs-type">int</span> <span class="hljs-variable">required</span> <span class="hljs-operator">=</span> in.ReadableBytes ();<br>            If (required &gt; cumulation.MaxWritableBytes () ||<br>                (required &gt; cumulation.MaxFastWritableBytes () &amp;&amp; cumulation.RefCnt () &gt; <span class="hljs-number">1</span>) ||<br>                Cumulation.IsReadOnly ()) &#123;<br>                <span class="hljs-comment">// Expand cumulation (by replacing it) under the following conditions:</span><br>                <span class="hljs-comment">// - cumulation cannot be resized to accommodate the additional data</span><br>                <span class="hljs-comment">// - cumulation can be expanded with a reallocation operation to accommodate but the buffer is</span><br>                <span class="hljs-comment">//   assumed to be shared (e.g. refCnt () &gt; 1) and the reallocation may not be safe.</span><br>                Return <span class="hljs-title function_">expandCumulation</span> <span class="hljs-params">(alloc, cumulation, in)</span>;<br>            &#125;<br>            Cumulation.WriteBytes (in, in.ReaderIndex (), required);<br>            In.ReaderIndex (in.WriterIndex ());<br>            Return cumulation;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// We must release in in all cases as otherwise it may produce a leak if writeBytes (...) throw</span><br>            <span class="hljs-comment">// for whatever release (for example because of OutOfMemoryError)</span><br>            In.Release ();<br>        &#125;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="3-3-ReplayingDecoder"><a href="#3-3-ReplayingDecoder" class="headerlink" title="3.3 ReplayingDecoder"></a>3.3 ReplayingDecoder</h2><h3 id="3-3-1-介绍"><a href="#3-3-1-介绍" class="headerlink" title="3.3.1 介绍"></a>3.3.1 介绍</h3><p><code>ReplayingDecoder</code>也是一个抽象类，其父类是<code>ByteToMessageDecoder</code>， <code>ReplayingDecoder</code>是<code>ByteToMessageDecoder</code>的一个特殊的子类，其对<code>ByteToMessageDecoder</code>做了进一步的封装。两者最大的区别是，使用<code>ReplayingDecoder</code>时，只需要实现<code>decode ()</code>中的解码逻辑，不用判断累加器中是否有足够的 bytes 数据，直接去读取。如果数据不够的话（半包），<code>ReplayingDecoder</code>会抛出一个异常。</p><p>​<code>ReplayingDecoder</code>​通过一个专门的 ByteBuf 实现，当缓冲区中没有足够的数据时，会抛出一个某种类型的 Error。在下面的<code>IntegerHeaderFrameDecoder</code>​中，当调用 in.ReadInt ()时，只需要假设缓冲区有4个或更多的字节。如果，缓冲区中确实有4个字节，会返回你所期望的 integer header。否则，会抛出这个 Error。<code>ReplayingDecoder</code>​会捕获这个 Error，然后重置缓冲区的 readerindex 到缓冲区的开始位置，并且当更多的数据到达缓冲区时，会再次调用<code>decode()</code>​方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">IntegerHeaderFrameDecoder</span>  <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReplayingDecoder</span>&lt;Void&gt; &#123;<br>  Protected <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span> <span class="hljs-params">(ChannelHandlerContext ctx,</span><br><span class="hljs-params">                          ByteBuf buf, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>    Out.Add (buf.ReadBytes (buf.ReadInt ()));  <span class="hljs-comment">//只需要读，不需要判断数据是否够</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>[!CAUTION]</p><p>ReplayingDecoder 在使用上会比较方便，不用考虑缓冲器数据是否满足的问题。但是也存在一定的限制：</p><ul><li>buffer 的部分操作，如 readBytes (ByteBuffer dst)、retain ()、release ()等方法会直接抛出异常。</li><li>如果网络缓慢而且消息格式复杂，性能会变差。因为在这种情况，解码器会解码同一部分的信息。</li><li>解码一条信息，decode ()方法可能被多次调用，需要保证多次解码消息不会出问题。</li></ul></blockquote><h3 id="3-3-2-原理"><a href="#3-3-2-原理" class="headerlink" title="3.3.2 原理"></a>3.3.2 原理</h3><p>ReplayingDecoder 在实现上主要是重写了父类<code>ByteToMessageDecoder #callDecode ()</code>，在内部增加了一个 checkpoint 属性，记录解码操作的初始位置。在解码过程中，如果解码失败，抛出异常，则 ByteBuf 的索引位置会更新到解码前的 checkpoint 位置，等后续数据满足时，再进行解码操作（这个再进行解码操作的触发条件，可能是与 epoll 等触发条件有关）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">callDecode</span> <span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> &#123;<br>    Replayable.SetCumulation (in);<br>    Try &#123;<br>        While (in.IsReadable ()) &#123;<br>            <span class="hljs-type">Int</span> <span class="hljs-variable">oldReaderIndex</span> <span class="hljs-operator">=</span> checkpoint = in.ReaderIndex (); <span class="hljs-comment">//记录解码前原始的索引位置</span><br>            <span class="hljs-type">Int</span> <span class="hljs-variable">outSize</span> <span class="hljs-operator">=</span> out.Size ();<br><br>            If (outSize &gt; <span class="hljs-number">0</span>) &#123;<br>                FireChannelRead (ctx, out, outSize);<br>                Out.Clear ();<br><br>                <span class="hljs-comment">// Check if this handler was removed before continuing with decoding.</span><br>                <span class="hljs-comment">// If it was removed, it is not safe to continue to operate on the buffer.</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// See:</span><br>                <span class="hljs-comment">// - https://github.com/netty/netty/issues/4635</span><br>                If (ctx.IsRemoved ()) &#123;<br>                    Break;<br>                &#125;<br>                OutSize = <span class="hljs-number">0</span>;<br>            &#125;<br><br>            <span class="hljs-type">S</span> <span class="hljs-variable">oldState</span> <span class="hljs-operator">=</span> state;<br>            <span class="hljs-type">Int</span> <span class="hljs-variable">oldInputLength</span> <span class="hljs-operator">=</span> in.ReadableBytes ();<br>            Try &#123;<br>                DecodeRemovalReentryProtection (ctx, replayable, out); <span class="hljs-comment">//尝试解码</span><br><br>                <span class="hljs-comment">// Check if this handler was removed before continuing the loop.</span><br>                <span class="hljs-comment">// If it was removed, it is not safe to continue to operate on the buffer.</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// See https://github.com/netty/netty/issues/1664</span><br>                If (ctx.IsRemoved ()) &#123;<br>                    Break;<br>                &#125;<br><br>                If (outSize == out.Size ()) &#123;<br>                    If (oldInputLength == in.ReadableBytes () &amp;&amp; oldState == state) &#123;<br>                        Throw <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoderException</span> (<br>                                StringUtil.SimpleClassName (getClass ()) + <span class="hljs-string">&quot;.Decode () must consume the inbound &quot;</span> +<br>                                <span class="hljs-string">&quot;data or change its state if it did not decode anything.&quot;</span>);<br>                    &#125; <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-comment">// Previous data has been discarded or caused state transition.</span><br>                        <span class="hljs-comment">// Probably it is reading on.</span><br>                        Continue;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Signal replay) &#123;<br>                Replay.Expect (REPLAY);<br><br>                <span class="hljs-comment">// Check if this handler was removed before continuing the loop.</span><br>                <span class="hljs-comment">// If it was removed, it is not safe to continue to operate on the buffer.</span><br>                <span class="hljs-comment">//</span><br>                <span class="hljs-comment">// See https://github.com/netty/netty/issues/1664</span><br>                If (ctx.IsRemoved ()) &#123;<br>                    Break;<br>                &#125;<br><br>                <span class="hljs-comment">// Return to the checkpoint (or oldPosition) and retry.</span><br>                <span class="hljs-type">Int</span> <span class="hljs-variable">checkpoint</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>. Checkpoint; <span class="hljs-comment">//解码失败，则恢复索引</span><br>                If (checkpoint &gt;= <span class="hljs-number">0</span>) &#123;<br>                    In.ReaderIndex (checkpoint);<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">// Called by cleanup () - no need to maintain the readerIndex</span><br>                    <span class="hljs-comment">// anymore because the buffer has been released already.</span><br>                &#125;<br>                Break;<br>            &#125;<br><br>            If (oldReaderIndex == in.ReaderIndex () &amp;&amp; oldState == state) &#123;<br>                Throw <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoderException</span> (<br>                       StringUtil.SimpleClassName (getClass ()) + <span class="hljs-string">&quot;.Decode () method must consume the inbound data &quot;</span> +<br>                       <span class="hljs-string">&quot;or change its state if it decoded something.&quot;</span>);<br>            &#125;<br>            If (isSingleDecode ()) &#123;<br>                Break;<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">catch</span> (DecoderException e) &#123;<br>        Throw e;<br>    &#125; <span class="hljs-keyword">catch</span> (Exception cause) &#123;<br>        Throw <span class="hljs-keyword">new</span> <span class="hljs-title class_">DecoderException</span> (cause);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-3-优化"><a href="#3-3-3-优化" class="headerlink" title="3.3.3 优化"></a>3.3.3 优化</h3><p>在解码操作时，使用 ReplayingDecoder 可能会面临着重复解码的情况，因此在一定程度上，其性能会下降。因此为提高 ReplayingDecoder 性能，ReplayingDecoder 提供了 State 属性与 checkpoint ()函数，以提高性能。</p><p>在一次解码过程中（调用一次 decode 方法），如果出现异常，ReplayingDecoder 默认会重置到 decode 方法之前的位置。如果编解码协议较为复杂，每次都重置到初始位置，则比较影响性能。因此可以使用 ReplayingDecoder的State属性 ，将解码过程人工分为几个部分，在每完成一部分解码时，便手动调用一次 checkpoint ()函数进行手动保存解码位置，这样在发生异常时，不会回退到 decode 方法之前。</p><blockquote><p>比如，在某次解码前，Bytebuf 的索引位置在 a 点，如果不使用 checkpoint ()函数的情况下，在发生异常时，Bytebuf 的索引会重置到 a 点。如果在使用 checkpoint ()函数的情况下（如手动 checkpoint 到 b），在发生异常时，会重置到 b 点。这样能减少重复解码的次数。</p></blockquote><h2 id="3-4-自定义解码器"><a href="#3-4-自定义解码器" class="headerlink" title="3.4 自定义解码器"></a>3.4 自定义解码器</h2><h3 id="3-4-1-解码器中的-Bytebuf-释放问题"><a href="#3-4-1-解码器中的-Bytebuf-释放问题" class="headerlink" title="3.4.1 解码器中的 Bytebuf 释放问题"></a>3.4.1 解码器中的 Bytebuf 释放问题</h3><p>众所周知，netty 中的 Bytebuf 需要手动释放，否则会出现内存溢出问题。因此需要明确自定义解码器输出对象类型，如果是输出普通的自定义 java 对象，则不用考虑释放问题。如果是输出的 Netty 中的 Bytebuf，则需要记得在后续 handle 中释放，否则内存溢出。解码器 <code>decode ()</code>中输入的 Bytebuf 不用考虑释放问题，会在<code>ByteToMessageDecoder</code>中进行释放。</p><h3 id="3-4-2-示例"><a href="#3-4-2-示例" class="headerlink" title="3.4.2 示例"></a>3.4.2 示例</h3><p>如下所示，使用检查点机制增强性能，使用定长的协议处理半包与粘包问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs java">Package codec;<br><br>Import io. Netty. Buffer. ByteBuf;<br>Import io. Netty. Channel. ChannelHandlerContext;<br>Import io. Netty. Handler. Codec. ReplayingDecoder;<br>Import org. Slf4j. Logger;<br>Import org. Slf4j. LoggerFactory;<br>Import serialize. Command;<br>Import serialize. CommandContext;<br>Import serialize. CommandHeader;<br>Import serialize. CommandType;<br><br>Import java. Util. List;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * netty decoder</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">NettyDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ReplayingDecoder</span>&lt;NettyDecoder.State&gt; &#123;<br>    Private <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">Logger</span> <span class="hljs-variable">logger</span> <span class="hljs-operator">=</span> LoggerFactory.GetLogger (NettyDecoder. Class);<br><br>    Public <span class="hljs-title function_">NettyDecoder</span> <span class="hljs-params">()</span> &#123;<br>        Super (State. MAGIC);<br>    &#125;<br><br>    Private <span class="hljs-keyword">final</span> <span class="hljs-type">CommandHeader</span> <span class="hljs-variable">commandHeader</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">CommandHeader</span> ();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * decode</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx channel handler context</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> in byte buffer</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> out out content</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">decode</span> <span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        Switch (state ()) &#123;<br>            Case MAGIC:<br>                CheckMagic (in.ReadByte ());<br>                Checkpoint (State. VERSION);  <span class="hljs-comment">//手动 checkpoint</span><br>                <span class="hljs-comment">// fallthru</span><br>            Case VERSION:<br>                CheckVersion (in.ReadByte ());<br>                Checkpoint (State. COMMAND);<br>                <span class="hljs-comment">// fallthru</span><br>            Case COMMAND:<br>                CommandHeader.SetType (in.ReadByte ());<br>                Checkpoint (State. OPAQUE);<br>                <span class="hljs-comment">// fallthru</span><br>            Case OPAQUE:<br>                CommandHeader.SetOpaque (in.ReadLong ());<br>                Checkpoint (State. CONTEXT_LENGTH);<br>                <span class="hljs-comment">// fallthru</span><br>            Case CONTEXT_LENGTH:<br>                CommandHeader.SetContextLength (in.ReadInt ());<br>                Checkpoint (State. CONTEXT);<br>                <span class="hljs-comment">// fallthru</span><br>            Case CONTEXT:<br>                Byte[] context = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[commandHeader.GetContextLength ()];<br>                In.ReadBytes (context);<br>                CommandHeader.SetContext (context);<br>                Checkpoint (State. BODY_LENGTH);<br>                <span class="hljs-comment">// fallthru</span><br>            Case BODY_LENGTH:<br>                CommandHeader.SetBodyLength (in.ReadInt ());<br>                Checkpoint (State. BODY);<br>                <span class="hljs-comment">// fallthru</span><br>            Case BODY:<br>                Byte[] body = <span class="hljs-keyword">new</span> <span class="hljs-title class_">byte</span>[commandHeader.GetBodyLength ()];<br>                In.ReadBytes (body);<br>                <span class="hljs-comment">//</span><br>                <span class="hljs-type">Command</span> <span class="hljs-variable">packet</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Command</span> ();<br>                Packet.SetType (commandType (commandHeader.GetType ()));<br>                Packet.SetOpaque (commandHeader.GetOpaque ());<br>                Packet.SetContext (CommandContext.ValueOf (commandHeader.GetContext ()));<br>                Packet.SetBody (body);<br>                Out.Add (packet);<br>                <span class="hljs-comment">// 将检查点恢复初始位置</span><br>                Checkpoint (State. MAGIC);<br>                Break;<br>            Default:<br>                Logger.Warn (<span class="hljs-string">&quot;unknown decoder state &#123;&#125;&quot;</span>, state ());<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * get command type</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> type type</span><br><span class="hljs-comment">     */</span><br>    Private CommandType <span class="hljs-title function_">commandType</span> <span class="hljs-params">(<span class="hljs-type">byte</span> type)</span> &#123;<br>        For (CommandType ct : CommandType.Values ()) &#123;<br>            If (ct.Ordinal () == type) &#123;<br>                Return ct;<br>            &#125;<br>        &#125;<br>        Return <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * check magic</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> magic magic</span><br><span class="hljs-comment">     */</span><br>    Private <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkMagic</span> <span class="hljs-params">(<span class="hljs-type">byte</span> magic)</span> &#123;<br>        If (magic != Command. MAGIC) &#123;<br>            Throw <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span> (<span class="hljs-string">&quot;illegal packet [magic]&quot;</span> + magic);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * check version</span><br><span class="hljs-comment">     */</span><br>    Private <span class="hljs-keyword">void</span> <span class="hljs-title function_">checkVersion</span> <span class="hljs-params">(<span class="hljs-type">byte</span> version)</span> &#123;<br>        If (version != Command. VERSION) &#123;<br>            Throw <span class="hljs-keyword">new</span> <span class="hljs-title class_">IllegalArgumentException</span> (<span class="hljs-string">&quot;illegal protocol [version]&quot;</span> + version);<br>        &#125;<br>    &#125;<br><br>    Enum State &#123;<br>        MAGIC,<br>        VERSION,<br>        COMMAND,<br>        OPAQUE,<br>        CONTEXT_LENGTH,<br>        CONTEXT,<br>        BODY_LENGTH,<br>        BODY;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="4-二次编解码"><a href="#4-二次编解码" class="headerlink" title="4 二次编解码"></a>4 二次编解码</h1><p>在上文的编解码示例中，使用的是一次编解码方案，即使用一个编解码器对数据进行处理。在部分场景下，有时候还需要使用二次编解码器。相比于一次编解码器，二次编解码的解耦性更好。</p><ol><li>一次解码：io. Netty. Buffer. ByteBuf（原始数据流）→＞io. Netty. Buffer. ByteBuf（用户数据），主要处理 tcp 粘包半包问题。</li><li>二次解码：io. Netty. Buffer. ByteBuf（用户数据）→＞Java Object。主要处理二进制与 java 对象之间的转换关系。</li></ol><p>通过二次编解码操作，解耦性更好，在转换协议时，如 json 协议转为 protobuf 协议，更方便，只需要改二次解码的部分代码实现即可。主要的二次编解码方式有：Java 序列号、XML、JSON、Protobuf、MessagePack，在考虑编解码方式时，需要有以下几点：</p><ol><li>编码后的占用空间大小</li><li>编解码速度</li><li>可读性</li><li>多语言支持<br>在使用二次编解码时（如解码），可以针对 MessageToMessageDecoder 与 ByteToMessageDecoder 自定义实现，</li></ol><ul><li>ByteToMessageDecoder 主要是将二进制转换成 msg 消息，用于一次解码。输出的内容一般是字节数组。</li><li>MessageToMessageDecoder 主要是将一次解码中输出的二进制数组转换成 pojo 对象。</li></ul>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.4-ByteBuf</title>
    <link href="/2024/06/01/Netty/1.4-ByteBuf/"/>
    <url>/2024/06/01/Netty/1.4-ByteBuf/</url>
    
    <content type="html"><![CDATA[<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><p>网络数据的基本单位总是字节，java NIO提供ByteBuffer作为字节的容器，但是ByteBuffer使用起来过于复杂和繁琐。ByteBuf是netty的Server与Client之间通信的数据传输载体(Netty的数据容器)，它提供了一个byte数组(byte[])的抽象视图，既解决了JDK API的局限性，又为网络应用程序的开发者提供了更好的API</p><h2 id="1-1-ByteBuffer缺点"><a href="#1-1-ByteBuffer缺点" class="headerlink" title="1.1 ByteBuffer缺点"></a>1.1 ByteBuffer缺点</h2><ol><li>ByteBuffer长度固定，一旦分配完成，它的容量不能动态扩展和收缩，当需要编码的POJO对象大于ByteBuffer的容量时，会发生索引越界异常；</li><li>ByteBuffer只有一个标识位置的指针position，读写的时候需要手工调用flip()和rewind()等，使用者必须小心谨慎地处理这些API，否则很容易导致程序处理失败；</li><li>ByteBuffer的API功能有限，一些高级和实用的特性它不支持，需要使用者自己编程实现。</li></ol><h2 id="1-2-ByteBuf优点"><a href="#1-2-ByteBuf优点" class="headerlink" title="1.2 ByteBuf优点"></a>1.2 ByteBuf优点</h2><ol><li>容量可以按需增长</li><li>读写采用了不同的指针，读写模式可以随意切换，不需要调用 flip 方法；</li><li>支持方法的链式调用</li><li>支持引用计数</li><li>支持池化</li><li>可以被用户自定义的缓冲区类型扩展</li><li>通过内置的复合缓冲区类型实现透明的零拷贝</li></ol><h1 id="2-工作机制"><a href="#2-工作机制" class="headerlink" title="2 工作机制"></a>2 工作机制</h1><h2 id="2-1-工作机制介绍"><a href="#2-1-工作机制介绍" class="headerlink" title="2.1 工作机制介绍"></a>2.1 工作机制介绍</h2><p>​<img src="/../../images/Netty/ByteBuf.png">​</p><ol><li>ByteBuf工作机制：ByteBuf维护了两个不同的索引，一个用于读取，一个用于写入。<code>readerIndex</code>和<code>writerIndex</code>的初始值都是0，当从ByteBuf中读取数据时，它的<code>readerIndex</code>将会被递增(它不会超过writerIndex)，当向ByteBuf写入数据时，它的writerIndex会递增。</li><li>名称以<code>readXXX</code>或者<code>writeXXX</code>开头的ByteBuf方法，会推进对应的索引，而以<code>setXXX</code>或<code>getXXX</code>开头的操作不会。</li><li>在读取之后，0～readerIndex的就被视为discard的，调用<code>discardReadBytes()</code>，可以释放这部分空间，它的作用类似ByteBuffer的<code>compact()</code>方法。</li><li>readerIndex和writerIndex之间的数据是可读取的，等价于ByteBuffer的position和limit之间的数据。writerIndex和capacity之间的空间是可写的，等价于ByteBuffer的limit和capacity之间的可用空间。</li></ol><h2 id="2-2-索引变化流程"><a href="#2-2-索引变化流程" class="headerlink" title="2.2 索引变化流程"></a>2.2 索引变化流程</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 初始化分配</span><br>    +-------------------------------+<br>    |       writable bytes          |<br>    +-------------------------------+<br>    |                               |<br>    <span class="hljs-number">0</span>=readerIndex=writerIndex       capacity<br><br> <span class="hljs-comment">// 写入N个字节</span><br>    +------------------+-------------------+<br>    |  readable bytes  |    writable bytes |<br>    +------------------+-------------------+<br>    |                  |                   |<br>    <span class="hljs-number">0</span>=readerIndex      N=writerIndex       capacity<br><br> <span class="hljs-comment">// 读取M（＜N）个字节之后</span><br>    +-------------------+------------------+------------------+<br>    | discardable bytes |  readable bytes  |  writable bytes  |<br>    +-------------------+------------------+------------------+<br>    |                   |                  |                  |<br>    <span class="hljs-number">0</span>               M=readerIndex    N=writerIndex       capacity<br><br><span class="hljs-comment">// 调用discardReadBytes操作之后</span><br>    +------------------+----------------------+<br>    |  readable bytes  |    writable bytes    |<br>    +------------------+----------------------+<br>    |                  |                      |<br>    <span class="hljs-number">0</span>=readerIndex   N-M=writerIndex         capacity<br><br><span class="hljs-comment">// 调用clear操作之后</span><br>    +-------------------------------+<br>    |       writable bytes          |<br>    +-------------------------------+<br>    |                               |<br>    <span class="hljs-number">0</span>=readerIndex=writerIndex       capacity<br></code></pre></td></tr></table></figure><h2 id="2-3-引用计数"><a href="#2-3-引用计数" class="headerlink" title="2.3 引用计数"></a>2.3 引用计数</h2><p>ByteBuf 是基于引用计数设计的，它实现了 ReferenceCounted 接口，ByteBuf 的生命周期是由引用计数所管理。只要引用计数大于 0，表示 ByteBuf 还在被使用；当 ByteBuf 不再被其他对象所引用时，引用计数为 0，那么代表该对象可以被释放。</p><p>当新创建一个 ByteBuf 对象时，它的初始引用计数为 1，当 ByteBuf 调用 release() 后，引用计数减 1，所以不要误以为调用了 release() 就会保证 ByteBuf 对象一定会被回收。你可以结合以下的代码示例做验证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ctx.alloc().directbuffer();<br><span class="hljs-keyword">assert</span> buffer.refCnt() == <span class="hljs-number">1</span>;<br>buffer.release();<br><span class="hljs-keyword">assert</span> buffer.refCnt() == <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>引用计数对于 Netty 设计缓存池化有非常大的帮助，当引用计数为 0，该 ByteBuf 可以被放入到对象池中，避免每次使用 ByteBuf 都重复创建，对于实现高性能的内存管理有着很大的意义。</p><p>此外 Netty 可以利用引用计数的特点实现内存泄漏检测工具。JVM 并不知道 Netty 的引用计数是如何实现的，当 ByteBuf 对象不可达时，一样会被 GC 回收掉，但是如果此时 ByteBuf 的引用计数不为 0，那么该对象就不会释放或者被放入对象池，从而发生了内存泄漏。Netty 会对分配的 ByteBuf 进行抽样分析，检测 ByteBuf 是否已经不可达且引用计数大于 0，判定内存泄漏的位置并输出到日志中，你需要关注日志中 LEAK 关键字。</p><h1 id="3-ByteBuf分类"><a href="#3-ByteBuf分类" class="headerlink" title="3 ByteBuf分类"></a>3 ByteBuf分类</h1><p><img src="/../../images/Netty/ByteBuf-1.png">​<br>从分配位置来看，可将ByteBuf分为两类：</p><ol><li>堆内存（HeapByteBuf）字节缓冲区：特点是内存的分配和回收速度快，可以被JVM自动回收；缺点就是如果进行Socket的I&#x2F;O读写，需要额外做一次内存复制，将堆内存对应的缓冲区复制到堆外，性能会有一定程度的下降。</li><li>直接内存(DirectByteBuf)字节缓冲区：非堆内存，它在堆外进行内存分配，相比于堆内存，它的分配和回收速度会慢一些，但是将它写入或者从Socket Channel中读取时，由于少了一次内存复制，速度比堆内存快。</li></ol><p>从内存回收角度看，ByteBuf也分为两类：</p><ol><li>基于对象池的ByteBuf：将ByteBuf进行池化重用，降低gc频率。</li><li>普通的ByteBuf：普通的ByteBuf，使用后需要回收内存。</li></ol><p>综上，根据不同的组合形式，ByteBuf共有四类：</p><ol><li>池化堆内ByteBuf</li><li>池化非堆ByteBuf</li><li>非池化堆内ByteBuf</li><li>非池化非堆ByteBuf</li></ol><p>此外，还有<strong>Unsafe&#x2F;非 Unsafe</strong>不同的操作方式，其中Unsafe 表示每次调用 JDK 的 Unsafe 对象操作物理内存，依赖 offset + index 的方式操作数据。非 Unsafe 则不需要依赖 JDK 的 Unsafe 对象，直接通过数组下标的方式操作数据。</p><h1 id="4-ByteBuf的默认类型"><a href="#4-ByteBuf的默认类型" class="headerlink" title="4 ByteBuf的默认类型"></a>4 ByteBuf的默认类型</h1><p>从上可知，在ByteBuf分为四类。在使用时，如果不指定具体类型，则使用<code>ByteBufAllocator.DEFAULT</code>进行分配ByteBuf。在<code>ByteBufAllocator.DEFAULT</code>初始化过程如下文代码所示，从代码中可知：</p><ol><li>在初始化时，如果指定了<code>io.netty.allocator.type</code>参数，则使用对应的参数值。</li><li>如果未指定上述参数，则根据netty运行平台决定，如果运行在非安卓平台则以池化ByteBuf作为默认的ByteBuf类型。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> &#123;<br><span class="hljs-type">String</span> <span class="hljs-variable">allocType</span> <span class="hljs-operator">=</span> SystemPropertyUtil.get(<br><span class="hljs-string">&quot;io.netty.allocator.type&quot;</span>, PlatformDependent.isAndroid() ? <span class="hljs-string">&quot;unpooled&quot;</span> : <span class="hljs-string">&quot;pooled&quot;</span>);<br>allocType = allocType.toLowerCase(Locale.US).trim();<br><br>ByteBufAllocator alloc;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;unpooled&quot;</span>.equals(allocType)) &#123;<br>alloc = UnpooledByteBufAllocator.DEFAULT;<br>logger.debug(<span class="hljs-string">&quot;-Dio.netty.allocator.type: &#123;&#125;&quot;</span>, allocType);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;pooled&quot;</span>.equals(allocType)) &#123;<br>alloc = PooledByteBufAllocator.DEFAULT;<br>logger.debug(<span class="hljs-string">&quot;-Dio.netty.allocator.type: &#123;&#125;&quot;</span>, allocType);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>alloc = PooledByteBufAllocator.DEFAULT;<br>logger.debug(<span class="hljs-string">&quot;-Dio.netty.allocator.type: pooled (unknown: &#123;&#125;)&quot;</span>, allocType);<br>&#125;<br><br>DEFAULT_ALLOCATOR = alloc;<br><br>THREAD_LOCAL_BUFFER_SIZE = SystemPropertyUtil.getInt(<span class="hljs-string">&quot;io.netty.threadLocalDirectBufferSize&quot;</span>, <span class="hljs-number">0</span>);<br>logger.debug(<span class="hljs-string">&quot;-Dio.netty.threadLocalDirectBufferSize: &#123;&#125;&quot;</span>, THREAD_LOCAL_BUFFER_SIZE);<br><br>MAX_CHAR_BUFFER_SIZE = SystemPropertyUtil.getInt(<span class="hljs-string">&quot;io.netty.maxThreadLocalCharBufferSize&quot;</span>, <span class="hljs-number">16</span> * <span class="hljs-number">1024</span>);<br>logger.debug(<span class="hljs-string">&quot;-Dio.netty.maxThreadLocalCharBufferSize: &#123;&#125;&quot;</span>, MAX_CHAR_BUFFER_SIZE);<br>&#125;<br></code></pre></td></tr></table></figure><p>从上述代码中可知，<code>PooledByteBufAllocator.DEFAULT</code>为默认的alloc，其创建细节如下，由<code>PlatformDependent.directBufferPreferred()</code>决定是否使用堆外内存还是堆内内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-type">PooledByteBufAllocator</span> <span class="hljs-variable">DEFAULT</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">PooledByteBufAllocator</span>(PlatformDependent.directBufferPreferred());<br></code></pre></td></tr></table></figure><p>进一步跟踪<code>PlatformDependent.directBufferPreferred()</code>代码可知，当有回收堆外内存工具（jdk7+）且未明确指定使用堆内内存时，默认使用堆外内存。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// We should always prefer direct buffers by default if we can use a Cleaner to release direct buffers.</span><br>DIRECT_BUFFER_PREFERRED = CLEANER != NOOP<br>    &amp;&amp; !SystemPropertyUtil.getBoolean(<span class="hljs-string">&quot;io.netty.noPreferDirect&quot;</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>    logger.debug(<span class="hljs-string">&quot;-Dio.netty.noPreferDirect: &#123;&#125;&quot;</span>, !DIRECT_BUFFER_PREFERRED);<br>&#125;<br></code></pre></td></tr></table></figure><p>综上，默认情况下，netty默认的Bytebuf为堆外池化Bytebuf：</p><ul><li>通过池化Bytebuf可减少内存回收的次数，提高效率。</li><li>通过使用堆外内存，降低字节在内存中复制的次数，提高性能。</li></ul><p>‍</p><h1 id="5-ByteBuf的释放"><a href="#5-ByteBuf的释放" class="headerlink" title="5 ByteBuf的释放"></a>5 ByteBuf的释放</h1><p>在Netty里，因为Handler链的存在，ByteBuf经常要传递到下一个Hanlder去而不复还，所以规则变成了谁是最后使用者，谁负责释放。另外，更要注意的是各种异常情况，ByteBuf没有成功传递到下一个Hanlder，还在自己地界里的话，一定要进行释放。根据<strong>谁最后使用谁负责释放</strong>原则，每个Handler对消息可能有三种场景</p><ul><li>对原消息不做处理，调用<code>ctx.fireChannelRead(msg)</code>把原消息往下传，那不用做什么释放。</li><li>将原消息转化为新的消息并调用<code>ctx.fireChannelRead(newMsg)</code>往下传，那必须把原消息release掉。</li><li>如果已经不再调用<code>ctx.fireChannelRead(msg)</code>传递任何消息，那更要把原消息release掉。</li></ul><h2 id="5-1-场景一"><a href="#5-1-场景一" class="headerlink" title="5.1 场景一"></a>5.1 场景一</h2><p>对原消息不做处理是指相关操作不影响原始的bytebuf，如只拷贝出字节等，这样的话，只需要对消息往后传输。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.buffer.ByteBufUtil.getBytes(buf)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        <span class="hljs-comment">//拷贝操作</span><br>        <span class="hljs-type">byte</span>[] bytes = ByteBufUtil.getBytes(buf);<br>        <span class="hljs-type">String</span> <span class="hljs-variable">value</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(bytes, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;connect&quot;</span>.equals(value)) &#123;<br>            doSomething();<br>            ReferenceCountUtil.release(msg)<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            ctx.fireChannelRead(msg);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="5-2-场景二"><a href="#5-2-场景二" class="headerlink" title="5.2 场景二"></a>5.2 场景二</h2><p>将原消息转化为新的消息，并传递新消息，一般是指我们使用了原消息，然后传递新的消息给下一个处理器，那么不会再有任何地方会继续使用原来的消息，那么需要释放原消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> io.netty.buffer.ByteBufUtil.getBytes(buf)<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">ConnectHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">ChannelInboundHandlerAdapter</span><br>  <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception &#123;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;<br>        <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">newBuf</span> <span class="hljs-operator">=</span> buf .alloc().directBuffer(buf .readableBytes() + <span class="hljs-number">1</span>);<br>            newBuf .writeBytes(input);<br>            newBuf .writeByte(<span class="hljs-number">42</span>);    <br>            <span class="hljs-comment">//释放原消息  </span><br>            ReferenceCountUtil.release(buf )<br>            <span class="hljs-comment">//传递新的消息至下一个处理器</span><br>            ctx.fireChannelRead(newBuf );<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><h2 id="5-3-场景三"><a href="#5-3-场景三" class="headerlink" title="5.3 场景三"></a>5.3 场景三</h2><p>不再传递任何消息，这个场景很简单，就是流程到此结束，一切都over了，那么就关闭原消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> &#123;  <br>    <span class="hljs-type">ByteBuf</span> <span class="hljs-variable">buf</span> <span class="hljs-operator">=</span> (ByteBuf) msg;  <br>    <span class="hljs-keyword">try</span> &#123;  <br>        ...  <br>    &#125; <span class="hljs-keyword">finally</span> &#123;  <br>        buf.release();  <br>    &#125;  <br>&#125;  <br></code></pre></td></tr></table></figure><blockquote><p>还有一些特殊的使用方式，如在ds中，bytebuf并未传输到自定义handle中，而是在解码器中就将bytebuf解析成java obj，并且解码器使用的是ReplayingDecoder解码器，所以就不用手动的释放资源了。</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.1-Java网络编程</title>
    <link href="/2024/06/01/Netty/1.1-Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2024/06/01/Netty/1.1-Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-Java网络编程"><a href="#1-Java网络编程" class="headerlink" title="1 Java网络编程"></a>1 Java网络编程</h1><h1 id="2-网络分层模型"><a href="#2-网络分层模型" class="headerlink" title="2 网络分层模型"></a>2 网络分层模型</h1><h2 id="2-1-OSI-模型"><a href="#2-1-OSI-模型" class="headerlink" title="2.1 OSI 模型"></a>2.1 OSI 模型</h2><p>OSI 模型把网络通信的工作分为 7 层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层。​​</p><h2 id="2-2-TCP-IP-模型"><a href="#2-2-TCP-IP-模型" class="headerlink" title="2.2 TCP&#x2F;IP 模型"></a>2.2 TCP&#x2F;IP 模型</h2><p>OSI 参考模型过于庞大，因此后续提出了 TCP&#x2F;IP 协议栈参考模型，简化了 OSI 参考模型。TCP&#x2F;IP 参考模型采用 4 层的层级结构，每一层都呼叫它的下一层所提供的协议来完成自己的需求，这 4 个层次分别是：<strong>网络接口层、网络层（IP 层）、传输层（TCP 层）、应用层</strong>。</p><p>​<img src="/../../images/Netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B.png">​</p><ul><li>应用层：负责提供各种网络服务，如 Springboot 服务等。</li><li>TCP 层：使用 TCP 协议，保证消息可靠传输。TCP 层涉及两个协议，TCP 和 UDP：<ul><li>TCP 协议提供面向连接的服务，提供按字节流的有序、可靠传输，可以实现连接管理、差错控制、流量控制、拥塞控制等</li><li>UDP 协议提供无连接的服务，用于不需要或无法实现面向连接的网络应用中。</li></ul></li><li>IP 层：IP 层可以进行网络连接的建立和终止以及 IP 地址的寻找等功能。该层负责提供基本的数据封包传送功能，让每一块数据包都能够到达目的主机。</li><li>网络接口层：网络接口层兼并了物理层和数据链路层所以，网络接口层既是传输数据的物理媒介，也可以为网络层提供一条准确无误的线路。该层负责接收 IP 数据报并进行传输，从网络上接收物理帧，抽取 IP 数据报转交给下一层。</li></ul><h1 id="3-网络协议"><a href="#3-网络协议" class="headerlink" title="3 网络协议"></a>3 网络协议</h1><h2 id="3-1-TCP-协议"><a href="#3-1-TCP-协议" class="headerlink" title="3.1 TCP 协议"></a>3.1 TCP 协议</h2><p>TCP（传输控制协议）是面向连接的传输层协议，位于 IP 层之上，提供可靠的、像管道一样的连接（IP 层协议不能提供这种能力，而是不可靠的数据交换）</p><h3 id="3-1-1-TCP-报文格式"><a href="#3-1-1-TCP-报文格式" class="headerlink" title="3.1.1 TCP 报文格式"></a>3.1.1 TCP 报文格式</h3><p><img src="/../../images/Netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-1.png"></p><ol><li><p>源端口号以及目的端口号：各占 2 个字节，端口是传输层和应用层的服务接口，用于寻找发送端和接收端的进程，一般来讲，通过端口号和 IP 地址，可以唯一确定一个 TCP 连接，在网络编程中，通常被称为一个 socket 接口。</p></li><li><p>序号：Seq 序号，占 4 个字节、32 位。用来标识从 TCP 发送端向 TCP 接收端发送的数据字节流。发起方发送数据时对此进行标记。</p></li><li><p>确认序号：Ack 序号，占 4 个字节、32 位。包含发送确认的一端所期望收到的下一个序号。只有 ACK 标记位为 1 时，确认序号字段才有效，因此，确认序号应该是上次已经成功收到数据字节序号加 1，即 <code>Ack=Seq + 1</code>​。</p></li><li><p>数据偏移：占 4 个字节，用于指出 TCP 首部长度，若不存在选项，则这个值为 20 字节，数据偏移的最大值为 60 字节。</p></li><li><p>保留字段：占 6 位，暂时可忽略，值全为 0。</p></li><li><p>标志位：6 个</p><ul><li>URG (紧急)：为 1 时表明紧急指针字段有效</li><li>ACK (确认)：为 1 时表明确认号字段有效</li><li>PSH (推送)：为 1 时接收方应尽快将这个报文段交给应用层</li><li>RST (复位)：为 1 时表明 TCP 连接出现故障必须重建连接</li><li>SYN (同步)：在连接建立时用来同步序号</li><li>FIN (终止)：为 1 时表明发送端数据发送完毕要求释放连接</li></ul></li><li><p>接收窗口：占 2 个字节，用于流量控制和拥塞控制，表示当前接收缓冲区的大小。在计算机网络中，通常是用接收方的接收能力的大小来控制发送方的数据发送量。TCP 连接的一端根据缓冲区大小确定自己的接收窗口值，告诉对方，使对方可以确定发送数据的字节数。</p></li><li><p>校验和：占 2 个字节，范围包括首部和数据两部分。</p></li><li><p>选项是可选的，默认情况是不选。</p></li></ol><h3 id="3-1-2-三次握手"><a href="#3-1-2-三次握手" class="headerlink" title="3.1.2 三次握手"></a>3.1.2 三次握手</h3><p><img src="/../../images/Netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-2.png"></p><p>三次握手示意图如上：</p><ol><li><strong>第一次握手</strong>（客户端发送请求）：客户机发送连接请求报文段到服务器，并进入 SYN_SENT 状态，等待服务器确认。发送连接请求报文段内容：SYN&#x3D;1，seq&#x3D;x；SYN&#x3D;1 意思是一个 TCP 的 SYN 标志位置为 1 的包，指明客户端打算连接的服务器的端口；seq&#x3D;x 表示客户端初始序号 x，保存在包头的序列号（Sequence Number）字段里。</li><li><strong>第二次握手</strong>（服务端回传确认）：服务器收到客户端连接请求报文，如果同意建立连接，向客户机发回确认报文段（ACK）应答，并为该 TCP 连接分配 TCP 缓存和变量。服务器发回确认报文段内容：SYN&#x3D;1，ACK&#x3D;1，seq&#x3D;y，ack&#x3D;x+1；SYN 标志位和 ACK 标志位均为 1，同时将确认序号（Acknowledgement Number）设置为客户的 ISN 加 1，即 x+1；seq&#x3D;y 为服务端初始序号 y。</li><li><strong>第三次握手</strong>（客户端回传确认）：客户机收到服务器的确认报文段后，向服务器给出确认报文段（ACK），并且也要给该连接分配缓存和变量。此包发送完毕，客户端和服务器进入 ESTABLISHED（TCP 连接成功）状态，完成三次握手。客户端发回确认报文段内容：ACK&#x3D;1，seq&#x3D;x+1，ack&#x3D;y+1；ACK&#x3D;1 为确认报文段；seq&#x3D;x+1 为客户端序号加 1；ack&#x3D;y+1, 为服务器发来的 ACK 的初始序号字段 +1。</li></ol><p>注意：握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。</p><h3 id="3-1-3-四次挥手"><a href="#3-1-3-四次挥手" class="headerlink" title="3.1.3 四次挥手"></a>3.1.3 四次挥手</h3><p>​<img src="/../../images/Netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-3.png">​</p><p>四次挥手示意图如上，由于 TCP 连接是全双工的，因此每个方向都必须单独进行关闭。这原则是当一方完成它的数据发送任务后就能发送一个 FIN 来终止这个方向的连接。收到一个 FIN 只意味着这一方向上没有数据流动，一个 TCP 连接在收到一个 FIN 后仍能发送数据。首先进行关闭的一方将执行主动关闭，而另一方执行被动关闭。</p><ol><li>TCP 客户端发送一个 FIN，用来关闭客户端到服务端的数据传送，客户端进入 FIN_WAIT_1 状态。发送报文段内容：FIN&#x3D;1，seq&#x3D;u；FIN&#x3D;1 表示请求切断连接；seq&#x3D;u 为客户端请求初始序号。</li><li>服务端收到这个 FIN，它发回一个 ACK 给客户端，确认序号为收到的序号加 1。和 SYN 一样，一个 FIN 将占用一个序号；服务端进入 CLOSE_WAIT 状态。发送报文段内容：ACK&#x3D;1，seq&#x3D;v，ack&#x3D;u+1；ACK&#x3D;1 为确认报文；seq&#x3D;v 为服务器确认初始序号；ack&#x3D;u+1 为客户端初始序号加 1。</li><li>服务器关闭客户端的连接后，发送一个 FIN 给客户端，服务端进入 LAST_ACK 状态。发送报文段内容：FIN&#x3D;1，ACK&#x3D;1，seq&#x3D;w，ack&#x3D;u+1；FIN&#x3D;1 为请求切断连接，ACK&#x3D;1 为确认报文，seq&#x3D;w 为服务端请求切断初始序号。</li><li>客户端收到 FIN 后，客户端进入 TIME_WAIT 状态，接着发回一个 ACK 报文给服务端确认，并将确认序号设置为收到序号加 1，服务端进入 CLOSED 状态，完成四次挥手。发送报文内容：ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1；ACK&#x3D;1 为确认报文，seq&#x3D;u+1 为客户端初始序号加 1，ack&#x3D;w+1 为服务器初始序号加 1。</li></ol><p>注意：为什么连接的时候是三次握手，关闭的时候却是四次挥手？<br>因为当服务端收到客户端的 SYN 连接请求报文后，可以直接发送 SYN+ACK 报文。其中 ACK 报文是用来应答的，SYN 报文是用来同步的。但是关闭连接时，当服务端收到 FIN 报文时，很可能并不会立即关闭 socket，所以只能先回复一个 ACK 报文，告诉客户端，“你发的 FIN 报文，我收到了”。只有等到服务端所有的报文都发送完了，我才能发送 FIN 报文，因此不能一起发送，故需要四步挥手。</p><h2 id="3-2-UDP-协议"><a href="#3-2-UDP-协议" class="headerlink" title="3.2 UDP 协议"></a>3.2 UDP 协议</h2><h3 id="3-2-1-介绍"><a href="#3-2-1-介绍" class="headerlink" title="3.2.1 介绍"></a>3.2.1 介绍</h3><p>UDP，用户数据报协议，它是 TCP&#x2F;IP 协议簇中无连接的运输层协议。</p><ol><li>UDP 是一个非连接的协议，传输数据之前源端和终端不建立连接，当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。在发送端，UDP 传送数据的速度仅仅是受应用程序生成数据的速度、计算机的能力和传输带宽的限制；在接收端，UDP 把每个消息段放在队列中，应用程序每次从队列中读一个消息段。</li><li>由于传输数据不建立连接，因此也就不需要维护连接状态，包括收发状态等，因此一台服务器可同时向多个客户端传输相同的消息。</li><li>UDP 信息包的标题很短，只有 8 个字节，相对于 TCP 的 20 个字节信息包的额外开销很小。</li><li>吞吐量不受拥挤控制算法的调节，只受应用软件生成数据的速率、传输带宽、源端和终端主机性能的限制。</li><li>UDP 使用尽量最大努力交付，即不保证可靠交付，因此主机不需要维持复杂的链接状态表。</li><li>UDP 是面向报文的。发送方的 UDP 对应用程序交下来的报文，在添加首部受就向下交付给 IP 层。既不拆分，也不合并，而是保留这些报文的边界，因此，应用程序需要选择合适的报文大小。</li></ol><h3 id="3-2-2-报文格式"><a href="#3-2-2-报文格式" class="headerlink" title="3.2.2 报文格式"></a>3.2.2 报文格式</h3><p><img src="/../../images/Netty/Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B-4.png"></p><p>UDP 协议由两部分组成：首部和数据。其中，首部仅有 8 个字节，包括源端口和目的端口、长度（UDP 用于数据报的长度）、校验和。</p><h3 id="3-2-3-TCP-与-UDP-的区别"><a href="#3-2-3-TCP-与-UDP-的区别" class="headerlink" title="3.2.3 TCP 与 UDP 的区别"></a>3.2.3 TCP 与 UDP 的区别</h3><ol><li>TCP 基于连接，UDP 是无连接的；</li><li>对系统资源的要求，TCP 较多，UDP 较少；</li><li>UDP 程序结构较简单；</li><li>TCP 是流模式，而 UDP 是数据报模式；</li><li>TCP 保证数据正确性，而 UDP 可能丢包；TCP 保证数据顺序，而 UDP 不保证；</li></ol><h1 id="4-Socket-编程"><a href="#4-Socket-编程" class="headerlink" title="4 Socket 编程"></a>4 Socket 编程</h1><h2 id="4-1-Socket-介绍"><a href="#4-1-Socket-介绍" class="headerlink" title="4.1 Socket 介绍"></a>4.1 Socket 介绍</h2><p>​Java 的网络编程主要涉及到的内容是 Socket 编程。Socket 就是两台主机之间逻辑连接的端点。Socket 是通信的基石，是支持 TCP&#x2F;IP 协议的网络通信的基本操作单元。它是网络通信过程中端点的抽象表示，包含进行网络通信必须的五种信息：<strong>连接使用的协议、本地主机的 IP 地址、本地进程的协议端口、远程主机的 IP 地址、远程进程的协议端口</strong>。</p><p>​应用层通过传输层进行数据通信时，TCP 会遇到同时为多个应用程序进程提供并发服务的问题。多个 TCP 连接或多个应用程序进程可能需要通过同一个 TCP 协议端口传输数据。为了区别不同的应用程序进程和连接，许多计算机操作系统为应用程序与 TCP&#x2F;IP 协议交互提供了套接字（Socket）接口。应用层可以和传输层通过 Socket 接口，区分来自不同应用程序进程或网络连接的通信，实现数据传输的并发服务。</p><blockquote><p>“TCP&#x2F;IP 只是一个协议栈，就像操作系统的运行机制一样，必须要具体实现，同时还要提供对外的操作接口。这个就像操作系统会提供标准的编程接口，比如 win32 编程接口一样，TCP&#x2F;IP 也要提供可供程序员做网络开发所用的接口，这就是 Socket 编程接口。”</p></blockquote><h2 id="4-2-Socket-编程案例"><a href="#4-2-Socket-编程案例" class="headerlink" title="4.2 Socket 编程案例"></a>4.2 Socket 编程案例</h2><p>下面是一个客户端和服务器端进行数据交互的简单例子，客户端输入正方形的边长，服务器端接收到后计算面积并返回给客户端。<br><strong>服务器端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketServer</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException &#123;<br>        <span class="hljs-comment">// 端口号</span><br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">7000</span>;<br>        <span class="hljs-comment">// 在端口上创建一个服务器套接字</span><br>        <span class="hljs-type">ServerSocket</span> <span class="hljs-variable">serverSocket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ServerSocket</span>(port);<br>        <span class="hljs-comment">// 监听来自客户端的连接</span><br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> serverSocket.accept();<br>        <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span>(socket.getInputStream()));<br>        <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span>(socket.getOutputStream()));<br>        <span class="hljs-keyword">do</span> &#123;<br>            <span class="hljs-type">double</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> dis.readDouble();<br>            System.out.println(<span class="hljs-string">&quot;服务器端收到的边长数据为：&quot;</span> + length);<br>            <span class="hljs-type">double</span> <span class="hljs-variable">result</span> <span class="hljs-operator">=</span> length * length;<br>            dos.writeDouble(result);<br>            dos.flush();<br>        &#125; <span class="hljs-keyword">while</span> (dis.readInt() != <span class="hljs-number">0</span>);<br>        socket.close();<br>        serverSocket.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">SocketClient</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> UnknownHostException, IOException &#123;<br>        <span class="hljs-type">int</span> <span class="hljs-variable">port</span> <span class="hljs-operator">=</span> <span class="hljs-number">7000</span>;<br>        <span class="hljs-type">String</span> <span class="hljs-variable">host</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;localhost&quot;</span>;<br>        <span class="hljs-type">Socket</span> <span class="hljs-variable">socket</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Socket</span>(host, port);<br>        <span class="hljs-type">DataInputStream</span> <span class="hljs-variable">dis</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataInputStream</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedInputStream</span> (socket.GetInputStream ()));<br>        <span class="hljs-type">DataOutputStream</span> <span class="hljs-variable">dos</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">DataOutputStream</span> (<span class="hljs-keyword">new</span> <span class="hljs-title class_">BufferedOutputStream</span> (socket.GetOutputStream ()));<br>        <span class="hljs-type">Scanner</span> <span class="hljs-variable">sc</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span> (System. In);<br>        <span class="hljs-type">Boolean</span> <span class="hljs-variable">flag</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;<br>        While (! Flag) &#123;<br>            System.Out.Println (<span class="hljs-string">&quot;请输入正方形的边长: &quot;</span>);<br>            <span class="hljs-type">Double</span> <span class="hljs-variable">length</span> <span class="hljs-operator">=</span> sc.NextDouble ();<br>            Dos.WriteDouble (length);<br>            Dos.Flush ();<br>            <span class="hljs-type">Double</span> <span class="hljs-variable">area</span> <span class="hljs-operator">=</span> dis.ReadDouble ();<br>            System.Out.Println (<span class="hljs-string">&quot;服务器返回的计算面积为: &quot;</span> + area);<br>            While (<span class="hljs-literal">true</span>) &#123;<br>                System.Out.Println (<span class="hljs-string">&quot;继续计算？(Y/N)&quot;</span>);<br>                <span class="hljs-type">String</span> <span class="hljs-variable">str</span> <span class="hljs-operator">=</span> sc.Next ();<br>                If (str.EqualsIgnoreCase (<span class="hljs-string">&quot;N&quot;</span>)) &#123;<br>                    Dos.WriteInt (<span class="hljs-number">0</span>);<br>                    Dos.Flush ();<br>                    Flag = <span class="hljs-literal">true</span>;<br>                    Break;<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (str.EqualsIgnoreCase (<span class="hljs-string">&quot;Y&quot;</span>)) &#123;<br>                    Dos.WriteInt (<span class="hljs-number">1</span>);<br>                    Dos.Flush ();<br>                    Break;<br>                &#125;<br>            &#125;<br>        &#125;<br>        Socket.Close ();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.3-Bytebuffer</title>
    <link href="/2024/06/01/Netty/1.3-Bytebuffer/"/>
    <url>/2024/06/01/Netty/1.3-Bytebuffer/</url>
    
    <content type="html"><![CDATA[<h1 id="1-ByteBuffer-介绍"><a href="#1-ByteBuffer-介绍" class="headerlink" title="1 ByteBuffer 介绍"></a>1 ByteBuffer 介绍</h1><p>在 NIO 中，最核心的三个组件就是：<code>Channel</code> 通道、<code>ByteBuffer</code> 读写缓冲区、<code>Selector</code> 多路复用器。其中 <code>ByteBuffer</code> 为 NIO 中的字节缓冲区，相对于 <code>BIO</code> 的 <code>Stream</code> 流只支持写入或者读取单向操作，<code>ByteBuffer</code> 是双向的，支持读和写。</p><h1 id="2-核心属性"><a href="#2-核心属性" class="headerlink" title="2 核心属性"></a>2 核心属性</h1><p>​<img src="/../../images/Netty/Bytebuffer.png">​<br>其属性如下：</p><ol><li>capacity：<code>ByteBuffer</code> 的容量，这个值在 <code>ByteBuffer</code> 初始化的时候就确定下来了。不论是在读还是在写模式下，这个值都不变。</li><li>position：表示当前操作的位置：<ol><li>在写模式下，该值表示当前写到了 <code>ByteBuffer</code> 的哪个位置，<code>ByteBuffer</code> 初始化时，这个值为 0，最大为 <code>capacity-1</code>。</li><li>在读模式下，首先会将 <code>position</code> 重置为 0，即从 <code>ByteBuffer</code> 的起始位置开始读取数据，该值表示已经读取数据的位置。</li></ol></li><li>limit：表示当前读或者写的限制下标：<ol><li>在写模式下，该值表示最大可写入的数据量，即 <code>ByteBuffer</code> 的最大容量，值为 <code>capacity</code>。</li><li>在读模式下，<code>limit</code> 将会被设置为读模式下的 <code>position</code> 值，即可读取的最大数据量。</li></ol></li><li>mark：为某个读取过的关键位置做标记，方便回退到该位置；</li></ol><h1 id="3-主要方法"><a href="#3-主要方法" class="headerlink" title="3 主要方法"></a>3 主要方法</h1><p>&#x3D;&#x3D;flip()&#x3D;&#x3D;</p><ul><li><p>将写模式切换为读模式</p></li><li><p>会触发的对核心属性的操作:</p><ul><li>将 <code>position</code> 设置为 <code>0</code>，即从 <code>ByteBuffer</code> 起始位置开始读。</li><li>将 <code>limit</code> 设置为写模式下 <code>position</code> 的值，即最大可读取的数据量大小。<br>&#x3D;&#x3D;mark()&#x3D;&#x3D;</li></ul></li><li><p>标记当前 <code>position</code> 位置</p></li></ul><p>&#x3D;&#x3D;reset()&#x3D;&#x3D;</p><ul><li>将 <code>position</code> 指向上一次 <code>mark()</code> 所指向的位置，可以从这个位置重复向下读取数据</li></ul><p>&#x3D;&#x3D;clear()&#x3D;&#x3D;</p><ul><li><p>在逻辑上清空 ByteBuffer 里的数据，实际上不清空数据</p></li><li><p>会触发的动作：</p><ul><li>将 <code>limit</code> 设置为 <code>capacity</code></li><li><code>position</code> 指向起始位置 <code>0</code></li><li>提示：实际上数据并未清理，只是下次是从 0 的位置开始写入数据，效果上像是数据清空了。</li><li>提示：如果 <code>ByteBuffer</code> 中的数据并未完全读完，调用这个方法将忽略那些未读取的数据。</li></ul></li></ul><p>&#x3D;&#x3D;compact()&#x3D;&#x3D;</p><ul><li>如果并未读取完 <code>ByteBuffer</code> 中的数据，调用 <code>compact()</code> 会将 <code>position~limit</code> 之间的数据拷贝到 <code>ByteBuffer</code> 的起始处，并且 <code>position</code> 为剩余数据量的大小，下次再往 <code>ByteBuffer</code> 中写入数据时，将在 <code>position</code> 位置继续往下写，不会覆盖历史数据。</li></ul><p>&#x3D;&#x3D;hasRemaining()&#x3D;&#x3D;</p><ul><li>判断缓冲区中是否还有未读数据</li></ul><h1 id="4-读写流程"><a href="#4-读写流程" class="headerlink" title="4 读写流程"></a>4 读写流程</h1><p>整个读写流程如下：</p><p>一开始</p><p><img src="/../../images/Netty/Bytebuffer-1.png"></p><p>写模式下，position 是写入位置，limit 等于容量，下图表示写入了 4 个字节后的状态</p><p><img src="/../../images/Netty/Bytebuffer-2.png"></p><p>flip 动作发生后，position 切换为读取位置，limit 切换为读取限制</p><p><img src="/../../images/Netty/Bytebuffer-3.png"></p><p>读取 4 个字节后，状态</p><p><img src="/../../images/Netty/Bytebuffer-4.png"></p><p>clear 动作发生后，状态</p><p><img src="/../../images/Netty/Bytebuffer-5.png"></p><p>compact 方法，是把未读完的部分向前压缩，然后切换至写模式</p><p><img src="/../../images/Netty/Bytebuffer-6.png"></p><h1 id="5-缺陷"><a href="#5-缺陷" class="headerlink" title="5 缺陷"></a>5 缺陷</h1><p>第一，ByteBuffer 分配的长度是固定的，无法动态扩缩容，所以很难控制需要分配多大的容量。如果分配太大容量，容易造成内存浪费；如果分配太小，存放太大的数据会抛出 BufferOverflowException 异常。在使用 ByteBuffer 时，为了避免容量不足问题，你必须每次在存放数据的时候对容量大小做校验，如果超出 ByteBuffer 最大容量，那么需要重新开辟一个更大容量的 ByteBuffer，将已有的数据迁移过去。整个过程相对烦琐，对开发者而言是非常不友好的。</p><p>第二，ByteBuffer 只能通过 position 获取当前可操作的位置，因为读写共用的 position 指针，所以需要频繁调用 flip、rewind 方法切换读写状态，开发者必须很小心处理 ByteBuffer 的数据读写，稍不留意就会出错。</p>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.5-Java堆外内存</title>
    <link href="/2024/06/01/Netty/1.5-Java%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98/"/>
    <url>/2024/06/01/Netty/1.5-Java%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h1 id="1-堆外内存介绍"><a href="#1-堆外内存介绍" class="headerlink" title="1 堆外内存介绍"></a>1 堆外内存介绍</h1><p>在 Java 中对象都是在堆内分配的，通常我们说的<strong>JVM 内存</strong>也就指的<strong>堆内内存</strong>，<strong>堆内内存</strong>完全被<strong>JVM 虚拟机</strong>所管理，JVM 有自己的垃圾回收算法，对于使用者来说不必关心对象的内存如何回收。</p><p><strong>堆外内存</strong>与堆内内存相对应，对于整个机器内存而言，除<strong>堆内内存以外部分即为堆外内存</strong>，如下图所示。堆外内存不受 JVM 虚拟机管理，直接由操作系统管理。</p><p>​<img src="/../../images/Netty/Java%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98.png">​</p><p>堆外内存和堆内内存各有利弊，这里我针对其中重要的几点进行说明。</p><ol><li>堆内内存由 JVM GC 自动回收内存，降低了 Java 用户的使用难度，但是 GC 是需要时间开销成本的，堆外内存由于不受 JVM 管理，所以在一定程度上可以降低 GC 对应用运行时带来的影响。</li><li>堆外内存需要手动释放，这一点跟 C&#x2F;C++ 很像，稍有不慎就会造成应用程序内存泄漏，当出现内存泄漏问题时排查起来会相对困难。</li><li>当进行网络 I&#x2F;O 操作、文件读写时，堆内内存都需要转换为堆外内存，然后再与底层设备进行交互，所以直接使用堆外内存可以减少一次内存拷贝。</li><li>堆外内存可以实现进程之间、JVM 多实例之间的数据共享。</li></ol><p>由此可知，如果要实现高效的 I&#x2F;O 操作、缓存常用的对象、降低 JVM GC 压力，堆外内存是一个非常不错的选择。</p><h1 id="2-堆外内存的分配"><a href="#2-堆外内存的分配" class="headerlink" title="2 堆外内存的分配"></a>2 堆外内存的分配</h1><p>Java 中堆外内存的分配方式有两种：<code>ByteBuffer#allocateDirect</code>和<code>Unsafe#allocateMemory</code>。</p><p>首先我们介绍下 Java NIO 包中的 ByteBuffer 类的分配方式，使用方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 分配 10M 堆外内存</span><br><span class="hljs-type">ByteBuffer</span> <span class="hljs-variable">buffer</span> <span class="hljs-operator">=</span> ByteBuffer.allocateDirect(<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>); <br></code></pre></td></tr></table></figure><p>跟进 <code>ByteBuffer.allocateDirect</code> 源码，发现其中直接调用的 DirectByteBuffer 构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">DirectByteBuffer(<span class="hljs-type">int</span> cap) &#123;<br>    <span class="hljs-built_in">super</span>(-<span class="hljs-number">1</span>, <span class="hljs-number">0</span>, cap, cap);<br>    <span class="hljs-type">boolean</span> <span class="hljs-variable">pa</span> <span class="hljs-operator">=</span> VM.isDirectMemoryPageAligned();<br>    <span class="hljs-type">int</span> <span class="hljs-variable">ps</span> <span class="hljs-operator">=</span> Bits.pageSize();<br>    <span class="hljs-type">long</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> Math.max(<span class="hljs-number">1L</span>, (<span class="hljs-type">long</span>)cap + (pa ? ps : <span class="hljs-number">0</span>));<br>    Bits.reserveMemory(size, cap);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">base</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">try</span> &#123;<br>        base = unsafe.allocateMemory(size);<br>    &#125; <span class="hljs-keyword">catch</span> (OutOfMemoryError x) &#123;<br>        Bits.unreserveMemory(size, cap);<br>        <span class="hljs-keyword">throw</span> x;<br>    &#125;<br>    unsafe.setMemory(base, size, (<span class="hljs-type">byte</span>) <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (pa &amp;&amp; (base % ps != <span class="hljs-number">0</span>)) &#123;<br>        address = base + ps - (base &amp; (ps - <span class="hljs-number">1</span>));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        address = base;<br>    &#125;<br>    cleaner = Cleaner.create(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span> <span class="hljs-title class_">Deallocator</span>(base, size, cap));<br>    att = <span class="hljs-literal">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如下图所示，描述了 DirectByteBuffer 的内存引用情况，方便你更好地理解上述源码的初始化过程。在堆内存放的 DirectByteBuffer 对象并不大，仅仅包含堆外内存的地址、大小等属性，同时还会创建对应的 Cleaner 对象，通过 ByteBuffer 分配的堆外内存不需要手动回收，它可以被 JVM 自动回收。当堆内的 DirectByteBuffer 对象被 GC 回收时，Cleaner 就会用于回收对应的堆外内存。</p><p>​<img src="/../../images/Netty/Java%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98-1.png">​</p><p>从 DirectByteBuffer 的构造函数中可以看出，真正分配堆外内存的逻辑还是通过 <code>unsafe.allocateMemory(size)</code>。Unsafe 是一个非常不安全的类，它用于执行内存访问、分配、修改等<strong>敏感操作</strong>，可以越过 JVM 限制的枷锁。Unsafe 最初并不是为开发者设计的，使用它时虽然可以获取对底层资源的控制权，但也失去了安全性的保证，所以使用 Unsafe 一定要慎重。Netty 中依赖了 Unsafe 工具类，是因为 Netty 需要与底层 Socket 进行交互，Unsafe 在提升 Netty 的性能方面起到了一定的帮助。</p><p>在 Java 中是不能直接使用 Unsafe 的，但是我们可以通过反射获取 Unsafe 实例，使用方式如下所示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-type">Unsafe</span> <span class="hljs-variable">unsafe</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>;<br><span class="hljs-keyword">static</span> &#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-type">Field</span> <span class="hljs-variable">getUnsafe</span> <span class="hljs-operator">=</span> Unsafe.class.getDeclaredField(<span class="hljs-string">&quot;theUnsafe&quot;</span>);<br>        getUnsafe.setAccessible(<span class="hljs-literal">true</span>);<br>        unsafe = (Unsafe) getUnsafe.get(<span class="hljs-literal">null</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (NoSuchFieldException | IllegalAccessException e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>获得 Unsafe 实例后，我们可以通过 allocateMemory 方法分配堆外内存，allocateMemory 方法返回的是内存地址，使用方法如下所示：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-comment">// 分配 10M 堆外内存</span><br><span class="hljs-built_in">long</span> address = <span class="hljs-keyword">unsafe</span>.allocateMemory(<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>);<br></code></pre></td></tr></table></figure><p>与 DirectByteBuffer 不同的是，Unsafe#allocateMemory 所分配的内存必须自己手动释放，否则会造成内存泄漏，这也是 Unsafe 不安全的体现。Unsafe 同样提供了内存释放的操作：</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">unsafe</span>.freeMemory(address);<br></code></pre></td></tr></table></figure><p>到目前为止，我们了解了堆外内存分配的两种方式，对于 Java 开发者而言，常用的是 ByteBuffer.allocateDirect 分配方式，我们平时常说的堆外内存泄漏都与该分配方式有关，接下来我们一起看看使用 ByteBuffer 分配的堆外内存如何被 JVM 回收，这对我们排查堆外内存泄漏问题有较大的帮助。</p><h1 id="3-堆外内存的回收"><a href="#3-堆外内存的回收" class="headerlink" title="3 堆外内存的回收"></a>3 堆外内存的回收</h1><p>某种场景下，因为 DirectByteBuffer 对象有可能长时间存在于堆内内存，所以它很可能晋升到 JVM 的老年代，所以这时候 DirectByteBuffer 对象的回收需要依赖 Old GC 或者 Full GC 才能触发清理。如果长时间没有 Old GC 或者 Full GC 执行，那么堆外内存即使不再使用，也会一直在占用内存不释放，很容易将机器的物理内存耗尽。</p><p>在上述场景下使用 DirectByteBuffer 时，我们可以通过 JVM 参数 <code>-XX:MaxDirectMemorySize</code> 指定堆外内存的上限大小，当堆外内存的大小超过该阈值时，就会触发一次 Full GC 进行清理回收，如果在 Full GC 之后还是无法满足堆外内存的分配，那么程序将会抛出 OOM 异常。</p><p>此外在 <code>ByteBuffer.allocateDirect</code> 分配的过程中，如果没有足够的空间分配堆外内存，在 Bits.reserveMemory 方法中也会主动调用 System.gc() 强制执行 Full GC，但是在生产环境一般都是设置了 -XX:+DisableExplicitGC，System.gc() 是不起作用的，所以依赖 System.gc() 并不是一个好办法。</p><p>通过前面堆外内存分配方式的介绍，我们知道 DirectByteBuffer 在初始化时会创建一个 Cleaner 对象，它会负责堆外内存的回收工作，那么 Cleaner 是如何与 GC 关联起来的呢？</p><p>Java 对象有四种引用方式：强引用 StrongReference、软引用 SoftReference、弱引用 WeakReference 和虚引用 PhantomReference。其中 PhantomReference 是最不常用的一种引用方式，Cleaner 就属于 PhantomReference 的子类，如以下源码所示，PhantomReference 不能被单独使用，需要与引用队列 ReferenceQueue 联合使用。</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">Cleaner</span> <span class="hljs-title">extends</span> <span class="hljs-title">java.lang.ref.PhantomReference</span>&lt;<span class="hljs-title">java.lang.Object</span>&gt; &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> final java.lang.<span class="hljs-keyword">ref</span>.ReferenceQueue&lt;java.lang.Object&gt; dummyQueue;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> sun.misc.Cleaner first;<br>    <span class="hljs-keyword">private</span> sun.misc.Cleaner next;<br>    <span class="hljs-keyword">private</span> sun.misc.Cleaner prev;<br>    <span class="hljs-keyword">private</span> final java.lang.Runnable thunk;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">clean</span>()</span> &#123;&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先我们看下，当初始化堆外内存时，内存中的对象引用情况如下图所示，first 是 Cleaner 类中的静态变量，Cleaner 对象在初始化时会加入 Cleaner 链表中。DirectByteBuffer 对象包含堆外内存的地址、大小以及 Cleaner 对象的引用，ReferenceQueue 用于保存需要回收的 Cleaner 对象。</p><p>​<img src="/../../images/Netty/Java%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98-2.png">​</p><p>当发生 GC 时，DirectByteBuffer 对象被回收，内存中的对象引用情况发生了如下变化：</p><p>​<img src="/../../images/Netty/Java%E5%A0%86%E5%A4%96%E5%86%85%E5%AD%98-3.png">​</p><p>此时 Cleaner 对象不再有任何引用关系，在下一次 GC 时，该 Cleaner 对象将被添加到 ReferenceQueue 中，并执行 clean() 方法。clean() 方法主要做两件事情：</p><ol><li>将 Cleaner 对象从 Cleaner 链表中移除；</li><li>调用 unsafe.freeMemory 方法清理堆外内存。</li></ol><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4 总结"></a>4 总结</h1><p>堆外内存是一把双刃剑，在网络 I&#x2F;O、文件读写、分布式缓存等领域使用堆外内存都更加简单、高效，此外使用堆外内存不受 JVM 约束，可以避免 JVM GC 的压力，降低对业务应用的影响。当然天下没有免费的午餐，堆外内存也不能滥用，使用堆外内存你就需要关注内存回收问题，虽然 JVM 在一定程度上帮助我们实现了堆外内存的自动回收，但我们仍然需要培养类似 C&#x2F;C++ 的分配&#x2F;回收的意识，出现内存泄漏问题能够知道如何分析和处理。</p>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>1.2-Netty IO模型</title>
    <link href="/2024/06/01/Netty/1.2-Netty%20IO%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/06/01/Netty/1.2-Netty%20IO%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="1-IO-模型分类"><a href="#1-IO-模型分类" class="headerlink" title="1 IO 模型分类"></a>1 IO 模型分类</h1><p>I&#x2F;O 请求可以分为两个阶段，分别为调用阶段和执行阶段。</p><ul><li>第一个阶段为<strong>I&#x2F;O 调用阶段</strong>，即用户进程向内核发起系统调用。</li><li>第二个阶段为<strong>I&#x2F;O 执行阶段</strong>。此时，内核等待 I&#x2F;O 请求处理完成返回。该阶段分为两个过程：首先等待数据就绪，并写入内核缓冲区；随后将内核缓冲区数据拷贝至用户态缓冲区。</li></ul><p>​<img src="/../../images/Netty/Netty%20IO%E6%A8%A1%E5%9E%8B.png">​</p><p>UNIX 系统下， IO 模型一共有 5 种：<strong>阻塞 I&#x2F;O</strong>、<strong>非阻塞 I&#x2F;O</strong>、<strong>I&#x2F;O 多路复用</strong>、<strong>信号驱动 I&#x2F;O</strong> 和<strong>异步 I&#x2F;O</strong>。这也是我们经常提到的 5 种 IO 模型。在 Java 中，目前常用的是阻塞 IO、NIO、IO 多路复用。</p><p>&#x3D;&#x3D;阻塞与非阻塞&#x3D;&#x3D;</p><p>阻塞与非阻塞的区别是在读写数据没完成前，是否返回。如：</p><ul><li>读数据时，数据未准备完成，阻塞式IO读操作会阻塞等待数据，而非阻塞式会直接返回。</li><li>写数据时，缓冲区满了，阻塞式IO写操作会阻塞，而非阻塞式会直接返回。</li></ul><p>&#x3D;&#x3D;同步与异步&#x3D;&#x3D;</p><p>同步与异步的区别是数据就绪后，谁来操作问题：</p><ul><li>同步是指数据就绪后，自己去读，将数据读取到用户缓冲区。</li><li>异步是指数据就绪后，系统会将数据放到对应的用户缓冲区，然后通知程序。</li></ul><h2 id="1-1-同步阻塞-IO（BIO）"><a href="#1-1-同步阻塞-IO（BIO）" class="headerlink" title="1.1 同步阻塞 IO（BIO）"></a>1.1 同步阻塞 IO（BIO）</h2><p>​<img src="/../../images/Netty/Netty%20IO%E6%A8%A1%E5%9E%8B-1.png">​</p><p>如上图所表现的那样，应用进程向内核发起 I&#x2F;O 请求，发起调用的线程一直等待内核返回结果。一次完整的 I&#x2F;O 请求称为BIO（Blocking IO，阻塞 I&#x2F;O），所以 BIO 在实现异步操作时，<strong>只能使用多线程模型</strong>，一个请求对应一个线程。但是，线程的资源是有限且宝贵的，创建过多的线程会增加线程切换的开销。<br><strong>优点</strong>：模型比较简单，在线程阻塞时，消耗 cpu 较少。<br><strong>缺点</strong>：高并发时容易耗尽线程资源, 且大量线程会引起线程切换的巨大开销, 造成响应不及时。</p><p>类比：类比于吃饭排队打饭，需要等待。</p><h2 id="1-2-同步非阻塞式-IO（NIO）"><a href="#1-2-同步非阻塞式-IO（NIO）" class="headerlink" title="1.2 同步非阻塞式 IO（NIO）"></a>1.2 同步非阻塞式 IO（NIO）</h2><p>​<img src="/../../images/Netty/Netty%20IO%E6%A8%A1%E5%9E%8B-2.png">​</p><p>如上图所示，应用进程向内核发起 I&#x2F;O 请求后不再会同步等待结果，而是会立即返回，通过轮询的方式获取请求结果。NIO 相比 BIO 虽然大幅提升了性能，但是轮询过程中大量的系统调用导致上下文切换开销很大。所以，单独使用非阻塞 I&#x2F;O 时效率并不高，而且随着并发量的提升，非阻塞 I&#x2F;O 会存在严重的性能浪费。</p><ul><li>优点: 把应用线程的 read 调用, 分割出了第一步和第二步, 应用线程可以做更多实时的控制。</li><li>缺点: 第一步中的轮询, 大量占用 CPU 时间, 降低系统资源利用率, 所以一般 web 服务器也不使用这样的 NIO。</li></ul><h2 id="1-3-IO-多路复用"><a href="#1-3-IO-多路复用" class="headerlink" title="1.3 IO 多路复用"></a>1.3 IO 多路复用</h2><p>IO 多路复用，是一种同步 IO 模型，由操作系统提供相关的能力，当线程监听的多个 IO 文件描述符中有部分 IO 数据就绪后，操作系统就会通知对应的线程进行读取数据。线程在读取数据的过程中，是同步阻塞读取的。如果没有 IO 就绪，则应用线程阻塞。如下图：</p><ol><li><p>应用线程调用 Linux 提供的相关方法，注册监听 IO。</p></li><li><p>当 IO 数据就绪后，Linux 通知对应的线程。</p><p> 用户线程阻塞式的调用 Linux 的 read 方法，读取 IO 数据。<br> ​<img src="/../../images/Netty/Netty%20IO%E6%A8%A1%E5%9E%8B-3.png">​</p></li></ol><blockquote><p>I&#x2F;O 多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但 select，poll，epoll 本质上都是同步 I&#x2F;O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I&#x2F;O 则无需自己负责进行读写，异步 I&#x2F;O 的实现会负责把数据从内核拷贝到用户空间</p></blockquote><h2 id="1-4-信号驱动IO"><a href="#1-4-信号驱动IO" class="headerlink" title="1.4 信号驱动IO"></a>1.4 信号驱动IO</h2><p>​<img src="/../../images/Netty/Netty%20IO%E6%A8%A1%E5%9E%8B-4.png">​</p><p>信号驱动 I&#x2F;O 并不常用，它是一种半异步的 I&#x2F;O 模型。在使用信号驱动 I&#x2F;O 时，当数据准备就绪后，内核通过发送一个 SIGIO 信号通知应用进程，应用进程就可以开始读取数据了。</p><h2 id="1-5-异步IO（AIO）"><a href="#1-5-异步IO（AIO）" class="headerlink" title="1.5 异步IO（AIO）"></a>1.5 异步IO（AIO）</h2><p>​<img src="/../../images/Netty/Netty%20IO%E6%A8%A1%E5%9E%8B-5.png">​</p><p>异步 I&#x2F;O 最重要的一点是从内核缓冲区拷贝数据到用户态缓冲区的过程也是由系统异步完成，应用进程只需要在指定的数组中引用数据即可。<strong>异步 I&#x2F;O 与信号驱动 I&#x2F;O 这种半异步模式的主要区别</strong>：信号驱动 I&#x2F;O 由内核通知何时可以开始一个 I&#x2F;O 操作，而异步 I&#x2F;O 由内核通知 I&#x2F;O 操作何时已经完成。</p><p>在Linux中，AIO的方式发展还未成熟，相比于NIO来说，性能提升较小。</p><p>类比：比如吃饭点餐的包厢模式，服务员会将餐送至包厢</p><h1 id="2-select-poll-epoll"><a href="#2-select-poll-epoll" class="headerlink" title="2 select&#x2F;poll&#x2F;epoll"></a>2 select&#x2F;poll&#x2F;epoll</h1><p>前文中 IO 多路复用，用户线程需要使用 Linux 系统提供的能力，来注册此线程监听的 IO，当对应的 IO 数据就绪后，Linux 通知对应的线程。此种能力即 select&#x2F;poll&#x2F;epoll 方法。</p><p>在netty中，linux平台下一般推荐使用Epoll实现，因为Netty任务在Linux平台下，Epoll实现性能更好。具体可表现为：</p><ol><li>JDK NIO是默认水平触发，而netty实现是默认边缘触发，并且可与水平触发切换。</li><li>netty实现垃圾回收更少。</li></ol><h2 id="2-1-select"><a href="#2-1-select" class="headerlink" title="2.1 select"></a>2.1 select</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">select</span> <span class="hljs-params">(<span class="hljs-type">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="hljs-keyword">struct</span> timeval *timeout)</span>;<br></code></pre></td></tr></table></figure><p><strong>函数参数</strong>：</p><ul><li><p>Readfds：内核检测该集合中的 IO 是否可读。如果想让内核帮忙检测某个 IO 是否可读，需要手动把文件描述符加入该集合。</p></li><li><p>Writefds：内核检测该集合中的 IO 是否可写。同 readfds，需要手动把文件描述符加入该集合。</p></li><li><p>Exceptfds：内核检测该集合中的 IO 是否异常。同 readfds，需要手动把文件描述符加入该集合。</p></li><li><p>Nfds：以上三个集合中最大的文件描述符数值 + 1，例如集合是{0,1,5,10}，那么 maxfd 就是 11</p></li><li><p>Timeout：用户线程调用 select 的超时时长。</p><ul><li>设置成 NULL，表示如果没有 I&#x2F;O 事件发生，则 select 一直等待下去。</li><li>设置为非0的值，这个表示等待固定的一段时间后从 select 阻塞调用中返回。</li><li>设置成 0，表示根本不等待，检测完毕立即返回。</li></ul></li></ul><p><strong>函数返回值</strong>：</p><ul><li>大于0：成功，返回集合中已就绪的 IO 总个数</li><li>等于-1：调用失败</li><li>等于0：没有就绪的 IO</li></ul><p><strong>执行逻辑</strong>：</p><p>Select 函数是操作系统提供的，监视 IO 的相关方法。Select 函数监视的文件描述符分3类，分别是 writefds、readfds、和 exceptfds</p><ol><li><p>当用户 process 调用 select 的时候，select 会将需要监控的 readfds 集合拷贝到内核空间</p></li><li><p>内核会遍历用户传来的 IO 集合，检查是否有 IO 事件：</p><ol><li>如果无 IO 事件就绪，则阻塞用户线程。</li><li>如果有 IO 事件就绪，则返回就绪事件的个数，并唤醒用户线程。</li><li>用户线程被唤醒后，遍历检查所有的 IO 事件，然后针对就绪的 IO 进行阻塞处理。</li></ol></li></ol><p><strong>存在问题</strong>：</p><ol><li>每次调用 select，都需要把被监控的 fds 集合从用户态空间拷贝到内核态空间，高并发场景下这样的拷贝会使得消耗的资源是很大的。</li><li>能监听端口的数量有限，单个进程所能打开的最大连接数由 FD_SETSIZE 宏定义，监听上限就等于 fds_bits 位数组中所有元素的二进制位总数，其大小是32个整数的大小（在32位的机器上，大小就是3232，同理64位机器上为3264）</li><li>由于 select 函数返回的结果是 io 就绪个数，所以用户线程需要在被唤醒后，再次遍历所有 io，检查是否就绪，性能较差。</li></ol><h2 id="2-2-poll"><a href="#2-2-poll" class="headerlink" title="2.2 poll"></a>2.2 poll</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">struct pollfd &#123;<br>　　 <span class="hljs-type">int</span> fd;           <span class="hljs-comment">/*文件描述符*/</span><br>　　 <span class="hljs-type">short</span> events;     <span class="hljs-comment">/*监控的事件*/</span><br>　　 <span class="hljs-type">short</span> revents;    <span class="hljs-comment">/*监控事件中满足条件返回的事件*/</span><br>&#125;;<br><span class="hljs-type">int</span> <span class="hljs-title function_">poll</span><span class="hljs-params">(struct pollfd *fds, unsigned <span class="hljs-type">long</span> nfds, <span class="hljs-type">int</span> timeout)</span>;   <br></code></pre></td></tr></table></figure><p><strong>函数参数</strong>：</p><ul><li>Fds：struct pollfd 类型的数组, 存储了待检测的文件描述符，struct pollfd 有三个成员：</li><li>Fd：委托内核检测的文件描述符</li><li>Events：委托内核检测的 fd 事件（输入、输出、错误），每一个事件有多个取值</li><li>Revents：这是一个传出参数，数据由内核写入，存储内核检测之后的结果</li><li>Nfds：描述的是数组 fds 的大小</li><li>Timeout: 指定 poll 函数的阻塞时长<ul><li>一直阻塞，直到检测的集合中有就绪的 IO 事件，然后解除阻塞函数返回</li><li>不阻塞，不管检测集合中有没有已就绪的 IO 事件，函数马上返回</li><li>大于0：表示 poll 调用方等待指定的毫秒数后返回</li></ul></li></ul><p><strong>函数返回值</strong>：</p><ul><li>-1：失败</li><li>大于0：表示检测的集合中已就绪的文件描述符的总个数</li></ul><p><strong>执行逻辑</strong>：</p><p>Poll 的整体逻辑与 select 类似，区别就是函数参数中 fds 集合的形式变化了，使用了 struct pollfd 类型的数组，而不是 select 的 fd_set 结构，使得 poll 支持的 fds 集合限制远大于 select 的1024。</p><p><strong>存在问题</strong>：</p><ul><li>Poll 解决了 select 的 fds 集合大小限制文件，但是从实现来看，依旧存在大量描述符数组被整体复制于用户态和内核态的地址空间之间，以及个别描述符就绪触发整体描述符集合的遍历的低效问题。在大量 IO 并发的场景下，poll 的性能会随着 IO 数量的增多而降低。</li></ul><h2 id="2-3-epoll"><a href="#2-3-epoll" class="headerlink" title="2.3 epoll"></a>2.3 epoll</h2><h3 id="2-3-1-概念"><a href="#2-3-1-概念" class="headerlink" title="2.3.1 概念"></a>2.3.1 概念</h3><p>Epoll 接口是为解决 Linux 内核处理大量文件描述符而提出的方案。该接口属于 Linux 下多路 I&#x2F;O 复用接口中 select&#x2F;poll 的增强。Epoll 在 Linux 内核中构建了一个文件系统（eventpoll），采用红黑树的形式，组织文件描述符。当有网络连接增加或删除时，通过修改红黑树中文件描述符来修改对 io 的监听。其基本结构如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// file：fs/eventpoll.c</span><br>struct eventpoll &#123; <br>    <span class="hljs-comment">//sys_epoll_wait用到的等待队列</span><br>    wait_queue_head_t wq;<br>    <span class="hljs-comment">//接收就绪的描述符都会放到这里</span><br>    struct list_head rdllist;<br>    <span class="hljs-comment">//每个epoll对象中都有一颗红黑树</span><br>    struct rb_root rbr;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>当 io 就绪后，需要唤醒对应的用户线程来处理 io 数据，因此在 eventpoll 中就存在 wq 队列，用户存储用户线程，方便后续 io 就绪后唤醒对应的线程<br>Select&#x2F;poll 效率较低的原因就是在 io 就绪后，线程无法知道具体哪个 socket io 就绪，需要遍历寻找就绪的 io。Epoll 为解决此问题，在 eventpoll 中引入一个就绪队列 rdlist，当 scoket 就绪后，会将此 io 事件放到 rdlist 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">epol_create()<br>epoll_ctl()<br>epoll_wait()<br></code></pre></td></tr></table></figure><p>Epoll 接口提供以上三个函数，其中：</p><ol><li><code>epol_create()</code> 函数提供创建 epoll 文件系统功能，即在 linux 内核中初始化创建一个红黑树，用户存储文件描述符。</li><li><code>epoll_ctl()</code> 函数提供对红黑树的增删功能，即当有连接断开等事情发生时，需要操作 epoll 文件系统改变监听的文件描述符。</li><li><code>epoll_wait()</code> 函数提供返回就绪 io 事件功能，如果 eventpoll 中 rdlist 已经引用了 socket，那么 epoll_wait 直接返回就绪 io 数量，如果 rdlist 为空，阻塞进程。<br>综上，整体逻辑如下：</li><li>用户使用 <code>epol_create()</code> 函数，在 linux 内核中创建 eventpoll。</li><li>用户使用 <code>epoll_ctl()</code> 函数在 eventpoll 中新增或删除相关的 io 文件描述符。</li><li>用户线程使用 <code>epoll_wait()</code> 函数，等待返回就绪 io。<ol><li>Eventpoll 会将其加入到 wq 队列中，阻塞用户线程。</li><li>当 socket 接收到数据时，中断回调程序一方面修改 rdlist“就绪列表”，另一方面唤醒 eventpoll 等待队列中的用户线程</li><li>用户线程唤醒后，根据 rdlist 可知哪些 io 事件就绪了，省去遍历所有 io 事件操作，提高效率。</li></ol></li></ol><h3 id="2-3-2-水平触发与边缘触发"><a href="#2-3-2-水平触发与边缘触发" class="headerlink" title="2.3.2 水平触发与边缘触发"></a>2.3.2 水平触发与边缘触发</h3><p>水平触发与边缘触发是指数据就绪后，通知次数：</p><ul><li><strong>边缘触发</strong>(edge-triggered)：当文件描述符关联的读内核缓冲区由空转化为非空的时候，则发出可读信号进行通知，<br>当文件描述符关联的内核写缓冲区由满转化为不满的时候，则发出可写信号进行通知</li><li><strong>水平触发</strong>(level-trggered)：只要文件描述符关联的读内核缓冲区非空，有数据可以读取，就一直发出可读信号进行通知，<br>当文件描述符关联的内核写缓冲区不满，有空间可以写入，就一直发出可写信号进行通知<br>LT 模式支持阻塞和非阻塞两种方式。Epoll 默认的模式是 LT<br>由于信号发送不同，所以在进行<strong>编码</strong>时也存在不 s 同：</li><li>当水平触发模式下，代码可以从缓存取读取定长的数据，不用担心缓冲区数据未读取完毕，当数据未读完时，会一直发送读取信号。</li><li>当边缘触发模式下，在接受到读取信号时，需要使用循环，一直读取，保证缓冲区中数据读取完毕。因为边缘触发只发送一次信号，如果不读取完毕，则数据会不完整。</li></ul><h3 id="2-3-3-epoll-高效的原因"><a href="#2-3-3-epoll-高效的原因" class="headerlink" title="2.3.3 epoll 高效的原因"></a>2.3.3 epoll 高效的原因</h3><ol><li>功能分离：使用 <code>epoll_ctl</code> 维护等待队列，再调用 <code>epoll_wait</code> 阻塞进程</li><li>就绪列表：使用就绪列表，来清晰的获取哪个 io 描述符存在就绪事件，避免不必要的遍历。</li><li>红黑树结构：对文件描述符的增删是 logN 的时间。</li></ol><h1 id="3-Netty-IO模型"><a href="#3-Netty-IO模型" class="headerlink" title="3 Netty IO模型"></a>3 Netty IO模型</h1><p>Netty 的 I&#x2F;O 模型是基于非阻塞 I&#x2F;O 实现的，底层依赖的是 JDK NIO 框架的多路复用器 Selector。一个多路复用器 Selector 可以同时轮询多个 Channel，采用 epoll 模式后，只需要一个线程负责 Selector 的轮询，就可以接入成千上万的客户端。</p><p>在 I&#x2F;O 多路复用的场景下，当有数据处于就绪状态后，需要一个事件分发器（Event Dispather），它负责将读写事件分发给对应的读写事件处理器（Event Handler）。事件分发器有两种设计模式：Reactor 和 Proactor，<strong>Reactor 采用同步 I&#x2F;O， Proactor 采用异步 I&#x2F;O</strong>。</p><p>Reactor 实现相对简单，适合处理耗时短的场景，对于耗时长的 I&#x2F;O 操作容易造成阻塞。Proactor 性能更高，但是实现逻辑非常复杂，目前主流的事件驱动模型还是依赖 select 或 epoll 来实现。</p><p>​<img src="/../../images/Netty/Netty%20IO%E6%A8%A1%E5%9E%8B-6.png">​</p><p>上图所描述的便是 Netty 所采用的主从 Reactor 多线程模型，所有的 I&#x2F;O 事件都注册到一个 I&#x2F;O 多路复用器上，当有 I&#x2F;O 事件准备就绪后，I&#x2F;O 多路复用器会将该 I&#x2F;O 事件通过事件分发器分发到对应的事件处理器中。该线程模型避免了同步问题以及多线程切换带来的资源开销，真正做到高性能、低延迟。</p><h2 id="3-1-Netty-相比-JDK-NIO-有哪些突出的优势。"><a href="#3-1-Netty-相比-JDK-NIO-有哪些突出的优势。" class="headerlink" title="3.1 Netty 相比 JDK NIO 有哪些突出的优势。"></a>3.1 Netty 相比 JDK NIO 有哪些突出的优势。</h2><ul><li><strong>易用性。</strong>  我们使用 JDK NIO 编程需要了解很多复杂的概念，比如 Channels、Selectors、Sockets、Buffers 等，编码复杂程度令人发指。相反，Netty 在 NIO 基础上进行了更高层次的封装，屏蔽了 NIO 的复杂性；Netty 封装了更加人性化的 API，统一的 API（阻塞&#x2F;非阻塞） 大大降低了开发者的上手难度；与此同时，Netty 提供了很多开箱即用的工具，例如常用的行解码器、长度域解码器等，而这些在 JDK NIO 中都需要你自己实现。</li><li><strong>稳定性。</strong>  Netty 更加可靠稳定，修复和完善了 JDK NIO 较多已知问题，例如臭名昭著的 select 空转导致 CPU 消耗 100%，TCP 断线重连，keep-alive 检测等问题。</li><li><strong>可扩展性。</strong>  Netty 的可扩展性在很多地方都有体现，这里我主要列举其中的两点：一个是可定制化的线程模型，用户可以通过启动的配置参数选择 Reactor 线程模型；另一个是可扩展的事件驱动模型，将框架层和业务层的关注点分离。大部分情况下，开发者只需要关注 ChannelHandler 的业务逻辑实现。</li></ul><h2 id="3-2-更低的资源消耗"><a href="#3-2-更低的资源消耗" class="headerlink" title="3.2 更低的资源消耗"></a>3.2 更低的资源消耗</h2><p>作为网络通信框架，需要处理海量的网络数据，那么必然面临有大量的网络对象需要创建和销毁的问题，对于 JVM GC 并不友好。为了降低 JVM 垃圾回收的压力，Netty 主要采用了两种优化手段：</p><ul><li><strong>对象池复用技术。</strong>  Netty 通过复用对象，避免频繁创建和销毁带来的开销。</li><li><strong>零拷贝技术。</strong>  除了操作系统级别的零拷贝技术外，Netty 提供了更多面向用户态的零拷贝技术，例如 Netty 在 I&#x2F;O 读写时直接使用 DirectBuffer，从而避免了数据在堆内存和堆外内存之间的拷贝。</li></ul><p>因为 Netty 不仅做到了高性能、低延迟以及更低的资源消耗，还完美弥补了 Java NIO 的缺陷，所以在网络编程时越来越受到开发者们的青睐。</p><p>‍</p>]]></content>
    
    
    <categories>
      
      <category>技术框架</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
